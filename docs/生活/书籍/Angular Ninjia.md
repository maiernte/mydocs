[TOC]

（供学习和研究使用，请阅读后自行删除此文档）

想成为一个忍者，嗯？好吧，那你找对人了！

但是我们有很长的路要走，你和我，途中有许多东西需要学习.

我们正处于Web开发领域的一个激动人心的时代。一个新的Angular出现了。它完全重写了旧有的AngularJS。为什么要完全重写？AngularJS 1.x难道还不够吗？

我非常喜欢旧的AngularJS。在我们的小公司中，我们用它构建了好几个项目，我们也贡献了代码到核心框架中，并且培训了数以百计的开发者（是的，千真万确），我们甚至还写了一本关于它的书。

完全掌握AngularJS之后，其所带来的生产力是难以置信的。尽管如此，我们也不应对其弱点视而不见。AngularJS并不完美，它有许多难懂的概念需要掌握，并且还有许多难以避免的陷阱。

最重要的是，自从AngularJS出现之后，Web已经有了更新的变化。JavaScript也已经有了变化。一些具有很棒的思想或者拥有更好实现的新框架出现了。我们并不是那种告诉你你应该使用这个工具而不是那个工具的开发者。我们只是碰巧非常了解一些工具，并且也知道我们的项目需要什么。AngularJS就是这些工具之一，它让我们能够构建出经过良好测试的web应用，并且这个构建过程很快。我们也曾将其用于其不适合的地方。不要责备我们，这是不可避免的事情。

在我们未来的项目中，我们是否要毫不犹豫地去使用Angular作为我们工具呢？现在很难说，因为这个框架确实非常年轻，其生态系统也刚刚开始爆发。

但是Angular有许多有意思的点，还有其它一些框架拥有的一些好东西。它一开始就是为明天的Web来设计的，ECMAScript 6、Web组件和移动应用都被考虑在内。当它第一次发布的时候，我也和许多人一样，为2.0版本并非是简单的升级而沮丧。

但是我也非常渴望看到才华横溢的Google团队将会带给我们什么样的解决方案。

所以我就开始写这本电子书，几乎就在第一次提交之后，读设计文档、看会议视频、回顾从一开始的每次提交。我的第一本电子书是关于AngularJS 1.x的，那个时候它就已经是一个稳定且名身在外的巨兽了。这次非常不同，Angular起始于甚至连其设计者的思想都不是很清楚的状态下。因为我知道要学习很多东西，其中不仅仅是关于Angular的，还有关于将塑造未来Web开发模式的一些概念，其中的一些与Angular并没有什么关系。我做到了。我必须对其中的一些概念深入挖掘，并且我也希望你能像我一样享受学习它们的这个过程，并且搞清楚它们和Angular之间的关系。

这本电子书的目的在于同Angular一同进化。如果最终证明Angular是我们希望的那样棒的框架，你将会收到本书的更新，其中会包含最佳实践和新出现的一些特性（也会有更少的打印错误，尽管经过我们大量的检查，但是有一些可能还会留下）。并且我非常期待能得到你们的反馈------比如一些章节不够清楚，你发现了一个错误或者对于某些部分你有更好的方式去阐述。

尽管如此，我对样例代码是相当自信的，因为它们都是来自于真实的项目，并且经过了数以百计的单元测试。这是写一本关于新生框架的电子书的唯一的方式，这样才能够抓住每个版本中出现的问题。

即使你最终并没有选择Angular，我也非常确信你能在阅读的过程中学到一样或两样有用的东西。

如果你已经购买了"Pro Package"（谢谢！），你会随着本书，一点一点地构建一个小的应用。应用的名字叫做PonyRacer，它是一个你可以对小马赛跑比赛进行下注的站点。你甚至可以在这里测试这个应用！继续前进吧，我会等你的。

有意思，不是吗？

但是它不仅仅是一个有意思的引用，它还是一个完整的应用。你需要写组件、表单、测试、使用路由，调用HTTP接口（我们已经构建好的）甚至使用WebSockets。这个应用中包含了你开发一个真实应用所需要的所有的部分。每个练习都带有一个框架，一堆的指令和几个测试。一旦通过所有的测试，你就完成了练习。

Pro Pack的前6个练习时免费的。其它的只有在你购买了我们的在线培训之后才能访问。在每章的最后，我们将链接到与相关章节相关的Pro Pack的练习，免费的会有如下的标签：，其它的会有如下的标签：。

如果你没有购买"Pro package"，没有关系：你会学到所有需要的东西。但是你就不会构建出这个带有漂亮的像素艺术小马的出色的应用了。你是的损失：）！

你将很快看到，Angular本身之外，我们试图解释这个框架所使用的核心概念。第一章甚至没有讨论到Angular：它们就是我所说的"概念章节"，在这里通过介绍在我们领域中新的和令人激动的正在发生的事物来刷新你的认识。

然后我们将慢慢地构建我们的框架知识，包含组件、模版、管道、表单、http、路由、测试......

最后，我们将学习高级主题。但是那是另一回事了。

就介绍到这里吧，让我们以即将改变我们编码方式的ECMAScript 6开始说起吧。

注意：本电子书的例子使用Angular 5.2.0

# ECMASCRIPT 6 简介

如果你读到这里，我们就能够确定你听说过JavaScript。我们所称的JS是一个标准规范的实现，这个规范就是ECMAScript。你最了解的规范版本是这些年一直在使用的5。

但是最近，一个新版本的规范正在起草当中，叫做ECMASCRIPT 6，ES6或者ECMASCRIPT 2015。从现在开始，我们主要使用ES6来代指此规范，因为这是最受欢迎的引用方式。ES6为JavaScript增加了很多特性，像是类、常量、箭头函数、生成器...新增加的东西太多了，以至于我们不能涉及它们的全部，因为那会花费一整本书的篇幅。但是Angular最初的设计就利用了全新JavaScript版本带来的好处。同时，尽管你仍旧能够使用旧的JavaScript，但是如果你使用ES6，你就会得到更多惊喜。所以我们会在本章话费一些时间来理解什么是ES6，以及当我们构建一个Angular应用的时候，那些特性能够帮上忙。

那就意味着我们会将一堆东西先放在一边，我们也不会对其它的内容太深入，但是这是一个非常棒的起点。如果你已经已经了解了ES6，你可以跳过这些页。如果你还不知道ES6，即使你将来并未将Angular作为你的工具，你也会学到很多对你有用的东西。

## 翻译器

ES6刚刚达到其最终状态，各浏览器还没有对齐提供完善的支持。当然，总有些浏览器会走在后面（这一次，微软在Edge上做了不错的工作）。你可能会想：如何去应用这些新特性，是否需要对我能用哪些特性倍加小心呢？你是对的，能够忽略老浏览器的应用并不多。但是，因为几乎每个尝试过ES6的JS开发者都想要写ES6应用，所以社区出现了一种解决方案：翻译器。

翻译器将ES6元代码转换成在任何浏览器上都能运行的ES5代码。它甚至能够生成源码映射文件，这样就可以在浏览器中直接调试ES6元代码了。本书写作时，翻译ES6代码有两个主要的选项：

-   Traceur，一个Google的项目

-   Babeljs，一个叫做Sebastian McKenzie（当时他17岁，没错，这也伤到我了）年轻开发者开启的项目，也有很多其他人对这个项目做除了贡献。

它们各有长短。比如，Babeljs比Traceur会生成可读性更好的源代码。但是Traceur是一个Google项目，所以Angular和Traceur注定会配合地很好。Angular自身的源代码起初是用Traceur翻译的，后来就转换到TypeScript了。TypeScript微软开发的一个开源语言。它是一个Javacript超集，最终会被编译成普通的Javascript代码，我们稍后就会深入研究它。

坦诚地说，Babel比Traceur能量更足，所以我建议你使用它。它很快就会成为本领域的事实标准。

如果你想要把玩ES6，或者在你的一个项目中使用它，那就研究一下这些翻译器，并在你的构建中添加一个构建步骤。它会将你的ES6代文件翻译成等价的ES5代码。总体来说效果非常不错，当然，有一些新的特性并不能轻易地或者不可能转换成ES5。然而，当前的状态已经足够好了，我们可以放心使用，下面就让我们看一下我们能在Javascript中把玩的新玩意儿吧！

## let

如果你已经写过一段时间的JS，那么你就会知道var声明有点奇怪。在多数的其它语言中，一个变量是在其声明的位置被声明的。但是在JS中有一个概念，叫做"声明提升"，其效果就是尽管你是在后面的位置声明了一个变量，但是真正的声明却是发生在函数的顶部。

所以，在if块中声明一个像name的变量：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonyFullName(pony) {

if (pony.isChampion) {

var name = 'Champion ' + pony.name;

return name;

}

return pony.name;

}

等价于将其在函数的顶部声明：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonyFullName(pony) {

var name;

if (pony.isChampion) {

name = 'Champion ' + pony.name;

return name;

}

// name在这里依旧可以访问到

return pony.name;

}

ES6引入了一个新的关键词用于变量声明，let，它的行为更符合你的预期：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonyFullName(pony) {

if (pony.isChampion) {

let name = "Champion " + pony.name;

return name;

}

// 这里是访问不到name的

return pony.name;

}

现在变量name已经被限制在它所在的块中了。长期来看let的引入是用于完全替代var的，所以你现在就可以丢掉老的var关键词并开始使用let了。好消息是，更换成let的过程应该是无感的，如果你遇到问题，很有可能是你的代码出现了问题！

## 常量

刚刚我们提到了新的关键词和变量，正好有一个相关的有趣主题。ES6引入了const关键词来声明常量！当你使用const来声明一个变量的时候，它就必须被初始化，并且后续也不能给它赋一个不同的值。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const poniesInRace = 6;\
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

poinesInRace = 7; // 语法错误

和用let声明的变量一样，常量并不会被提升，仅仅是块级声明。

一件小事情可能会让你感到惊讶：你可以使用对象来初始化一个常量，随后你可以更改对象的内容：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const PONY = {};

PONY.color = 'blue'; // 没有问题

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

但是你不能赋予其另一个对象：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const PONY = {};

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

PONY = {color: 'blue'} // 语法错误

数组也是同样的道理：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const PONIES = \[\];

PONIS.push({color: 'blue'}); // 没有问题

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

PONIES = \[\] // 语法错误

## 创建对象

虽然不是一个新的关键词，但是当你读ES6代码的时候也会引起你的注意。如果要创建的对象的属性和代表其值的变量名相同的时候，就有一种创建对象的简写方法。

例子

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function createPony() {

const name = 'Rainbow Dash';

const color = 'blue';

return {name: name, color: color};

}

可以被简写成

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function createPony() {

const name = 'Rainbow Dash';

const color = 'blue';

return {name, color};

}

## 解构赋值

这个新特性也会在你阅读ES6代码的时候引起你的注意。现在有一种从对象或者数组赋值到变量的简写方式。

在ES5中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var httpOptions = {timeout: 2000, isCache: true};

// 后续

var httpTimeout = httpOptions.timeout;

var httpCache = httpOptions.isCache;

现在，ES6中你可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const httpOptions = {timeout: 2000, isCache: true};

const {timeout: httpTimeout, isCache: httpCache} = httpOptions;

两种写法的效果是一样的。这种写法能有点儿混乱，键是在对象中要搜寻的属性，而值却是要赋值的变量。但是这工作地很好！有一种更好的写法：如果你想要赋值的变量名和属性名相同，你就可以进一步简写为：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const httpOptions = {timeout: 2000, isCache: true};

// 后续

const {timeout, isCache} = httpOptions;

// 现在你有了一个叫做'timeout'的变量

// 和一个叫做'isCache'的变量，它们都具有正确的值

更酷的是嵌套对象也是可以这样用的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const httpOptions = {timeout: 2000, cache: {age: 2}};

// 后续

const {cache: { age }} = httpOptions;

// 你现在有了一个叫做'age'的变量，其值是2

数组也是同样的道理：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const timeouts = \[1000, 2000, 3000\];

// 后续

const \[shortTimeout, mediumTimeout\] = timeouts;

// 你现在有了一个叫做'shortTimeout'的变量，其值为1000

// 和一个叫做'mediumTimeout'的变量，其值为2000

当然对于数组中的数组，或者对象中的数组也是没有问题的。

这种特性的一个有趣的应用就是多值返回。假设一个函数randomPonyRace同时返回小马对象和其在比赛中的位置。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_function randomPonyInRace() {

const pony = {name: 'Rainbow Dash'};

const position = 2;

// ...

return {pony, position};

}

const {position, pony} = randomPonyInRace();

这里的解构特性将方法返回的position赋值给position变量，将方法返回的pony赋值给pony变量！如果你不关心位置，你可以这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function randomPonyInRace() {

const pony = {name: 'Rainbow Dash'};

const position = 2;

//...

Return {pony, position};

}

const { pony } = randomPonyInRace();

现在你就只有pony了！

## 默认的参数和值

JavaScript的一个特点就是允许开发者用任意数量的参数来调用函数。

-   如果你传递了比参数列表更多的变量，那么多出来的变量会被忽略掉（严格来说，你还是可以通过特殊的arguments变量来使用它们的）。

-   如果你传递了比参数列表的数量少的变量，缺失的参数会被设置为undefined。

后一种情况是和我们更加相关的。通常，如果参数是可选的，我们就可以传递更少的变量，就像下面的例子一样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonies(size, page) {

size = size \|\| 10;

page = page \|\| 1;

//...

server.get(size , page);

}

可选的参数通常是有一个默认值的。"或"操作符将会在左操作数为undefined的情况下返回右操作数，当没对应的参数没指定时就是这种情况（出于完整性考虑，如果提供的是假值，比如0, false, ""时也是这样）。使用这个技巧，函数getPonies可以像如下一样屌用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getPonies(20, 2);

getPonies(); // 和getPonies(10, 1)效果相同

getPonies(15); // 和getPonies(15, 1) 效果相同

这工作起来是没有问题的，但是参数是带有默认值的可选参数在这里并没有明显体现出来，我们必须阅读过函数体之后才能确定。ES6引入了一种更加严格的方式来定义默认参数，它直接体现在函数的定义当中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Function getPonies(size = 10, page = 1) {

// ...

server.get(size, page);

}

现在就非常清楚地表明了，如果不提供参数，size的值就是10，page的值就是1.

注意：这里有一点细微的不同，现在0或者""都是合法的值，并不会被默认值所替代。所以新的指定默认参数的方式的行为更像是size = size === undefined ? 10: size;

默认值同样可以是一个函数调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonies(size = defaultSize(), page = 1) {

// 如果没有为size提供值，defaultSize方法就会被调用

// ...

server.get(size, page);

}

也可以是其它变量，既可以是全局变量，或者本函数的其它参数：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonies(size = defaultSize(), page = size - 1) {

// 如果没有为page参数提供值，它就会被设置为

// size参数的值减去1

// ...

server.get(size, page);

}

注意如果你想要访问右边的参数，它们的值会一直是undefined：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function getPonies(size = page, page = 1 ) {

// size会一直是undefined，因为page参数在其右侧

server.get(size, page);

}

参数的这种机制也可以应用到值上，比如当使用解构赋值的时候：

const {timeout = 1000} = httpOptions;

// 现在你得到了一个叫做'timeout'的变量

// 如果httpOptions.timeout能够找到，其值就是httpOptions.timeout

// 否则就是1000

## Rest操作符

ES6引入了一种在函数中定义变量参数的新语法。之前也提到过，你可以向函数传递多余的变量，并且之后通过特殊的arguments变量来获取它们。所以你可能曾经这样做过：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function addPonies(ponies) {

for(var i = 0; I \< arguments.length; i++) {

poniesInRace.push(arguments\[i\]);

}

}

addPonies('Rainbow Dash', 'Pinkie Pie');

但是我觉得我们都会认为这既不美观也不显而易见：由于参数ponies从未被使用过，我们怎么知道我们可以传递多个pony呢？

ES6通过使用rest操作...符给出了一种更好的语法:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function addPonies(...ponies) {\
for (let pony of ponies) {

poniesInRace.push(pony);

}

}

ponies现在已经是一个我们可以在其上迭代的真正数组了。用于迭代的for ... of循环也是ES6的新特性。它能保证我们是在容器的值上进行迭代，而不像for ... in是在容器的属性上进行迭代。难道你不认为我们现在的代码更加美观和显而易见吗？

Rest操作符也可以用于解构数据：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const \[winner, ...losers\] = poniesInRace;

// 假设'poniesInRace'是一个包含多个ponies的数组

// 'winner'会得到第一个pony

// 'losers'将会是一个包含其它元素的数组

Rest操作符不要与展开操作符混淆，稍后会给出一个例子，它们看起来真实太像了！但是延展操作符的功能正好相反：它接受的是一个数组并将其展开为变量参数。我记忆中的例子只有类似于min和max这样的函数，它们接受变长的参数，而你却想将一个数组传递给它的时候会用到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const ponyPrices = \[12, 3, 4\];

const minPrice = Math.min(...ponyPrices);

## 类

最具代表性的新特性之一，我们在写Angular应用的时候将大量使用的特性：ES6将类带入了JavaScript！你现在可以方便地在JavaScript中使用类和继承了。你可以一直使用原型风格的继承，但是那并非一项简单的任务，特别是对于新手而言。\
\
现在它变得非常简单了，看一下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Pony {

constructor(color) {

this.color = color;

}

toString() {

return \`\${this.color} pony\`;

// 看到了吗？这是ES6的另一个好特性，叫做模版字面量

// 我们将很快谈到它！

}

}

const bluePony = new Pony('blue');

console.log(bluePony.toString()); // blue pony

类的定义不同于函数的定义， 并没有声明提升，所以你需要先声明一个类后才能使用它。你可能已经注意到了这个特殊的constructor函数。我们在通过new操作符创建一个新的pony的时候，这个函数就会被调用。这儿它需要一个color，我们通过将color设置为blue来创建了一个Pony实例。一个类也可以有方法，可以在其实例上调用，就像这里的toString()方法。

也可以具有静态的属性和方法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Pony {

static defaultSpeed() {

return 10;

}

}

静态方法只能够由类来直接调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const speed = Pony.defaultSpeed();

如果你想在获取或者设置成员的时候添加一些钩子，可以在类中添加getters和setters：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Pony {

get color() {

console.log('get color');

return this.\_color;

}

set color(newColor) {

console.log(\`set color \${newColor}\`);

this.\_color = newColor;

}

}

const pony = new Pony();

pony.color = 'red';

// 'set color red'

console.log(pony.color);

// 'get color'

// 'red'

当然了，在ES6中，如果有了类，也就有了继承：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Animal {

speed() {

return 10;

}

}

class Pony extends Animal {

}

const pony = new Pony();

console.log(pony.speed()); // 10, Pony继承了父类的方法

Animal称为基类，Pony称为衍生类。正如你所看到的，衍生类拥有基类的方法。也可以重写它们：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Animal {

speed() {

return 10;

}

}

class Pony extends Animal {

speed() {

return super.speed() + 10;

}

}

const pony = new Pony();

console.log(pony.speed()); // 20, Pony覆盖了父类的方法实现

你也看到了，关键词super让我们能够调用基类的方法，这里就是super.speed();

Super关键词也可以在构造器函数中使用，用来调用基类的构造器：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Animal {

constructor(speed) {

this.speed = speed;

}

}

class Pony extends Animal {

constructor(speed, color) {

super(speed);

this.color = color;

{

}

const pony = new Pony(20, 'blue');

console.log(pony.speed()); // 20

## Promises

Promises并不是特别新鲜的事物，你可以已经知道并且使用过它们了，因为它们是AngularJS 1.x的重要部分。由于你将在Angular，甚至在普通的JS中大量地使用它们，我们认为我们需要在这里停留一下。

Promises旨在简化异步编程。我们的JS代码充满了异步，像是AJAX请求，并且通常是通过回调函数来处理结果和错误。但是回调函数的不断嵌套会似的代码越来越乱，越来越难以阅读和维护。Promises比回调函数的方式好多了，因为这种方式会扁平化代码，让代码变得更容易理解。让我们考虑一个简单的使用场景，我们获取一个用户，然后再获取它的权限，然后我们根据获得信息更新一个菜单：

通过使用回调函数的方式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login, function(user) {

getRights(user, function(rights){

updateMenu(rights);

});

});

现在我们用promises来实现，并做一下对比：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

return getRights(user);

})

.then(function(rights) {

updateMenu(rights);

})

我喜欢这个版本，因为你读到什么它就执行什么：我想要获取一个用户，然后获取用户的权限，然后更新菜单。

正如你所看到的，一个promise是一个'thenable'的对象，这就意味着它有一个then方法。这个方法接受两个变量作为参数：一个是成功回调，另一个是拒绝回调。Promise有三种状态：

1.  挂起（pending）：这个promise还没有完成，比如我们的服务器调用还没有完成。

2.  完成（fulfilled）：这个promise成功结束，比如服务器返回了OK HTTP状态。

3.  拒绝（rejected）：这个promise失败，比如服务器返回了一个404状态。

当promise完成的时候，成功回调就会被调用并将结果会作为参数传递给成功回调函数。如果promise被拒绝了，拒绝回调函就会被调用，传给拒绝回调函数的参数是一个值或者一个错误对象。

那么，怎样去创建一个Promise呢？相当简单，有一个新的类叫做Promise，它的构造器接受一个函数，而这个函数接受两个参数，resolve和reject。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const getUser = function(login) {

return new Promise(function(resolve, reject) {

// 异步作业，比如从服务器获取一个用户的信息，返回一个应答

if(response.status === 200) {

> resolve(response.data);
>
> } else {
>
> reject('No user');
>
> }

});

};

一旦你创建好这个Promise，你就可以使用then来注册回调函数了。这个方法可以接受两个参数，这两个参数分别对应于成功或者失败状况下的两个回调函数。这里我们只传递了一个成功回调函数，而忽略了潜在的错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

console.log(user);

})

一旦promise被成功确定，成功回调（这里就是简单地在控制台打印用户信息）就会被调用。

好处在于这种方式扁平化了代码。比如你的确定回调（resolve callback）也返回一个promise，你就可以这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

return getRights(user)

.then(function(rights) {

> return updateMenu(rights);
>
> });

})

这样写更漂亮：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

> .then(function(user) {\
> return getRights(user);
>
> })
>
> .then(function(rights) {
>
> return updateMenu(rights);
>
> })

另一个有趣的事情是错误处理，你可以每个promise都提供一个处理函数，或者对于整个链就提供一个。

对于每个promise都提供一个：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

return getRights(user);

}, function(error) {

console.log(error); // 会在getUser失败的时候调用

return Promise.reject(error);

})

.then(function(rights) {

Return updateMenu(rights);

}, function(error) {

console.log(error); // getRights失败的时候调用

return Promise.reject(error);

})

整个链只有一个处理函数的情况：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

return getRights(user);

})

.then(function(rights) {

return updateMenu(rights);

})

.catch(function(error){

console.log(error); // getUser或getRights失败时会被调用

})

你应该认真的研究一下Promise，因为它们会成为书写API的新方式，每个库都会使用它们。即使是标准库也是这样的：Fetch API就是一个典型的例子。

## 箭头函数

ES6中我非常喜欢的一个特性就是新的箭头函数语法，其使用"胖箭头"操作符（=\>）。对于回调函数和匿名函数简直太有用了！

我们看一下先前的promise的例子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(function(user) {

return getRights(user); // getRights is returning a promise

})

.then(function(rights) {

return udpateMenu(rights);

})

用箭头函数就可以写成这样了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(user =\> getRights(user))

.then(rights =\> updateMenu(rights))

酷吗？简直太酷了！

注意，这里没有函数块，其返回也是隐式调用的：也就是不需要这样写 user =\> return getRights(user)。但是如果我们有了函数块，那么我们就必须显式地使用return了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

getUser(login)

.then(user =\> {

console.log(user);

return getRights(user);

})

.then(rights =\> updateMenu(rights))

它还有一个特殊的用法，与普通函数不一样的能力：this会绑定在词法作用域上，这样就意味着它就不会和其他函数一样会有一个新的this。让我们举一个例子，使用map函数在一个数组上迭代，来找到最大的值。

在ES5中

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var maxFinder = {

max: 0;

find: function(numbers) {

// 在这里迭代

numbers.forEach(function(element){

// 如果element更大，那么就赋值给max

if(element \> this.max) {

this.max = element;

}

> });

}

}

maxFinder.find(\[2, 3, 4\]);

// 打印结果

console.log(maxFinder.max);

你可能认为这个没有问题，但是确实是有问题的。如果你够仔细，你会注意到find函数中的forEach使用了this，但是这个this并没有被绑定到一个对象上。所以this.max并不是maxFinder对象的max。当然，你可以非常容易地解决这个问题，比如使用别名：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var maxFinder = {\
max: 0,

find: function(numbers) {

var self = this;

numbers.forEach(function(element) {

> if(element \> self.max) {\
> self.max = element;
>
> }
>
> });

}

};

maxFinder.find(\[2, 3, 4\]);

// 记录结果

console.log(maxFinder.max);

或者通过绑定this也可以解决此问题：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var maxFinder = {\
max: 0,

find: function(numbers) {

numbers.forEach(function(element){

if (element \> this.max) {

this.max = element;

}

> }.bind(this));

}

};

maxFinder.find(\[2, 3, 4\]);

// 记录结果

console.log(maxFinder.max);

甚至向forEach函数传递第二个参数也可以解决这个问题：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var maxFinder = {

max: 0,

find: function(numbers) {

numbers.forEach(function(element) {

if (element \> this.max) {

this.max = element;

}

> }, this);

}

};

maxFinder.find(\[2, 3, 4\]);

// 记录结果

console.log(maxFinder.max);

现在我们可以使用箭头函数实现一个更加优雅的解决方案：

const maxFinder = {

max: 0,

find: function(numbers) {

numbers.forEach(element =\> {

if(element \> this.max) {

this.max = element;

> }
>
> })

}

};

maxFinder.find(\[2, 3, 4\]);

// 记录结果

console.log(maxFinder.max);

这种特性使得箭头函数称为回调匿名函数实现方式的完美选项。

## 集合和映射

简而言之就是：现在在ES6中你有了真正的集合了。喔！我们过去一直让字典来充当映射的角色，但是现在我们有了Map类了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const cedric = {id: 1, name: 'Cedric'};

const users = new Map();

users.set(cedric.id, cedric); // 添加一个用户

console.log(users.has(cedric.id)); // true

console.log(users.size); // 1\
users.delete(cedric.id); // 删除此用户

现在也有了Set类了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const cedric = {id: 1, name: 'Cedric'};

const users = new Set();

users.add(cedric); // 添加一个用户

console.log(users.has(cedric)); // true

console.log(users.size); // 1

users.delete(cedric); // 删除此用户

你可以使用新的for ... of 语法来迭代一个集合：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

for (let user of users) {\
console.log(user.name);

}

你会看到Angular团队选择for ... of语法在模版中迭代集合。

## 模版字面量

在JavaScript中组合字符串一直是一件让人头疼的事情，我们通常不得不使用连接：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const fullname = 'Miss ' + firstname + ' ' + lastname;

模版字面量是一个新的小特性，这个特性要求使用反勾号，而不是引号或者单引号，这样你就拥有了一个基础的模版系统，并且还是支持多行的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const fullname = \`Miss \${firstname} \${lastname}\`;

多行支持在书写HTML字符串的时候助益良多，我们在写Angular组件的时候经常会用到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const template = \`\<div\>

\<h1\>Hello\</h1\>

\<div\>\`;

## 模块

JS一直缺乏一种将函数组织到名称空间并动态加载代码的方式。NodeJS在这方面一直是领导者，它拥有一个使用CommonJS协定的繁荣的模块生态系统。在浏览器端，也有一个被RequireJS使用的AMD（异步模块定义Asynchronous Module Definition）API。但是它们都不是真正的标准，这样就导致了关于哪个更好的无穷无尽的讨论。

ES6旨在吸收两者的优点来创建一种语法，而不用关心真实的实现。Ecma TC39委员会（负责衍进ES6并维护语言的具体细则）想要一种既好又简单的语法（这正是CommonJS的强项），但是还要支持异步加载（像AMD），还能够支持工具对代码的静态分析，以及对循环依赖更好的支持。新的语法处理了如何向模块导出（export）或如何从模块导入（import）东西。

这里的模块在Angular中非常重要，因为几乎所有的东西都是在模块中定义的，你想要使用它们的时候必须先要导入。比如说我想暴露一个在一场比赛中对某匹小马下注的函数，和一个开始比赛的函数。

在races\_service.js中可以这样写：

export function bet(race, pony) {

// ...

}

export function start(race) {

// ...

}

正如你所看到的，这相当简单：新的关键词export的作用非常直观，它导出了这两个函数。

现在，比如我们的组件之一想要调用这些函数。

在另一个文件中这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import {bet, start} from './races\_service';

// 后续

bet(race, pony);

start(race);

这就叫做命名导出（named export）。这里我们导入了两个函数，我们必须指定包含这两个函数的文件的名字 ------这里就是'races\_service'。当然，如果需要，你也可以只导入一个方法，你甚至还可以给它起一个别名：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import {start as startRace} from './races\_service' ;

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 后续

startRace(race);

如果你想要导入模块中的所有的方法，你可以使用通配符'\*'。

和其它语言一样，必须小心使用通配符，只在你确实需要导入全部或者大部分函数的情况下使用。我们的IDE会分析相关情况，我们不久会看到自动导入（auto-import），这会帮助我们从担心是否导入正确的烦恼中解放出来。

使用通配符的话，你必须使用给它起一个别名，我很喜欢这种限制，因为这使得后面的代码更加清晰：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import \* as racesService from './races\_service';

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 后续

racesService.bet(race, pony);

racesService.start(race);

如果你的模块只暴露了一个函数、值或类，那就不必使用命名导出，你可以利用default关键字。它特别适合和类一起使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// pony.js

export default class Pony {

}

// races\_service.js

import Pony from './pony';

注意到我们省略了大括号来导入了一个**默认的**导出。你可以在导出时指定一个别名，但是为了保持一致，在调用导入的东西时，最好也带着模块名（除非你有多个重名的模块，那么就可以指定一个别名来区分它们）。当然了，你可以将默认导出和命名导出混用，但是显而易见的是每个模块只能有一个默认导出。

在Angular中，你会在你的应用中大量使用这样的导入。每个组件和服务都是一个类，它们通常位于一个独立的文件中并且被导出，如果其它组件需要它们，就需要进行导入。

## 总结

我们对ES6的介绍结束于此。我们跳过了一些部分，但是如果你对本章的内容没有任何问题，那你就可以毫无障碍地使用ES6来写应用了。如果你想要了解更多的关于ES6的内容，我强烈推荐Axel Rauschmayer的Exploring JS，或者Nicholas C. Zakas的Understanding ES... 两本电子书都可以在线免费阅读，但是不要忘记通过购买来支持作者，他们的工作确实很棒！还有，我又重新阅读了Axel的前一本电子书Speaking JS，我又学到了一些东西，如果你也想刷新你的JS技能，我肯定会推荐它的！

# 比ES6更进一步

## 动态、静态和可选类型

你可能听说过，开发Angular应用可以使用ES5、ES6或者是TypeScript。你可能会好奇什么是TypeScript，它又给我们带来了什么。

JavaScript是动态类型的。这就意味着你可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

let pony = 'Rainbow Dash';

pony = 2;

这是能够正常工作的代码。对所有的事情都很好，你可以向函数传递几乎任意的对象，只要对象具有函数需要的属性：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const pony = {name: 'Rainbow Dash', color: 'blue'};

const horse = {'speed': 40, color: 'black'};

const printColor = animal =\> console.log(animal.color);

// 只要对象有\`color\`属性就可以正常工作

这种动态的特征给我们带来了一些非常棒的体验，但是在相较于静态类型语言，其在某些方面也有一些缺点。最明显的可能就是当你从另一个API调用一个未知的函数的时候，你必须阅读其文档（或者，更糟糕的，函数代码）来弄明白其参数应该长什么样。看一下我们先前的例子：方法printColor需要一个具有color属性的参数。我们很难去猜测它，在我们日常工作中，使用伙伴开发者开发的各种库和服务会让这种情况更加棘手。忍者小队的联合创始人之一经常抱怨JS中类型的缺乏，不能像在静态类型环境中那样具有生产力，也不能写出更优质的代码让其倍感遗憾。即使有的时候他会大声指责类型的缺失！但是他的观点也不无道理，如果没有类型信息，IDE就没有可靠的线索来确定你是否出错了，工具也不能帮助你发现代码中的BUG。当然，我们在代码中有测试，并且Angular也一直致力于让测试变得简单，但是完美的测试覆盖率几乎是不可能的。

这就引导我们到了可维护性的主题。即使有测试和文档，JS代码也可能会变得难以维护。与其它静态类型语言相比，重构一个巨大的JS应用不是一件容易的事情。可维护性是一个非常重要的主题，在写代码和维护代码的时候，类型会帮助人们和工具避免错误。Google一直在致力于推动这个领域的新的解决方案：也很好理解，因为他们有世界上最大的Web应用，像是Gmail、Google apps、Maps...所以他们尝试了几种不同的方法来改善前端的可维护性：GWT、Google Closure、Dart...他们都是帮助开发大型Web应用的。

对于Angular来说，Google团队想要帮助我们写出更好的JS，而其方式就是在我们的代码中加入一些类型信息。在JS中这并不是一个新概念，ECMAScript 4的条文中就有这样的主题，但是最后被废弃了。他们首先发布了AtScript，这是一个带有注解（类型注解和其它种类的注解，稍后会提到）的ES6的超集。他们也宣布了对TypeScript的支持，这是一种附加了类型注解的来自于微软的语言。几个月之后，TypeScript团队宣布他们一直在和Google团队紧密合作，新版本（1.5）的语言将会支持AtScript的全部特性。稍后Google团队也宣布官方放弃AtScript，这样TypeScript就变成了开发Angular应用的首选。

## 进入TypeScript

我认为这是非常明智的一步，有这样几个理由。首先，没有人真想去学习另一种语言扩展。TypeScript已经在那里了，有活跃的社区和生态系。我在使用Angular之前从未使用过它，但是我从各种各样的人那里听到过关于它的一些赞誉。TypeScript是一个来自于微软的语言。但是这已经不是鲍尔默和盖茨时代的微软了。这是Nadella时代的微软，这个微软向社区开放，当然了，也向开源开放。Google也知道这点，向一个已经存在的项目作出贡献，而不必耗费精力维护自己的项目，对他们来说是一个更好的选择。并且TypeScript框架也会变得更加受欢迎：你的经历可能会说，双赢。

但是下注TypeScript的主要原因还是它所提供的类型系统。这是一个辅助的可选的类型系统，这样它就不会给你带来任何阻碍。事实上，在用它编码一段时间之后，我都把它忘记了：在开发Angular应用的时候，你可以只在确实需要的时候使用TypeScript（稍后会提到），其它地方你就可以忽略它，直接写纯JS（ES6）就可以了。我确实非常赞赏他们所做的一切，我们将在下一部分中看一下TypeScript提供了什么。最后，你会学到足够多的东西来阅读任意的Angular代码，你也可以在你的应用中选择是否需要使用它。

你可能想知道：在Angular应用中为什么要使用带有类型的代码？举个例子。Angular 1 和2都有一个强大的概念，叫做"依赖注入"。你可能已经非常熟悉它了，这是一种通用的设计模式，它已经被应用于不同语言的不同框架之中了，正如我先前提到的，其已经被用于AngularJS 1.x。

## 一个依赖注入（DI）的实际例子

为了搞清楚什么是依赖注入，可以以一个应用的组件为例，比如说RaceList，这个组件需要访问比赛列表，而这个列表可以由服务RaceService提供。你可能会这样写RaceList:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class RaceList {

constructor() {\
this.raceService = new RaceService();

// 我们假设list()返回一个promise

this.raceService.list()

// 我们将返回的比赛列表存储到\`RaceList\`的一个成员中

.then(races =\> this.races = races);

// 箭头函数FTW！

}

}

但是这种实现有几个缺陷。一种就是可测试性：现在想要用一个假的（伪装的）服务来替代raceService来测试组件，就非常难办了。

如果我们使用**依赖注入**模式，我们将RaceService的创建代理给框架，我们只是简单地请求一个一个实例。现在框架控制着依赖的创建，并将其注入：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class RaceList {

constructor(raceService) {

this.raceService = raceService;

this.raceService.list()

.then(races =\> this.races = races);

}

}

现在，当我们想要测试这个类的时候，我们可以非常容易地传一个假的服务给构造函数：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在一个测试中

const fakeService = {

> list: () =\> {
>
> // returns a fake promise
>
> }

};

const raceList = new RaceList(fakeService);

// 现在我们能够确定比赛列表

// 就是我们用于测试的比赛列表

但是框架怎么知道要向构造函数中注入什么呢？好问题！AngularJS 1.x依靠参数的名字，但是它有一个非常严重的限制，因为压缩代码会改变参数名...你可以使用数组语法来解决这个问题，或者为类添加一个元数据：\
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

RaceList.\$inject = \['RaceService'\];

我们必须为框架添加一些元数据使其理解类需要被注入什么。这就是类型注解所带给我们的：这是一种元数据，它可以给框架一些必要的提示，以使其能够进行正确的注入。在Angular中，使用TypeScript，我们可以这样写我们的RaceList组件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class RaceList {

raceService: RaceService;

races: Array\<string\>;

constructor(raceService: RaceService) {

// 有趣的部分在于\`: RaceService\`

this.raceService = raceService;

this.raceService.list()

.then(races =\> this.races = races);

}

}

现在就可以进行注入了！虽然在Angular中并不要求必须使用TypeScript，但是你使用的话，你的部分代码可能会因此更加优雅。你可以在ES6或者ES5中做到相同的事情，但是你必须用其它方式手动添加相关的元数据（我们后面会介绍关于此主题的更多细节）。

这就是我们为什么要花费一些时间来学习TypeScript（TS）的原因。Angular充分利用了ES6和TS1.5+，这样我们就会在使用它开发应用的时候得心应手了。Angular团队非常希望将这个类型系统提交给标准委员会，所以可能将来的某一天JS中也会有类型，到那时，所有的这些都会变得稀松平常了。

让我们继续深入！

# 深入TYPESCRIPT

TypeScript自从2012年开始就存在了。它是一个JavaScript的超集，给ES5增加了一些新的东西。其中最重要的一个就是这个类型系统，这也就是TypeScript名字的由来。从2015年发布的版本1.5开始，这个库试图称为ES6的超集，其中包含了我们之前章节中看到的所有闪亮的特征，当然还有其它一些新东西，比如说装饰器。写TypeScript和写JavaScript非常像。习惯上，TypeScript文件有一个.ts的扩展名，它们会被编译成标准的JavaScript，一般是在构建期使用TypeScript编译器来完成这项工作。生成的代码极具可读性。

npm install -g typescript

tsc test.ts

好吧，让我们从头开始。

## TypeScript中的类型

在TypeScript中添加类型信息的语法非常直观：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

let variable: type;

类型也非常容易记住：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const ponyNumber: number = 0;

const ponyName: string = 'Rainbow Dash';

在这种情况下类型是可选的，因为TS编译器可以根据它们的值来猜测出来（叫做"类型推断"）。

类型也可以来自于你的应用，就像下面的Pony类一样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const pony: Pony = new Pony();

TypeScript也支持在一些语言中所谓的"泛型"，举一个数组的例子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const ponies: Array\<Pony\> = \[new Pony()\];

这个数组只能包含Pony的实例，泛化符号\<\>中的内容指明了这一点。你可能很想知道为什么要这样做。添加类型信息能够帮助编译器捕获可能的错误：\
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ponies.push('hello') // error TS2345

// 'string'类型的参数值是不可被赋值给'Pony'类型的参数的。

那么，如果你想要一个可以支持多种类型的变量，就没有办法了吗？并非如此，因为TS又一个特恶书的类型，叫做any。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

let changing: any = 2;

changing = true; // 没有问题

这在你并不知道一个值的类型的时候非常有用，不管这个值是来自于动态的内容或者是来自于你使用的一个库。

如果你的变量只能是number或者boolean类型，你可以使用联合类型：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

let changing: number\|Boolean = 2;

changing = true; // 没有问题

## 枚举类型

TypeScript也提供了enum类型。比如，我们应用中的一场比赛的状态可以是ready、started或者是done。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

enum RaceStatus {Ready, Started, Done}

const race = new Race();

race.status = RaceStatus.Ready;

枚举实际上是一个数字值，从0开始。你当然也可以设置你想要的值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

enum Medal {Gold = 1, Silver, Bronze}

## 返回值的类型

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function startRace(race: Race): Race {

race.status = RaceStatus.Started;

return race;

}

如果函数不返回任何东西，你可以使用void来指明：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function startRace(race: Race): void {

race.status = RaceStatus.Started;

}

## 接口

但是正如我之前所提到的，JavaScript的动态特性也非常棒。如果一个对象有函数需要的对应属性就可以传递给相应的函数调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function addPointsToScore(player, points) {

player.score += points;

}

只要一个对象有score属性，就可以将其传递给这个函数作为参数。如何在TypeScript中实现同样的效果呢？很简单：定义一个接口，它就像对象的"形状"一样。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function addPointsToScore(player: {score: number;}, points: number): void {

player.score += points;

}

这样就意味着提供的参数必须有一个名为score的参数，并且要求其类型为数字。当然你也可以给接口起一个名字，然后再引用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

interface HasScore {

score: number;

}

function addPointsToScore(player: HasScore, points: number): void {

player.score += points;

}

## 可选参数

JavaScript的另一个特点就是参数是否需要指定值是可选的。你可以忽略它们，不给他们传值，它们就是undefined。但是再TypeScript中定义了一个具有类型参数的函数，如果你不提供对应的参数值，那么编译器可就会不高兴了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

addPointsToScore(player); // error TS2346

// 提供的参数与调用对象的任何签名都不匹配

要指明一个函数中的某个参数（或者是接口中的某个属性）是可选的，你可以在参数的后面加上?。这里，points参数是可选的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function addPointsToScore(player: HasScore, points?:number) : void {

points = points \|\| 0;

player.score += points;

}

## 作为属性的函数

你可能也会要求一个参数必须包含某个方法，而不是属性：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function startRunning(pony) {

pony.run(10);

}

接口定义会是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

interface CanRun {

run(meters: number): void;

}

function startRunning(pony: CanRun): void {

pony.run(10);

}

const ponyOne = {

run: (meters) =\> logger.log(\`pony runs \${meters}m\`)

};

startRunning(ponyOne);

## 类

一个类可以实现一个接口。对我们来说，Pony类应该实现会跑（run）才对，所以我们这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Pony implements CanRun {

run(meters) {

logger.log(\`pony runs \${meters}m\`);

}

}

编译器会强制要求我们在类中实现一个run方法。如果我们提供了错误的实现，比如在这里我们让run方法接收string类型的参数，而不是number，编译器将会向我们大叫：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class IllegalPony implements CanRun {

run(meters: string) {

console.log(\`pony runs \${meters}m\`);

}

}

// error TS2420: Class 'IllegalPony' incorrectly implements interface 'CanRun'.

// 'run'的属性不兼容

你也可以同时实现多个接口：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class HungryPony implements CanRun, CanEat {

run(meters) {

logger.log(\`pony runs \${meters}m\`);

}

eat() {

logger.log(\`pony eats\`);

}

}

一个接口也可以继承自一个或多个其它接口：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

interface Animal extends CanRun, CanEat {}

class Pony implements Animal {

// ...

}

当你在TypeScript中定义一个类的时候，你可以在类中包含属性和方法。你可能已经意识到类中能够包含属性并不是ES6的特征，仅仅在TypeScript中才可以：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class SpeedyPony {

speed = 10;

run() {

logger.log(\`pony runs at \${this.speed}m/s\`);

}

}

默认情况下，所有东西都是public的，不过你可以使用private关键字将一个属性或者一个方法隐藏起来。如果你在构造器参数中添加private或者public，它只是一种创建并初始化一个私有或者公有变量的便利方式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class NamedPony {

constructor(public name: string, private speed: number) {

}

run() {

logger.log(\`pony runs at \${this.speed}m/s\`);

}

}

const pony = new NamedPony('Rainbow Dash', 10);

// 定义了一个值为'Rainbow Dash'的公有的name属性

// 定义了一个值为10的私有的speed属性

它和下面的这种冗余写法在效果上是一样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class NamedPonyWithoutShortcut {

public name: string;

private speed: number;

constructor(name: string, speed: number) {

this.name = name;

this.speed = speed;

}

run() {

logger.log(\`pony runs at \${speed}m/s\`);

}

}

这种简写方式非常有用，我们将在Angular中大量使用它们！

## 与其它库一起使用

如果和用JS写成的库一起用的时候，你可能会认为我们完蛋了，因为我们不知道那个库中的函数所期待的参数是什么类型的。TypeScript社区做了一件非常棒的事情：对于非常流行的JavaScript库，社区成员为其暴露出来的类型和函数都定义了接口！

包含这些接口的文件拥有特殊的.d.ts扩展名。它们包含了库的公共函数列表。查找这些文件的一个好地方是DefinitelyTyped。比如，如果你想要在AngularJS 1.x中使用TS，你可以直接通过NPM来下载对应的文件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

npm install --save-deve \@types/angular

或者也可以手动下载。然后将其包含在代码的顶部，之后就可以享受编译检查带来的好处了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

/// \<reference path="angular.d.ts" /\>

angular.module(10, \[\]); // 模块名应该是一个字符串

// 所以当我编译的时候，我会得到：

// Argument of type 'number' is not assignable to parameter of type 'string'.

/// \<reference path="angular.d.ts" /\>是一种可以被TS识别的特殊注释，它告诉编译器寻找接口angular.d.ts。现在如果你以错误的方式调用了AngularJS的方法，编译器就会报错，你就可以当场修复它了，这样就不用等到运行期才能发现这种错误。

更酷的是，从TypeScript 1.6开始，如果接口被打包进依赖的node\_modules目录，那么编译器会自动发现它们。越来越多的项目开始适配这种方式，Angular也一样。所以也不必担担心再你的Angular项目中包含接口：如果你使用NPM管理你的依赖，TS编译器会自己找到它！

## 装饰器

这是一个较新的概念，在TypeScript 1.5的时候被添加进来，用来支持Angular。确实，正如我们不久就要看到的，Angular组件可以使用装饰器来描述。你可能还没有听说过装饰器，因为并不是每种语言都有装饰器。装饰器是一种进行元编程的方式。它们和Java、C\#、Python（或者还有一些我不太了解语言）中使用的注解非常相似。你可以注解方法、注解属性或者注解一个类，当然不同的语言支持的注解类型也不一样。通常，注解并不应用于语言自身，而是主要应用于框架和库。

装饰器确实非常强大：它们可以修改它们的目标（方法、类等等），比如可以变更调用的参数、干预结果、当目标被调用的时候调用其它的方法或者为框架添加元数据（这就是Angular装饰器做的事情）。直到现在，在JavaScript中还没有这种能力。但是语言也在不断地衍进种，现在已经有了一个关于decorators的官方提案，可能会在未来的某一天（可能在ES7/ES2016中）变成标准化的东西。也要注意到，TypeScript实现的装饰器比提案标准更进一步。

在Angular中，我们将会使用框架提供的装饰器。它们的角色非常基础：它们向我们的类或者参数中添加元数据，像是"这个类是一个组件"、"这是一个可选的依赖"、"这是一个自定义属性"等等。但是由于它是TypeScript提供的特性，所以使用它们并不是强制性的，你也可以手动添加元数据（比如，如果你想一直坚持ES5的话），但是使用装饰器会使代码更加优雅。

在TypeScript中，装饰器以一个\@符号开始，可以应用于一个类、一个类的属性、一个函数或者一个函数参数。它们不能应用于构造函数，但是可以应用于构造函数的参数上。

为了更好地掌握装饰器，让我们先构建一个简单的装饰器，\@Log()，这个装饰器在每个方法调用的时候都会记录下一些信息。

可以这样使用它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class RaceService {

\@Log()

getRaces() {

// call API

}

\@Log()

getRace(raceId) {

// call API

}

}

要定一个一个装饰器，我们需要写一个返回函数的方法，像下面这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const Log = function() {

return (target: any, name: string, descriptor: any) =\> {

logger.log(\`call to \${name}\`);

return descriptor;

}

}

基于你想要将装饰器应用的目标，这个函数不会有完全相同的参数。这里我们写的是一个方法装饰器，它接受3个参数：

-   target： 装饰器所装饰的目标

-   name：装饰目标方法的名字

-   descriptor：装饰目标方法的喵舒服（这个方法是否是可枚举的、可写的等等）

这里我们就是简单的记录了一下方法的名字，但是你可以做你想做的任何事情：干预参数、干预结果，调用另一个函数等等。

所以，在我们的简单例子中，每次调用getRace()或者getRaces()方法的时候，我们就会在浏览器日志中看到一个调用的轨迹：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

raceService.getRaces();

// logs: call to getRaces

raceService.getRace(1);

// logs: call to getRace

作为用户，让我们看一下Angular的装饰器是什么样子的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({selector: 'ns-home'})

class HomeComponent {

constructor(\@Optional() hello: HelloService) {

logger.log(hello);

}

}

\@Component装饰器被添加到HomeComponent类上。当Angular加载我们的应用的时候，它会找到类HomeComponent，并且依据装饰器为其添加的相关元数据，知道它是一个组件。很酷，是吧？正如你看到的，一个装饰器可以接受参数，这里是一个配置对象。

我只是想介绍装饰器的原始概念：我们将会在本书中研究Angular中的每个装饰器。

必须要指出的是，使用Babel翻译器替代TypeScript也是可以使用装饰器的。甚至有一个支持所有Angular装饰器的插件：angular2-annotations。Babel也支持类属性，但是不支持TypeScript的类型系统。你可以使用Babel，写"ES6+"的代码，但是你就不能使用类型了，而类型对于依赖注入非常有用。当然使用Babel也是完全可以的，但是你必须添加更多的装饰器来替代类型。

所以我的建议是尝试一下TypeScript！从这里开始，我们所有的例子都会使用TypeScript。它并不具有侵入性，你可以在它拥有的地方使用它，在其它地方忘掉它。如果你确实不喜欢它，并且有点疯狂的话，切换到Babel或者Traceur支持的ES6，或者甚至是ES5都不是很困难（说实话，用ES5写出的Angular应用，代码非常丑）。

# 精彩的Web组件王国

在更进一步之前，我想先停下一会儿，来讨论Web组件。写Angular代码并不需要了解Web组件。但是我认为对Web组件是什么有一个大致的了解是有好处的，因为Angular已经作出一些选择来促进与Web组件的集成，或者让我们构建的组件和Web组件更加相似。如果对此主题不感兴趣可以直接跳过；然而，我深信你会学到一些对于后续的旅途有用的东西。

## 一个勇敢的新世界

组件是在开发领域的一个古老的幻想。你可以从架子上抓一些东西下来，将其拖到你的应用中，然后它就可以立即工作，并且为你的用户提供了他们需要的功能。

我的朋友，这个时代已经到来了。

当然，可能至少一些事情已经开始发生了。

这也并不是全新的东西。我们已经在Web开发中长时间使用组件了，但是它们通常需要一些依赖，像是JQuery、Dojo、Prototype、AngularJS等等。并不是你的应用所必须要的一些库。

Web组件试图解决这个问题：可重用的和封装的组件。

它们都依赖于一个新兴的标准集，现在浏览器都还不能完美地支持。但是，它仍旧是一个有趣的话题，即使我们可能要等上几年才能完全地使用它们，或者这个概念一直都不会真正实现。

这个新兴的标准是在4个规范中定义的：

-   自定义元素

-   Shadow DOM

-   模版

-   HTML导入

注意相关的示例可能可以运行于最新的Chrome或者Firefox浏览器。

## 自定义元素

自定义元素是一个允许开发者创建自己的DOM元素的新标准，这使得像是\<ns-pony\>\</ns-pony\>也称为一个合法的HTML元素。规范定义了怎样去声明这样的元素，怎样使它们继承现有的元素，怎样定义你的API等等。

创建一个自定义元素可以通过一个简单的document.registerElement('ns-pony')来实现：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 新元素

var PonyComponent = document.registerElement('ns-pony');

// 插入到当前的body中

document.body.appendChild(new PonyComponent());

注意名字必须包含一个短破折号，这样浏览器才能知道它是一个自定义的元素。当然了，你自定义的元素也可以包含属性和方法，它也有生命周期回调，这样就可以在组件被插入、删除或者其属性发生变化的时候执行相应代码了。它也可以有自己的一个模版。ns-pony可能展示小马的图片或者仅仅展示小马的名字：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 扩展HTMLElement

var PonyComponentProto = Object.create(HTMLElement.prototype);

// 通过使用生命周期回调添加一些模版

PonyComponentProto.createedCallback = function() {

this.innerHTML = '\<h1\>General Soda\</h1\>';

};

// 新元素

var PonyComponent = document.registerElement('ns-pony', {prototype: PonyComponentProto});

// 插入到当前的body中

document.body.appendChild(new PonyComponent());

如果你试图检查一下此DOM，你会看到\<ns-pony\>\<h1\>General Soda\</h1\>\</ns-pony\>。但是这意味着你应用的CSS和JavaScript逻辑可能会对你的组件产生未知的影响。所以，通常情况下，这个模版是被隐藏起来的，并被封装到Shadow DOM下，这样尽管浏览器显示了小马的名字，但是你在检查的时候却只能看到\<ns-pony\>\</ns-pony\>。

## Shadow DOM

名字看上去很神秘，你一定对它的能力有所期待。确实是这样的。Shadow DOM是一种封装我们组件中DOM的方式。这种封装意味着你的应用的样式表和JavaScript逻辑将不会应用于这个组件，也就避免了无意间将其毁坏的问题。它是我们隐藏组件内部实现的完美工具，同时保证了组件中的任何东西都不会泄露到应用中，反之亦然。

回到我们前面的例子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

var PonyComponentProto = Object.create(HTMLElement.prototype);

// 在Shadow DOM中添加一些模版

PonyComponentProto.createdCallback = function () {

var shadow = this.createShadownRoot();

shadow.innerHTML = '\<h1\>General Soda\</h1\>';

};

var PonyComponent = document.registerElement('ns-pony', {prototype: PonyComponentProto});

document.body.appendChild(new PonyComponent());

如果你现在再去检查它，你应该会看到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony\>

\#shadow-root (open)

\<h1\>General Soda\</h1\>

\</ns-pony\>

现在，即使你想要给h1元素添加一些样式，组件的视觉外观也不会受到影响：这是因为Shadow DOM在这里扮演了屏障的角色。

直到现在，我们仅仅是使用字符串作为我们的Web组件的模版。但是你并不会经常使用这种方式。最佳实践应该是使用\<template\>元素。

## 模版

\<template\>元素指定的模版并不会在你的浏览器中显示出来。它的主要目标在于在某些时候被克隆。你插入到其中的内容是惰性的：脚本不会运行，图片不会加载等等。它的内容不能被页面的其它部分通过类似于getElementById()的方法查询，它可以安全地放置于页面的任意位置。

要使用一个模版，首先需要克隆它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<template id="pony-tpl"\>

\<style\>

h1 {color: orange;}

\</style\>

\<h1\>General Soda\</h1\>

\</template\>

var PonyComponentProto = Object.create(HTMLElement.prototype);

// 使用template标签添加一些模版

PonyComponentProto.createdCallback = function() {

var template = documents.querySelector('\#pony-tpl');

var clone = document.importNode(template.content, true);

this.createShadowRoot().appendChild(clone);

}

var PonyComponent = document.registerElement('ns-pony', {prototype: PonyComponentProto});

document.body.appendChild(new PonyComponent());

也许我们可以在单独的文件中声明这些，我们就有了一个完美封装的组件了...让我们通过使用HTML导入来实现这个想法。

## HTML导入

这是最后一个规范。HTML导入允许将HTML导入到HTML。类似于\<link rel="import" href="ns-pony.html"\>。ns-pony.html文件包含了一切：模版、脚本、样式表等等。

如果有人想使用我们的漂亮的组件，它们必须使用HTML导入，并且这并不困难！

## Polymer和X-tag

所有这些东西合在一起组成了Web组件。我在这个主题上远远算不上什么专家，这条路上还有各种各样的古怪的陷阱在等着我们。

由于Web组件并没有得到每个浏览器的完善支持，你可以在你的应用中添加一个polyfill来确保它是可以正常工作的。这个polyfill叫做web-components.js，值得注意的是，它是Google、Mozilla和微软等共同努力的结果。

依靠这个polyfill，几个库的实现就称为了可能。它们都是致力于促进Web组件的使用，并且有的还包含了一些开箱即用的Web组件。

在最受关注的首创者中，你会找到：

-   Google的Polymer

-   Mozilla和微软的X-tag

我不会继续谈论更多细节了，但是你可以非常方便地使用已经存在的Polymer组件。比如你想要在你额应用中添加Google地图：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<\--Polyfill Web Components support for older browsers \--\>

\<script src="webcomponents.js"\>\</script\>

\<!\-- 导入元素\>

\<link rel="import" href="google-map.html"\>

\<!\-- 使用元素\>

\<body\>

\<google-map latitude="45.780" longtitude="4.842"\>\</google-map\>

\</body\>

还有更多的已经准备好的组件。你可以在<https://www.webcomponents.org>上做一下概览。

Polymer也能帮助你构建自己的组件（ns-pony.html）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<dom-module id="ns-pony"\>

\<template\>

\<h1\>\[\[name\]\]\</h1\>

\</template\>

\<script\>

Polymer({

> is: 'ns-pony',
>
> properties: {
>
> name: String
>
> }
>
> });

\</script\>

\</dom-module\>

使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<!\-- Polyfill Web Component support for older browsers \--\>

\<script src="webcomponents.js"\>\</script\>

\<!\-- Polymer \--\>

\<link rel="import" href="polymer.html"\>

\<!\-- 引入元素 \--\>

\<link rel="import " href="ns-pony.html"\>

\<!\-- 使用元素 \--\>

\<body\>

\<ns-pony name="General Soda"\>\</ns-pony\>

\</body\>

你可以使用Polymer做很多很酷的事情，像是数据的双向绑定、属性的默认值、触发自定义事件、对属性的变化作出响应、我们给组件传递了一个集合的情况下生成重复元素等等。

对于Web组件的所有细节来说，一章的内容确实太少了，但是随着你阅读本书，你将会看到其中的一些概念会不断的出现在你的眼前。你最终会发现Google团队将Angular设计为便于使用Angular组件的同时，也便于使用Web组件。

# 掌握Angular的哲学

要写Angular应用，你必须掌握这个框架的几个设计哲学。

首先最重要的是，Angular是面向组件的。你想要写一些小的组件，它们组合起来就形成了整个应用。一个组件就是在模版中的一组HTML元素，只聚焦于某一项任务。这样的话，你也需要一些与这个模版相关的一些逻辑，比如用于填充数据或者响应事件。对于AngularJS 1.x的老手来说，它有点儿像'template/controller' 的二重奏，或者叫做指令。

必须要说的是，已经围绕组件形成了一个标准：Web组件标准。尽管浏览器还没有完善的支持，你也可以构建小的、独立的组件，可以在不同的应用中重用------可以说是计算机编程的一个旧梦吧。这种面向组件的方式已经被多个前端框架锁使用：来自于Facebook的最新的ReatJS，从一开始就按照这个思路在做；EmberJS和AngularJS用它们自己的方式做了类似的事情；像是Aurelia或者Vue.js这样的后来者也下注于构建小的组件。

Angular在这方面并不独孤，但是它是第一批（或者说是第一个）认真考虑将Web组件（标准组件）集成进来的框架。但是现在先让我们忘记这些，这应该是属于更加高级的主题了。

组件是按等级组织在一起的，这点和DOM比较像。一个根组件会有子组件，每个子组件也会有孩子等等。如果你想要显示一个小马比赛（谁不想呢？），你最终会得到一个应用（Ponyracer），它有一个子视图（Race），这个视图显示了一个菜单（Menu），登陆的用户（User），当然还有参加比赛的小马（Pony）们：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image1.png){width="4.638888888888889in" height="4.111111111111111in"}

写组件就是你的日常工作，现在就让我们看一下它是什么样子的。Angular团队想要利用现在Web开发领域另一个利好：ES6（或者叫ES2015，都可以）。这样你就可以用ES5（不太酷）或者ES6（酷多了）来写组件了。但是他们认为这些还不够，他们还需要一些非标准的特性：装饰器。所以他们于翻译器（Traceur和Babel）团队和微软的TypeScript团队紧密协作，让我们能够在Angular应用中用上装饰器。有几个装饰器已经可用了，利用它们我们可以更轻松地声明一个组件。我希望你已经了解过它们了，毕竟我们前面花费了两章来说这些事情！

我们先举一个简化的例子，Race组件看上去应该是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { RacesService } from './services';

\@Component({

selector: 'ns-race',

templateUrl: 'race/race.html'

})

export class RaceComponent {

race: any;

constructor(racesService: RaceService) {

racesService.get()

.then(race =\> this.race = race);

}

}

而模版应该是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div\>

\<h2\>{{ race.name }}\</h2\>

\<div\>{{ race.status }}\</div\>

\<div \*ngFor="let pony of race.ponies"\>

\<ns-pony \[pony\]="pony"\>\</ns-pony\>

\</div\>

\</div\>

如果你已经了解过AngularJS 1.x，这个模版看上去应该很熟悉，同样适用双大括号的表达式，双大括号中的表达式将会进行求值计算，并将其替换为相应的值。然而一些东西也发生了变化：比如以后就没有ng-repeat了。我不打算在这里深入太多，仅仅就是先让你对代码的样子有一个感性的认识。

一个组件是你的应用中非常独立的一部分。你的应用也是一个组件，和其它组件没有什么差别。

组件会被组织到一个或者多个连续的实体中，它们叫做模块（Angular模块，不是ES6模块）。

在完美的情况下，从社区取到可用的模块，让后将它们放入应用中，然后就可以使用它们了。

这样的模块可以提供UI组件、拖拽能力、表单验证，几乎你能想到的任何东西。

在下面的章节中，我们将学习如何从零开始，怎样构建一个小的组件，你的第一个模块还有模版语法。

还有另一个非常核心的概念，叫做依赖注入（经常叫它的小名，DI）。 这是一种非常强大的模式，读完相关的章节之后你会很快地习惯使用它的。这对于应用的测试非常有用，我非常喜欢做测试，然后看着IDE中的进度条慢慢变绿。这让我感觉到我做的还不错。所以会有一章的内容专门讲测试，测试所有的东西：你的组件、你的服务、你的UI...

Angular仍然具有何其在V1版本中一样的神奇感觉，框架会自动检测到所有的变化并将这些变化应用到模型和视图上。但是它却是以和之前完全不同的方式实现的：现在变化的检测用到了一个叫做zones的概念。当然，我们会着重看一下它。

Angular是一个完整的框架，它为Web开发中的常见任务提供了大量的帮助。写表单、调用HTTP后端、路由、与其它库交互、动画、凡是你能说得出的： 你已经被全覆盖了。

好吧，还要学习很多东西！我们应该从零开始：开启一个应用项目，然后写出我们的第一个组件。

# 从零开始

让我们通过创建我们的第一个应用和第一个组件来开始吧！我们会保持其最小可用。

## NodeJS和NPM

现如今，几乎所有的现代JavaScript工具都是为NodeJS和NPM构建的。你需要在你的系统上安装Node.js和NPM。安装它们的最好的方式取决于你的操作系统------你可以从官方网站找到更多的信息。确保你有一个较新版本的Node.js（通过node \--version可以获取版本信息），比如8.9+。

## Angular CLI

你可以自己搭建出所有的东西，开启一个TypeScript项目、然后安装所有的依赖等等。

但是在真实的项目中，你很有可能也需要设置其它几样东西，像是：

-   用于确保我们没有搞砸事情的一些测试

-   一个用于检测代码的linter

-   一个CSS预处理器

-   一个构建工具，用于协调各种各样的任务（编译、测试、打包等等）

但是自己设置所有的东西有点儿太笨重了，特别是有这么多工具需要去学习的情况下。

过去的这些年，很多小的项目生成器冒出来了，几乎所有都在使用Yeoman。之前AngularJS 1.x也采取了同样的方式，Angular社区也做过一些尝试。

但是这次，Google团队一直在这方面进行努力，并且已经有了一些成果：Angular CLI。

Angular CLI是一个命令行工具，用它可以快速地启动一个项目，它和Webpack（这些年比较流行的家伙）配置在一起，作为构建工具、测试工具和大包工具等等。

其思想并不新鲜，事实上是从另一个流行的框架借鉴过来的：EmberJS何其广受赞誉的ember-cli。

这个工具一直在持续开发中，有一个Google团队专注于这个项目，并让它越来越好。它现在是创建和构建Angular应用的事实标准。所以，我们要尝试一下这个工具，并发现其所包含各种出色的体验。

首先，先要安装Angular CLI，并使用ng new命令生成一个新的应用。如果想和我们使用完全一样的版本（6.0.0），你可以使用npm install -g \@angular/cli\@6.0.0。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

npm install -g \@angular/cli

ng new ponyracer \--prefix ns

这样就会创建一个叫做ponyracer的目录，此目录中就是工程的框架。进入到这个目录中，你可以执行一下的命令开启你的应用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ng serve

这将在本地开启一个小的HTTP服务器，其是热加载的。这就意味着你每次修改并保存文件的时候，这个服务器会重新构建此应用，浏览器也会立即重新加载。

太棒了！你已经搭建并运行起你的第一个应用了！

## 应用的结构

让我们花时间来研究一下生成的代码。

使用你喜欢的IDE打开这个项目。你可以使用你想使用的任意的IDE，但是你应该激活其TypeScript的支持以获得更好的编程体验。选择你最喜欢的：Webstorm、Visual Studio Code、Atom...它们都对TypeScript有很好的支持。

你应该可以在顶层目录看到一堆的配置文件：欢迎来到现代JavaScript！

你第一个注意到的可能就是package.json：这里是定义应用依赖的地方。你可以看看它的内容，它现在应该包含如下的依赖了：

-   不同的\@angular的包

-   rxjs，用于响应式编程的非常酷的库。在这个主题上我们安排了一个专门的章节，具体就是关于RxJS的。

-   zone.js，进行检测变化的繁重工作（我们也会在稍后深入了解）

-   一些应用开发需要的库，像是CLI、TypeScript、一些测试库、一些类型...

TypeScript自身有一个配置文件tsconfig.json（另一个是src目录下的tsconfig.app.json），用于存储编译选项。正如我们在之前章节看到的，我们使用TypeScript中的装饰器（所有有两个关于装饰器的配置），我们想要讲我们的代码编译成ECMAScript 5，以让其能够在任何的浏览器中运行。sourceMap选项使我们能够创建源码映射，比如包含生成的ES5和原来的TypeScript代码之间的映射文件。浏览器会这使用这些源码映射，让我们能够直接在原来的TypeScript代码上进行调试。

TypeScript项目通常也会使用TSLint，以最佳实践的标准来检查你的代码的一个linter。TSLint有它自己的选项，其存储于tslint.json中，你可以在这里添加/删除一些规则。

最后的karma.conf.js是用来配置测试工具的（我们在讨论测试的时候会了解更多）。

现在配置文件部分看完了，现在让我们看一下应用代码吧。

## 我们的第一个组件

如在之前部分中看到的，一个组件是一个视图（模版）和一些逻辑（TS类）的组合体。CLI已经为我们创建了一个组件了：src/app/app.component.ts。让我们先看一下它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-root',

templateUrl: './app.component.html',

styleUrls: \['./app.component.css'\]

})

export class AppComponent {

title = 'ns';

}

我们的应用本身就是一个简单的组件。要告诉Angular它是一个组件，就要使用\@Component装饰器。要使用这个装饰器，我们必须先将其导入，正如你在文件顶部看到的那样。

当你写信的组件的时候，不要忘记引入Component装饰器。一开始你可能会忘记这样做，但是这种情况不会持续，因为编译器会向你喊话的！;)

你会注意到我们需要的多数的东西都在\@angular/core模块中，但是有的时候也需要其它的模块。比如，在处理HTTP请求的时候，我们将使用来自于\@angular/http模块中的东西；使用路由的时候，我们会使用\@angular/router等等。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

})

export class AppComponent {

title = 'ns';

}

其中的\@Component装饰器需要一个配置对象。我们会在后面搞清楚都能配置哪些东西，但是在这里我们只需要一个属性：就是selector。它负责告诉Angular在HTML页面中去寻找什么。Angular每在HTML中找到一个对应的元素符合这个组件的selector，它就会创建这个组件的一个实例，并将此元素的内容替换为组件的模版。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-root',

})

export class AppComponent {

title = 'ns';

}

这样的话，对于我们HTML中的每一个类似于\<ns-root\>\</ns-root\>的元素，Angular就会初始化一个新的AppComponent类的实例。

一个组件也必须包含一个模版。我们可以使用一个内联的模版，或者使用存储在外部文件中的模版，CLI工具就是使用的外部文件模版：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-root',

templateUrl: './app.component.html',

styleUrls: \['./app.component.css'\]

})

export class AppComponent {

title = 'ns';

}

对应的HTML被定义在app.component.html中，除了第一个h1元素之外，其它的都是静态元素：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<!\--The content below is only a placeholder and can be replaced.\--\>

\<div style=\"text-align:center\"\>

\<h1\>

Welcome to {{ title }}!

\</h1\>

\<img width=\"300\" alt=\"Angular Logo\" src=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg==\"\>

\</div\>

\<h2\>Here are some links to help you start: \</h2\>

\<ul\>

\<li\>

\<h2\>\<a target=\"\_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\"\>Tour of Heroes\</a\>\</h2\>

\</li\>

\<li\>

\<h2\>\<a target=\"\_blank\" rel=\"noopener\" href=\"https://github.com/angular/angular-cli/wiki\"\>CLI Documentation\</a\>\</h2\>

\</li\>

\<li\>

\<h2\>\<a target=\"\_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\"\>Angular blog\</a\>\</h2\>

\</li\>

\</ul\>

## 我们的第一个Angular模块

我之前曾简短提到过，我会将组件和其它东西都要组织到一致性实体中：Angular模块。

Angular模块和我们之前提到的ES6模块并不是一回事：这里我们谈论的是应用模块。

你的应用是少有一个模块，也就是**根模块**。随后，随着应用规模的增加，就需要按照不同的功能去增加其它模块了。比如，可以增加一个专门用于应用后台管理的模块，这个模块包含了这个功能所需要的全部组件和逻辑。我们将在稍后继续这个话题。我们也会看到第三方的库和Angular自身也会暴露模块，这样我们就可以在应用中使用它们了。

当然，CLI工具也生成了一个模块，叫做app.module.ts。

这个类是经过\@NgModule模块装饰的。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

\@NgModule({

})

export class AppModule { }

和\@Component装饰器类似，它也接受一个配置对象。

由于我们是为浏览器构建应用，根模块导入了一个BrowserModule。当然这并不是Angular的唯一选择，比如，你也可以选择在服务器端渲染应用，后续导入另一个模块。BrowserModule包含了所有我们需要的东西。模块可以选择性的导出组件、指令和管线。当你导入一个模块的时候，被导出模块的所有的指令、组件和管线都会在你的模块中可用。我们的额根模块不会在其它模块中被导入，所以我们没有导出，但是最后我们有一些导入。

这个术语对于新手来说并不十分友好。我们在第一章中讨论了ES6和图TS的模块，其定义了导入和导出。现在我们正在讨论的时候Angular的模块，也有导入和导出...我可不喜欢一堆不同的东西被冠以相同的名字，所以我们还是来解释一下吧。

ES6和TS的导入是语言特性，就像是Java中的import声明一样：在你的代码中就可以使用被导入的类/函数。它也需要为打包器或者模块加载器（Webpack或者SystemJS）声明依赖，这样如果a导入了b，它们就可以知道如果a.ts被加载了，那么b.ts也必须被加载进来。在ES6和TypeScript中你必须使用导入和导出，这个和你是不是使用Angular或者其它框架是没有关系的。

另一方面，在你自己的Angular模块（AppModule）中导入一个Angular模块（比如，BrowserModule），是有功能性含义的。它告诉Angular：BrowserModule所导出的所有的组件、指令和管线在我的Angular组件/模版中都可以使用。对于TypeScript编译器来说并没有什么特殊的意义。

回到NgModule：在它的配置对象中，我们必须通过declarations字段声明隶属于根模块的组件。可以看到，它包含了我们先前讨论过的组件：AppComponent.

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { BrowerModule } from '\@angular/platform-browser';

import { NgModule } from '\@angular/core';

import { AppComponent } from './app.component';

\@NgModule({

declarations: \[

AppComponent

\],

imports: \[

BrowserModule

\]\
})

export class AppModule {

}

由于这是根模块，我们需要告诉Angular哪个组件是根组件。比如我们引导应用的时候将会被开启的组件。这就是bootstrap字段的作用了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { BrowserModule } from '\@angular/platform-browser';

import { NgModule } from '\@angular/core';

import { AppComponent } from './app.component';

\@NgModule({

declarations: \[

AppComponent

\],

imports: \[

BrowserModule

\],

providers: \[\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

模块已准备好，下面就引导这个应用！

## 引导应用

最终我们需要使用bootstrapModule方法打开我的应用。这个方法是由一个叫做platformBrowserDynamic的方法返回的对象暴露出来的。你必须先从\@angular/pltform-browser-dynamic中也将其导入。这个模块看上去有些奇怪！为什么不是\@angular/core？好问题：这是因为，Angular支持服务器端渲染或者在一个Web Worker中运行，所以你可能并不想将你的应用运行于浏览器，而是其它地方。这种情况下，引导逻辑就会不同。我们后面将会更详细地讨论，现在我们还是聚焦于浏览器。

Angular CLI默认会生成一个独立的文件，来组织这些引导逻辑：main.ts：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import {enableProdMode} from '\@angular/core';

import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';

import { environment } from './environments/environment';

if (environment.production) {

enableProdMode();

}

platformBrowserDynamic().bootStrapModule(AppModule)

.catch(err =\> console.log(err));

好的！但是等一下。我们需要让用户看的HTML页面，不是吗？

CLI工具创建了一个index.html文件，这个就是我们应用的单个页面。你可能好奇它怎么能工作，它甚至不包含任何的脚本元素。

当你运行ng serve的时候，CLI调用TypeScript的编译器。编译器输出了JavaScript文件。 CLI工具将其绑定到index.html，并添加必要的脚本元素（背后是使用WebPack）。

如果一切顺利的话，你应该对于这第一个Angular应用的各个部分都有了一个更好的理解了。它还不是一个真正的动态应用，我们可以立即在一个静态HTML页面中实现同样的效果。那么就让我们进入下一个部分，学习一些关于依赖注入和模版的东西。

# 模版语法

我们知道一个组件需要一个视图。要定义个视图，你可以定义一个内联的模版，或者在一个单独的文件中去定义。你可以已经比较熟悉模版语法了。简单来说，一个模版就是依据我们的数据渲染HTML中的一些动态部分。

Angular由自己的模版语法，我们需要先学习一下才能更进一步。

让我们举一个简单的例子，修改我们的第一个组件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-root',

template: '\<h1\>PonyRacer\</h1\>'

})

export class AppComponent {

}

现在我想要在这个页面上显示一些动态的数据，比如可能是注册到我们应用的用户的数量。后面我们会看到怎样从服务器获取数据，但是现在这个用户的数据是直接硬编码到我们的类中的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-root',

template: '\<h1\>PonyRacer\</h1\>'

})

export class AppComponent {

numberOfUsers = 146;

}

现在，我们怎样修改模版才能展示这个变量呢？答案就是插值。

## 插值

插值是一个简单的概念。

小例子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-root',

template: \`

\<h1\>PonyRacer\</h1\>

\<h2\>{{ numberOfUsers }}\</h2\>

\`

})

export class AppComponent {

numberOfUsers = 146;

}

我们的这个组件每看到一个\<ns-root\>标签就会被激活一次。AppComponent类由一个属性，numberOfUsers。模版新增了一个\<h2\>标签，用到了著名的双大括号标记，来规定一个表达式必须被求值。这种模版机制就叫做插值。

现在我们可以在浏览器中看到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-root\>

\<h1\>PonyRacer\</h1\>

\<h2\>146 users\</h2\>

\</ns-root\>

这是因为{{ numberOfUsers }}将被其值替代了。当Angular检测到页面中有一个\<ns-root\>元素的时候，它就会创建 AppComponent类的一个实例，这个实例就是模版表达式的求值上下文。这里AppComponent实例将numberOfUsers属性设置为'146'，所以我们就在屏幕上看到了'146'。

神奇之处在于，当我们的numberOfUsers的值变化的时候，模版也会自动更新！这叫做'变化监测'，这是Angular非常棒的特性之一。

但是也要记住一个重要的事实：如果我们想要显示一个不存在的变量，它不会显示undefined，而是显示一个空的字符串。对于值为null的变量也是同样的效果。

我们假设我们的第一个组件用一个更复杂的用户对象而不是一个简单的值来代表当前用户。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-root',

template: \`

\<h1\>PonyRacer\</h1\>

\<h2\>Welcome {{ user.name }}\</h2\>

\`

})

export class AppComponent {

user: any = {name: 'Cedric'}

}

你看到了，我们可以插值像是访问一个对象的属性这样的更复杂的表达式。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-root\>

\<h1\>PonyRacer\</h1\>

\<h2\>Welcome Cedric\</h2\>

\</ns-root\>

如果我们的模版中存在一个输入错误会怎么样呢，比如引用了一个本类中不存在的属性：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-root',

// 输入错误：users不存在

template: \`

\<h1\>PonyRacer\</h1\>

\<h2\>welcome {{ users.name }}\</h2\>

\`

})

export class AppComponent {

user: any = {name: 'Cedric'}

}

加载这个应用的时候，你会得到一个错误，告诉你这个属性并不存在：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Cannot read property 'name' of undefined in \[{{ users.name }} in AppComponent\]

这很棒，因为这样你就可以确信你的模版是正确无误的了。AngularJS 1.x中经常遇到的一个问题就是这种类型的问题监测不到，你可能会花费不少的时间来查找问题出现在哪里（通常是一个输入错误，像是本该是{{ user.name }}却写成了{{ users.name }}）。我们已经进行过几节培训课了，我可以确信30%的新手在第一天都会犯这样的错误。我曾经被这种情况搞郁闷了，我甚至提交了一个PR用于监测当解析器找到一个未知变量的时候给出一个警告信息，出于某些原因这个PR被拒绝了，并且核心团队也说明它们已经有了解决这个问题的思路。最后它们确实做到了！

最后一个不大但却很有用的特性。如果我们的用户对象是从服务器端获取的，在服务器调用返回结果之前，用户对象就是undefined，这种情况如何处理呢？当模版编译的时候是否有办法来避免这样的错误呢？

是的，确实有：我们可以不写user.name，换做user?.name即可：

\@Component({

selector: ns-root',

// user 是undefined

// 但是 ?. 解决这个问题

template: \`

\<h1\>PonyRacer\</h1\>

\<h2\>Welcome {{ user?.name }}\</h2\>

\`

})

export class AppComponent {

user: any;

}

现在就不会有任何错误了！这个?.有时候叫做"安全导航操作符"。

所以我们现在可以更加安心地写模版了，并且能够确认它们能够正常工作。

回到我们的例子。我们现在正在显示一条问候信息。或许我们可以更进一步，展示即将到来的小马赛事。

这就需要到第二个模版了。现在，我们先写一个简单的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在另一个文件中，races.component.ts

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-races',

template: \`\
\<h2\>Races\</h2\>

\`

})

class RacesComponent {

}

没有什么新鲜的：一个简单的类，用\@Component来装饰它，我们指定了这个装饰器要匹配的selector，还有一个内联模版。

现在我们想静这个模版包含在我们的AppComponent模版之中。我们需要做些什么呢？

## 在我们的模版中使用其它的组件

我们已经有了应用组件，AppComponent，我们想要在其中展示小马比赛组件，RacesComponent。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在app.component.ts中

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-root',

// 添加RacesComponent 组件

template: \`

\<h1\>PonyRacer\</h1\>

\<ns-races\>\</ns-races\>

\`

})

export class AppComponent {

}

正如你看到的，我通过包含一个与RacesComponent中选择器相匹配的标签添加了RacesComponent。

但是，这还不行：你的浏览器不会显示比赛组件。

为什么？很简单：Angular还不知道存在这么一个RacesComponent。

但是解决这个问题很简单。你还记得我们必须在\@NgModule装饰器中的declarations中添加AppComponent吗？现在，既然我们有了第二个组件，也需要将其声明。

RacesComponent不是我们应用的根组件，所以它必须被配置在declarations中，而不是bootstrap中。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { AppComponent } from './app.component';

// 不要忘记导入这个组件

import { RacesComponent } from './races.component';

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent, RacesComponent\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

注意你需要直接传递这个类，所以你必须将其导入。为了能够将其导入，你需要将RacesComponent类从它的源代码文件races.component.ts中导出（如果不清楚，可以阅读关于ES6模块的章节）。所以RacesComponent会是这个样子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在另一个文件，races.component.ts

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-races',

template: \`

\<h2\>Races\<h2\>

\`

})

export class RacesComponent {

}

现在，我们的比赛组件可以自豪地显示在我们的浏览器上了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-root\>

\<h1\>PonyRacer\</h1\>

\<ns-races\>

\<h2\>Races\</h2\>

\</ns-races\>

\</ns-root\>

## 属性绑定

插值仅仅是动态化模版的一种方式。

事实上，插值仅仅是Angular模版系统的核心------属性绑定------的一种使用方式而已。

在Angular中，可以通过在HTML元素使用中括号包围的特殊属性来写入DOM属性。乍看起来很奇怪，但是这事实上是合法的HTML（这样然我很惊讶）。一个HTML属性可以以几乎任何字符开始，只有几个字符例外：引号、单引号、斜线、等号、空格...

我说的是DOM属性，可能你对此还不是很清晰。我们经常些HTML属性，对吧？不错，我们经常写。可以看一下下面这个简单的HTML：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input type="text" value="hello"\>

上面input标签有两个属性：一个type属性和一个value属性。当浏览器解析这个标签的时候，它会创建一个对应的DOM节点（一个HTMLInputElement），它也有对应于type和value的属性。每一个标准的HTML属性都对应一个DOM节点属性。但是DOM节点有更多的属性，它们并没有对应的HTML属性。比如childElementCount、innerHTML或者textContent。

我们上面显示用户的名字所有使用的插值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ user.name }}\</p\>

仅仅就是下面这种写法的一种语法糖而已：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p \[textContent\]="user.name"\>\</p\>

中括号羽凡让我们能够修改DOM的textContent属性，我们将其值设置为user.name，和插值一样，它会在当前的组件实例下进行求值。

注意解析器是大小写敏感的，所以必须按照正确的大小写来书写属性名：textcontent或者TEXTCONTENT就不行，必须是textContent。

DOM属性相比HTML属性有很大的优势：它们有最新的数据。在我的input例子中，value属性一直会包含'hello'，然而DOM节点的值属性是由浏览器动态修改的，所以它就包含了用户在文本输入框中输入的内容。

最后，DOM属性可以有布尔值，然而一些HTML属性只能通过在标签上存在或者缺失来表达。比如，在\<option\>标签中有selected属性：不论你给它什么值，它都会选中对应的选项，只要这个属性存在它就是选中状态：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<option selected\>Rainbow Dash\</option\>

\<option selected="false"\>Rainbow Dash\</option\> \<!\-- 依旧处于选中状态 \--\>

如果使用Angular给我们提供的DOM属性访问方式，你就可以这样写了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<option \[selected\]="isPonySelected" value="Rainbow Dash"\>Rainbow Dash\</option\>

如果isPonySelected是true的话就是选中状态，是false就是非选中状态。isPonySelected变化的时候，selected属性也会被更新。

你可以使用这种特性做很多有意思的事情，在AngularJS 1.x中如果一个图片有动态的资源地址，处理这种情况非常不方便。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<img src="{{ pony.avatar.url }}"\>

这个语法有一个很大的问题：浏览器会在读到src属性的时候会立即请求图片。你能看出来这是会失败的：它会向 {{ pony.avatar.url }}去做一次HTTP请求，很显然，这不是一个合法的URL...

在AngularJS 1.x中，有一个特殊的指令来处理这种情况：ng-src。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<img ng-src="{{ pony.avatar.url }}"\>

用ng-src替代src确实解决了这个问题，它通过这种方式让浏览器忽略了它。一旦AngularJS编译完应用，它就会添加一个带有正确URL的src属性，这就能够触发图片的下载了。很酷！但是有两个缺点：

-   首先，作为一个开发者，你必须知道要向ng-src传什么东西。是'https://gravatar.com'? "'https://gravatar.com'"? 'pony.avatar.url'? '{{ pony.avatar.url }}' ? 除了读文档别无选择。

-   第二，Angular团队必须为每一个属性都创建一个指令。他们确实这么做了，然后我们就必须去学习这些东西。但是我们现在生活在你的HTML中可以包含其它的Web组件的时代，看一下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony name="Rainbow Dah"\>\</ns-pony\>

如果你想用这个Web组件，多数的JS框架都没有一种方便的可以向其传递动态值的方式，除非这个Web组件的作者付出而外的努力来处理这个问题。可以读一下**Web组件**一章获取更多的信息。

一个Web组件的行为应该类似于一个浏览器元素。它们有基于DOM节点属性、事件和方法的DOM API。用Angular你可以这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony \[name\]="pony.name"\>\</ns-pony\>

工作正常！

Angular会维持HTML属性和DOM属性之间的一致性。

再也不用学习那么多的指令了！如果你想要隐藏一个元素，你就可以使用标注的hidden属性：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \[hidden\]="isHidden"\>Hidden or not\</div\>

只有当isHIdden是true的时候div才会被隐藏，因为Angular会直接工作与DOM属性hidden。再也不需要ng-hide了，这仅仅是Angular 1中一堆指令中的一个。

你可以可以访问嵌套的DOM属性，像是DOM属性style的color属性。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p \[style.color\]="foreground"\>Friendship is Magic\</p\>

如果foreground属性变成了'green'，文字的颜色也会更新为'green'！

那么Angular使用DOM属性。我们可以传哪些值呢？我们已经看到了插值 property="{{ expression }}"：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony name="{{ pony.name }}"\>\</ns-pony\>

折合\[property\]="expression"的效果是一样的（你可能更喜欢）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony \[name\]="pony.name"\>\</ns-pony\>

如果你想先写一个Pony然后跟着一个小马的名字，你有两种选择：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony name="Pony {{ pony.name }}"\>\</ns-pony\>

\<ns-pony \[name\]="'Pony' + pony.name"\>\</ns-pony\>

如果你的值并不是动态的，你可以直接写property="value"：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony name="Rainbow Dash"\>\</ns-pony\>

所有这些都是等价，这和开发者怎样设计组件没有关系，但是在AngularJS 1.x的时候你就需要知道这个组件是需要一个值还是需要一个引用。

当然，表达式也可以包含函数调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony name="{{ pony.fullName() }}"\>\</ns-pony\>

\<ns-pony \[name\]="pony.fullName()"\>\</ns-pony\>

## 事件

如果你正在开发一个Web应用，你就会知道显示内容仅仅是一部分工作而已：你是必须处理与用户的交互。为了做到这点，浏览器会发出事件，你可以去监听这些事件：click、keyup、mouseover等等。AngularJS 1.x对于每一个事件都有一个指令：ng-click、 ng-keyup、ng-mouseover等等。在Angular中，变得更简单了，不需要再去记忆这么多指令了。

回到我们的RacesComponent，我们现在想添加一个按钮，当点击这个按钮的时候显示出比赛。

响应一个事件可以像下面这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<button (click)="onButtonClick()"\>Click me!\</button\>

点击这个按钮就会触发组件中的方法onButtonClick()。

让我们将其添加到我们的组件中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-races',

template: \`

\<h2\>Races\</h2\>

\<button (click)="refreshRaces()"\>Refresh the races list\</button\>

\<p\>{{ races.length }}\</p\>

\`

})

export class RacesComponent {

races: any = \[\];

refreshRaces() {

this.races = \[{name: 'London'}, {name: 'Lyon'}\];

}

}

在你的浏览器中，一开始会看到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-root\>

\<h1\>PonyRacer\</h1\>

\<ns-races\>

\<h2\>Races\</h2\>

\<button (click)="refreshRaces()"\>Refresh the races list\</button\>

\<p\>0 races\</p\>

\</ns-races\>

\</ns-root\>

如果你点击了按钮，'0 races'就会变成'2 races'。耶！

这个声明可以是一个函数调用，也可以是任何可执行的声明，或者是一系列可执行的声明，像是：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<button (click)="firstname= 'Cedric'; lastName= 'Exbrayat'"\>

Click to change name to Cedric Exbrayat

\</button\>

然而我并不建议你这样做。使用方法是封装行为的更好方式：这样使你的代码更好维护、测试，并且会使视图更加清晰。

更酷的是对于标准的DOM事件它都支持，同时它也支持从你自己的Angular组件中或者Web组件中发出的事件。我们将会在后面学习怎样发出自定义的事件。

现在，我们假设当RacesComponent发现一个新的比赛可用的时候就通知应用。

我们AppComponent组件中的模版可能是这个样子的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-root',

template: \`

\<h1\>PonyRacer\</h1\>

\<ns-races (newRaceAvailable)="onNewRace()"\>\</ns-races\>

\`

})

export class AppComponent {

onNewRace() {

// 为用户添加一个闪动信息

}

}

我们可以很容易推测出\<ns-races\>组件有一个自定义的事件NewRaceAvailable，当这个事件发出的时候，AppComponent的方法onNewRace()就会被调用。

Angular会在元素和其子元素上监听，所以就会处理冒出来的事件。考虑下面的模版：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div (click)="onButtonClick()"\>

\<button\>Click me!\</button\>

\</div\>

尽管用户点击了div中的按钮，onButtonClick()方法还是会被调用，因为事件向上冒泡了。

哦，你还可以在被调用的方法中访问事件！只是你必须将\$event传递给你的方法就行：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div (click)="onButtonClick(\$event)"\>

\<button\>Click me!\</button\>

\</div\>

然后你就可以在你的组件类中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

onButtonClick(event){

console.log(event);

}

默认情况下，事件会继续向上冒泡，最终触发上面层级的监听器。

你可以使用事件对象来阻止默认的行为并且/或者取消传播：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

onButtonClick(event) {

event.preventDefault();

event.stopPropagation();

}

另一个有意思的特征是你可以非常容易地处理键盘事件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<textarea (keydown.space)="onSpacePress()"\>Press space!\</textarea\>

没你你按下space键，onSpacePress()方法就会被调用。你可以做一些疯狂的组合，比如(keydown.alt.space)，等等。

总结一下这部分，我想指出以下两种情况存在一个非常大的差别：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<component \[property\]="doSomething()"\>\</component\>

和

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<component (event)="doSomething()"\>\</component\>

第一种情况下，是属性绑定，doSomething()是一个表达式，每次的变化监测循环都会被计算，以确这个属性是否需要更新。

然而在第二种情况下，是事件绑定，doSomething()是一个语句，仅仅是在事件被触发的时候才进行计算。

从定义上来说它们有完全不同的目标，你也可以猜到，它们有不同的限制。

## 表达式和语句

表达式和语句在几个方面是不同的。

表达式作为变化监测的一部分，会被多次执行。它应该尽可能快。基本上，一个Angular表达式是一个JavaScript表达式的简化版本。

如果你正在将user.name作为一个表达式使用，user应该被定义，否则Angular会抛出错误。

一个表达式必须是单一的：不能用分号连接几个不同的部分。

表达式不能有副作用。这就意味着它不能是赋值语句。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<!\-- 禁止， 因为表达式是一个赋值 \--\>

\<!\-- 这样会抛出一个错误 \--\>

\<component \[property\]="user = 'Cedric'"\>\</component\>

表达式不能包含关键字，像是if、var等等。

另一方面，一个语句，会在对应的事件上被触发。如果你使用一个类似于race.show()的语句，当race是undefined的时候，会报错。你可以用分号结合多个语句。一个语句一般都会有副作用。这就是响应事件的关键：让某些事情发生。一个语句可以是一个变量赋值，也可以包含关键字。

## 本地变量

当我说Angular会查询组件实例来找到一个变量的时候，在技术上其实是不准确的。事实上，它会去检查组件实例和本地变量。本地变量是在你的模版中使用\#语法动态声明的。

加入你想要显示一个input的值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input type="text" \#name\>

{{ name.value }}

使用\#语法，我们创建了一个本地变量name，用它来引用DOM对象HTMLInputElement。这个本地变量可以在模版中的任意地方使用。由于其有一个value属性，我们可以用一个插值表达式来显示这个属性。稍后我们会回到这个例子。

本地变量另一个有用的地方是，当你想要在其它元素上执行某些动作的时候。

比如，当你点击一个按钮的时候，你可能想要把焦点放在一个元素上。在AngularJS 1.x时候这样做有点儿麻烦，你必须创建一个自定义的指令等等。

focus()方法是DOM API标准的方法，我们可以利用这点。使用本地变量，在Angular中一点都不费脑筋

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input type="text" \#name\>

\<button (click)="name.focus()"\>Focus the input\</button\>

这也可以被用于一个自定义的组件------在我们应用中创建的、从另一个项目导入的组件、或者甚至是一个真正的Web组件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<google-youtube \#player\>\</google-youtube\>

\<button (click)="player.play()"\>Play!\</button\>

这里的按钮可以开启\<google-youtube\>的视频播放。这是一个Polymer中真正的Web组件！这个组件有一个play()方法，当你点就按钮的时候，Angular会调用这个方法，这太棒了！

本地变量有几种使用场景，我们会逐渐看到它们。其中一个就在接下来的这一节中描述。

## 结构指令

现在，我们的RacesComponent还是没有显示出比赛列表 Angular中的典型的方式就是先创建一个RaceComponent组件来显示每一个比赛。我们这里先简化一下，就是写简单的\<ul\>\<li\>列表。

DOM属性和事件绑定非常棒，但是都不允许我们改变DOM结构，像是迭代一个集合，然后针对集合中的每一项添加一个元素。想要做到这样的效果，我们需要使用结构指令。Angular中的指令和组件非常接近，只是没有模版。它被用于对一个元素添加行为。

Angular提供的结构指令依赖于使用ng-template元素，灵感来自于HTML规范中模版标准标签。在4.0之前还叫做template，但是现在已经不推荐使用了，你现在应该使用ng-template：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ng-template\>

\<div\>Races list\</div\>

\</ng-template\>

这里，我们定义了一个模版，显示了一个简单的div。它单独存在并没有什么用处，因为浏览器不会显示它。但是如果我们在视图中添加一个'模版'元素，那么Angular就可以使用它的内容了。结构指令可以对这些内容进行一些简单的操作，像是显示隐藏内容、重复内容等等。

下面我们看一下哪些指令是可用的！

## NgIf

我们可能想在否和某个条件的时候才初始化模版。为此，我们会使用ngIf指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ng-template \[ngIf\]="races.length \> 0"\>

\<div\>\<h2\>Races\</h2\>\</div\>

\</ng-template\>

框架提供了介个指令，像是ngIf，它们来自于我们之前导入的：BrowserModule。如果有必要，你也可以定义你自己的指令：我们稍后会回来讨论自定义指令。

这里，只有在races的至少有一个元素的时候，模版才会被初始化，也就是说有比赛情况下。由于这个语法有点儿长，有一个简短的版本：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \*ngIf="races.length \> 0"\>\<h2\>Races\</h2\>\</div\>

你应该一直使用这个简短版本。

这个语法使用\*说明它是一个结构化指令。这个ngIf指令会在races变化之后决定是否展示div：如果没有比赛，div就会消失。

框架提供的指令已经为我们事先加载好了，这样我们就不必在\@Component装饰器的directives属性中导入并声明NgIf了。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ng-races',

'template': \`\<div \*ngIf="races.length \> 0"\>\<h2\>Races\</h2\>\</div\>\`

})

export class RacesComponent {

races: Array\<any\> = \[\];

}

从4.0开始就支持else语法了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-races',

template: \`

\<div \*ngIf="races.length \> 0; else empty"\>\<h2\>Races\</h2\>\</div\>

\<ng-template \#empty\>\<h2\>No races.\</h2\>\</ng-template\>

\`

})

export class RacesComponent {

races: Array\<any\> = \[\];

}

## NgFor

当使用真实数据的时候，不可避免地会遇到展示一个列表的情况。这就是NgFor非常有用的时候了：它让我们能够针对集合里的每一个项都初始化一个模版。我们的RacesComponent组件包含了一个races字段，你可能已经猜到了，它就是一个要展示的比赛列表：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-races',

template: \`

\<div \*ngIf="races.length \> 0"\>

\<h2\>Races\</h2\>

\<ul\>

\<li \*ngFor="let race of races"\>{{ race.name }}\</li\>

\</ul\>

> \</div\>

\`

})

export class RacesComponent {

races: Array\<any\> = \[{name: 'London'}, {name: 'Lyon'}\];

}

现在我们就有了一个漂亮的列表，集合中的每一个集合都对应一个li标签！

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul\>

\<li\>London\</li\>

\<li\>Lyon\</li\>

\</ul\>

注NgFor使用了一种特殊的语法，叫做微语法。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul\>

\<li \*ngFor="let race of races"\>{{ race.name }}\</li\>

\</ul\>

它和下面这种更加冗余的写法（我们是不会使用的）是等同的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul\>

\<ng-template ngFor let-race \[ngForOf\]="races"\>

\<li\>{{ race.name }}\</li\>

\</ng-template\>

\<ul\>

这里你能够发现：

-   用于声明内联模版的template元素

-   应用的NgFor指令

-   我们指定要展示集合的NgForOf属性

-   代表当前元素并且使我们能够在插值表达式中使用的race变量

我们并不需要先记住这么多东西，而是使用一种更简洁的形式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul\>

\<li \*ngFor="let race of races"\>{{ race.name }}\</li\>

\</ul\>

也可以声明另一个元素，用于绑定当前元素的索引：

\<ul\>

\<li \*ngFor="let race of races; index as i"\>{{ i }} - {{ race.name }}\</li\>

\</ul\>

本地变量i将会接收当前元素的索引，这个索引起始于0。index是一个导出的变量。一些指令会导出变量，这样你就可以在你的模版中使用它们了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul\>

\<li\>0 - London\</li\>

\<li\>1 - Lyon\</li\>

\</ul\>

还有其它几个有用的导出变量：

-   even，一个布尔值，如果元素的索引为偶数值，就为true

-   odd，一个布尔值，如果元素的索引为奇数值，就为true

-   first，一个布尔值，如果元素为第一个元素，就为true

-   last，一个布尔值，如果元素为最后一个元素，就为true

## NgSwitch

顾名思义，这个指令使我们能够根据不同的条件在不同的模版之间切换。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \[ngSwitch\]="messageCount"\>

\<p \*ngSwitchCase="0"\>You have no message\</p\>

\<p \*ngSwitchCase="1"\>You have a message\</p\>

\<p \*ngSwitchDefault\>You have some messages\</p\>

\</div\>

正如你看到的，ngSwitch接受一个条件，\*ngSwitchCase接受可能的值。如果没有匹配的值你也可以使用\*ngSwitchDefault的模版就会显示。

## 其它模版指令

写模版的时候，还有两个指令可能会有帮，但是它们并不是我们上面看到的结构指令。这些指令叫做标准指令。

## NgStyle

第一个叫做ngStyle。我们已经看到我们可以使用如下的方式影响一个元素的样式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p \[style.color\]="foreground"\>Friendship is Magic\</p\>

如果你需要一次设置多个样式，就可以使用ngStyle指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \[ngStyle\]="{fontWeight :fontWeight, color: color}"\>I've got style\</div\>

这个指令接受一个对象，其键为要设置的样式。键可以使驼峰式的（fontWeight）后者是破折号隔开的形式（'font-weight'）。

## ngClass

类似的，ngClass指令使我们能够动态的在一个元素上添加或者删除类。

对于样式，你可以使用DOM属性绑定来设置一个类：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \[class.awesome-div\]="isAnAwesomeDiv()"\>I've got style\</div\>

或者，如果你想同时设置几个类，就可以使用ngClass：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div \[ngClass\]="{'awesome-div': isAnAwesomeDiv(), 'colored-dive': isAColoredDiv()}"\>I've got style\</div\>

## 经典语法

我们看到的语法都有一种叫做经典语法的相对应。如果你的服务器端模版系统不能同\[\]或者()语法一同工作，或者你讨厌\[\]、()、\*...，经典语法就有了用武之地。

如果你想要声明一个DOM属性绑定，可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony \[name\]="pony.name"\>\</ns-pony\>

使用经典语法可以这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony bind-name="pony.name"\>\</ns-pony\>

对于事件绑定，可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<button (click)="onButtonClick()"\>Click me!\</button\>

对应的经典语法写法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<button on-click="onButtonClick()"\>Click me!\</button\>

对于本地变量，可以使用ref-：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input type="text" ref-name\>

\<button on-click="name.focus()"\>Focus the input\</button\>

其对应的简短形式为：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input type="text" \#name\>

\<button (click)="name.focus()"\>Focus the input\</button\>

## 总结

Angular的模版系统对于HTML的动态部分有着非常强大的语法支持。它让我们能够表达数据和属性绑定，事件绑定和模版细节相关的操作，总的来说，每种都有其对应的符号：

-   {{}}用于插值

-   \[\]用于DOM属性绑定

-   ()用于事件绑定

-   \# 用于本地变量声明

-   \*用于结构指令

与其它框架不同，它提供了一种和标准Web组件狡猾的方式。这些不同的方式之间并没有含糊不清的地方，我们将看到我们的工具和IDE会逐渐改善，使在我们写模版的时候给我们提供有意义的警告。

所有的这些符号都是它们经典语法简短版本，如果你想要使用经典语法也是没有问题的。

你需要一些时间来熟练掌握这种语法，但是你很快就会快起来，并且之后会更容易读写。

在继续之前，让我们先过一遍一个完整的例子。

我想先写一个PoniesComponent组件，用于显示小马的列表。每个小马应该由一个PonyComponent组件表示，但是我们还不知道如何向一个组件传递参数。所以，现在，我们要展示一个简单的列表。这个列表应该只是在非空的时候展示，并且我想要为列表中的偶数行添加一些颜色。最后，我需要一个按钮点击来刷新这个列表。

准备好了吗？

我们开始写组件了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`\`

})

export class PoniesComponent {

}

你可以将其加入到我们先前写的AppComponent组件中去测试它。你需要将其导入，将其添加到指令中，在模版中插入标签\<ns-ponies\>\</ns-ponies\>。

我们的新组件由一个列表的小马：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`\`

})

export class PoinesComponent {

poines: Array\<any\> = \[{name: 'Rainbow Dash'}, {name: 'Pinkie Pie'}\];

}

我们会使用NgFor来展示这个列表：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-poines',

template: \`

\<ul\>

\<li \*ngFor="let pony of ponies"\>{{ pony.name }}\</li\>

\</ul\>

\`

})

export class PoinesComponent {

poines: Array\<any\> = \[{name: 'Raibow Dash'}, {name: 'Pinkie Pie'}\];

}

还有一件事情，刷新按钮：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-poines',

template: \`

\<button (click)="refreshPoines()"\>Refresh\</button\>

\<ul\>

\<li \*ngFor="let pony of poines"\>{{ pony.name }}\</li\>

> \</ul\>

\`

})

export class PoniesComponent {

ponies: Array\<any\> = \[{name: 'Rainbow Dash'}, {name: 'Pinkie Pie'}\];

refreshPonies() {

this.poinies = \[{name: 'Fluttershy' }, {name: 'Rarity'}\];

}

}

当然，还有颜色的事情没做，我们通过使用\[style.color\]和导出的isEvent变量来做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`

\<button (click)="refreshPonies()"\>Refresh\</button\>

\<ul\>

> \<li \*ngFor="let pony of ponies; even as isEven" \[style.color\]="isEven ? 'green': 'black'"\>{{ pony.name }}\</li\>
>
> \</ul\>

\`

})

export class PoniesComponent {

ponies: Array\<any\> = \[{name: 'Rainbow Dash'}, {name: 'Pinkie Pie'}\];

refreshPonies() {

this.ponies = \[{name: 'Fluttershy'}, {name: 'Rarity'}\];

}

}

正如你所看到的，我们使用了所有的模版语法，我们有了一个可以完美工作的组件。当然我们的数据还是硬编码的：很快，我们将看到怎样使用一个服务区获取它们！这就需要我们先要了解依赖注入，然后才能使用HTTP服务！

# 依赖注入

依赖注入是一个著名的设计模式。让我们拿我们应用的一个组件为例。这个组件可也能需要我们应用的其它部分的功能（比如一个服务）。这就叫做依赖。我们不让组件创建自身的依赖，而是让框架来查创建这些依赖，并将其提供给组件。这就是"控制反转"。

它有几个特点：

-   让开发变得容易，我们只需要说明我们在什么地方需要什么即可

-   让测试变得容易，通过使用伪装的依赖替代真实的依赖

-   让配置变得容易，只需要切换不同的实现即可

这是一个在服务器端广泛使用的概念，但是AngularJS 1.x是第一批将其应用到前端的框架。

## 让开发变得容易

要使用依赖注入，我们需要：

-   一种定义依赖的方式，让它能够注入到其它的组件/服务中

-   一种在当前组件/服务中需要什么依赖的声明

以后的事情就交给框架了。当我们在一个组件中声明一个依赖时，它就会搜寻注册表，看是否能够找到这个依赖，然后就会获取这个依赖的实例或者创建一个新的，最后将其注入到我们的组件中。

依赖可以是Angular提供的服务，或者是我们自己写的服务。

我们看一个ApiService服务的例子，这是一个你的同事已经写好的服务。由于他是团队中的懒汉，他就写了一个类，里面有一个叫做get的方法，直接返回了一个空数组，但是你可以猜到这个服务应该是用来与后台API通信的。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class ApiService {

get(path) {

// todo: 调用后台API

}

}

用TypeScript的话，为组件或者服务声明依赖是非常容易的，我们只需要使用类型系统。

比如我们想要实现一个使用ApiService的RaceService：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { ApiService } from './api.service';

export class RaceService {

constructor(private apiService: ApiService) {

}

}

Angular帮我们会获取ApiService服务，并将其注入到我们的构造器中。当需要RaceService的时候，这个构造器会被调用个，我们就有一个apiService字段引用ApiService服务。

现在我们可以添加一个list()方法到我们的服务中，它会使用ApiService服务来调用我们的后端：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { ApiService } from './api.service';

export class RaceService {

constructor(private apiService: ApiService) {

}

list() {

return this.apiService.get('./races');

}

}

要告诉Angular本服务自身有一些依赖，我们需要一个类装饰器：\@Injectable()：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Injectable } from '\@angular/core';

import { ApiService } from './api.service';

\@Injectable()

export class RaceService {

constructor(private apiService: ApiService) {

}

list() {

return this.apiService.get('/races');

}

}

由于我们正在使用ApiService，我们需要将其注册，这样其才能够用来注入。

从Angular 6.0开始，最容易（也是推荐的）的方式就是为ApiService添加\@Injectable装饰器，并在内部直接使用providedIn：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Injectable } from '\@angular/core';

\@Injectable({

providedIn: 'root'

})

export class ApiService {

get(path) {

// todo: 调用后端API

}

}

另一种方式就是使用我们先前看到的\@NgModule装饰器的providers属性（Angular 6.0之前我们就这么用）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { AppComponent } from './app.component';

import { ApiService } from './services/api.service';

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent\],

providers: \[

ApiService

\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

现在，如果我们想要我们的RaceService在其它服务或组件中可以注入，我们也必须注册它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Injectable } from '\@angular/core';

import { ApiService } from './api.service';

\@Injectable({

providedIn: 'root'

})

export class RaceService {

constructor(private apiService: ApiService) {

}

list() {

return this.apiService.get('/races');

}

}

工作结束！

我们可以在任何地方使用我们的心服务。让我们在AppComponent中测试它一下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { RaceService } from './services/race.service';

\@Component({

selector: 'ns-root',

template: \`

\<h1\>PonyRacer\</h1\>

\<p\>{{ list() }}\</p\>

\`

})

export class AppComponent {

// 添加一个带有RaceService的构造器

constructor(private raceService: RaceService) {

}

list() {

return this.raceService.list();

}

}

由于我们的懒同事只是在ApiService类中的get方法中返回了一个空数组，调用这个list()方法你什么也不会得到。

也许我们可以做点儿别的...

## 便于配置

后面的一个章节中我们将回到依赖注入带给我们的可测试性的好处，但是我们可以先看一下配置的问题。这里我们调用了一个并不存在的后端。或许后端团队还没有准备好，或者你想稍后再做。不论如何，我们想要一些假的数据。

DI提供了一种非常好的方式来做到这点。让我们回到注册的部分，如果你选择在模块中声明它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { AppComponent } from './app.component';

import { RaceService } from './services/race.service';

import { ApiService } from './services/api.service';

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent\],

providers: \[

RaceService,

ApiService

\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

我们可以将组件和服务之间的关系并表示成下图的样子，箭头表示**依赖于**：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image2.png){width="4.930555555555555in" height="4.125in"}

事实上，我们写的是下面的简写形式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { AppComponent } from './app.component';

import { RaceService } from './services/race.service';

import { ApiService } from './services/api.service';

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent\],

bootstrap: \[AppComponent\],

providers: \[

{provide: RaceService, useClass: RaceService},

{provide: ApiService, useClass: ApiService}

\]

})

export class AppModule {

}

我们是在告诉注入器，我们想要在一个符号（类型RaceService）和类RaceService之间构建一个链接。注入器是一个服务，它负责通过一个注册表来跟踪可注入的组件，并在需要的时候注入它们。注册表是一个映射，将键（也叫做符号）和类联系起来。不同于其它依赖注入框架，符号并不要求一定是字符串。它们可以是任何东西，比如像是类型引用。一般来说都是这样的。

由于在我们的例子中，符号和类是一样的，你可以以更简短的形式写出同样效果的东西：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { AppComponent } from './app.component';

import { RaceService } from './services/race.service';

import { APiService } from './services/api.service';

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent\],

providers: \[

RaceService,

ApiService

\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

符号必须能够唯一标识依赖。

这里的注入器是由bootstrapModule这个promise返回的，我们可以看一下它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在我们的模块中

providers: \[

ApiService,

{provide: RaceService, useClass: RaceService},

// 让我们添加另一个提供者，但是指向相同的类

// 使用另一个符号

{provide: 'RaceServiceToken', useClass: RaceService}

\]

// 引导模块

platformBrowserDynamic().bootstrapModule(appModule)

.then(

// 查看返回的注入器

appRef =\> playWithInjector(appRef.injector)

);

有趣的部分在于playWithInjector函数。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function playWithInjector(inj) {

console.log(inj.get(RaceService));

// 记录： "RaceService {apiService: ApiService}"

console.log(inj.get('RaceServiceToken'));

// 记录："RaceService {apiService: ApiService}，和上面一样"

console.log(inj.get(raceService) === inj.get(RaceService));

// 记录： 'true'，因为对于一个符号每次都返回同一个实例

console.log(inj.get(RaceService) === inj.get('RaceServiceToken'));

// 记录："false"，因为提供者是不同的

// 所有由两个不同的实例

}

正如你看到的，我们可以通过get方法和一个符号向注入器询问一个依赖。因为我声明了RaceService两次，每次使用不同的符号，所以我们有两个提供者。注入器会在第一次询问某个符号的时候创建一个RaceService的实例，然后后续的对于这个符号的询问都会返回同一个实例。对于每个提供者都是一样的道理，所以这里，我们应用中最终只有两个RaceService的实例，每个符号对应一个。

然而，你不会经常使用符号，甚至根本不用。在TypeScript中，你依赖于类型来完成相应的工作，所以符号就是类型引用，通常绑定在对应的类上。如果你想要使用另一个符号，你必须使用\@Inject()装饰器：查看本章的最后部分来获取更多相关信息。

整个个例子就是为了点出几个事情：

-   提供者就是将一个符号和一个服务联系起来

-   如果使用相同的符号，注入器每次都返回同一个实例

-   符号名字可以不同于类名

实例第一次访问的时候被创建，之后每次调用都返回同一个实例，这也是一个著名设计模式：单例。这非常有用，因为你可以使用一个服务在组件之间共享数据，你可以确信他们共享同样的服务实例。

现在，返回到我们的假RaceService问题。我可以写一个新的类，和RaceService做同样的事，但是返回一个硬编码的数据：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class FakeRaceService {

list() {

return \[{name: 'London'}\];

}

}

我们可以使用提供者声明来用FakeRaceService替代RaceService：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在我们的模块中

providers: \[

// 我们提供了一个假的服务

{provide: RaceService, useClass: FakeRaceService}

\]

如果你重启你的应用，你会看到这次我们有了一个比赛了，因为我们的应用正在使用假的服务，而不是第一个！

现在我们的关系变成了如下的样子：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image3.png){width="6.5in" height="2.5729166666666665in"}

当你手动测试应用的时候，或者写自动化测试的时候，这真的非常有帮助。

## 其它类型的提供者

我们的例子中，我们可能在开发应用的时候想要使用FakeRaceService，而在产品环境中使用真实的RaceService。当然可以手工来调整，但是你也可以用其它类型的提供者：useFactory。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在进入产品环境的时候，我们仅需要修改这个常量即可

const IS\_PROD = false;

// 在我们的模块中

providers: \[

// 我们提供了一个工厂

{provide: RaceService, useFactory: () =\> IS\_PROD ? new RaceService(null) : new FakeRaceService()}

\]

本例中，我们使用了useFactory而不是useClass。一个工厂就是一个只负责一项工作的函数，创建一个对象。我们的例子根据一个常量的值而确定返回假的服务还是真的服务。

但是等一下，如果我们切换回真实的服务，由于我们使用了new来创建一个RaceService，这样它的ApiService依赖就不会被初始化了！没错，如果我们想要让这个例子正常工作，我们必须向构造器调用传递一个ApiService的实例。好消息：useFactory可以同一个叫做deps的属性一同使用，在这里你可以指定依赖的一个数组：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 进入产品环境的时候，我们仅需要修改这个常量即可

const IS\_PROD = true;

// 在我们的模块中

providers: \[

ApiService,

// 我们提供了一个工厂

{

> provide: RaceService,

// apiService实例将会在工厂中被注入进去

// 所以我们可以将其传递到RaceService中

useFactory: apiService =\> IS\_PROD ? new RaceService(apiService) : new FakeRaceService(),

deps: \[ApiService\]

}

\]

哦！

注意：如果有多个依赖，参数的顺序应该同数组的顺序相同！

当然，这个例子仅仅是说明useFactory的使用和它的依赖。你能够而且应该这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在我们的模块中

providers: \[

ApiService,

{provide: RaceService, useClass: IS\_PROD ? RaceService: FakeRaceService}

\]

声明一个IS\_PROD常量真是够无聊的：或许我们也可以使用依赖注入？如你所见，我们正在往前一步，你不必将所有的东西都放到DI中，这里仅仅是想你展示另一种提供类型：useValue。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 在我们的模块中

providers: \[

ApiService,

// 我们提供了一个工厂

{provide: 'IS\_PROD', useValue: true},

{

provide: RaceService,

useFactory: (IS\_PROD, apiService) =\> IS\_PROD ? new RaceService(apiService) : new FakeRaceService(),

deps: \['IS\_PROD', ApiService\]

}

\]

## 层级化的注入器

在Angular中最后需要理解的一个重点：在你的应用中有多个注入器。事实上，每个组件对应一个注入器，这个注入器继承自其父组件的注入器。

假设我们有一个像下面这样的应用：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image4.png){width="5.486111111111111in" height="4.472222222222222in"}

我们有一个模块AppModule，它有一个根组件AppComponent，根组件又有一个孩子组件RacesComponent。

当引导应用的时候，我们为这个模块创建根注入器。然后，每个组件会创建自己的注入器，会继承其父组件的注入器。

当你使用推荐的providedIn: 'root'或者使用模块的providers注册一个服务的时候，这些服务会被加入到根注入器。逐日'root'并不是providedIn唯一允许的值：事实上，如果你的应用中共有多个模块，你可以只将其加入到一个模块中，像是providedIn: RacesModule。

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image5.png){width="5.152777777777778in" height="3.7222222222222223in"}

这意味着当我们在组件中声明一个依赖的时候，Angular会从当前的注入器开始搜寻。如果找到了依赖，非常完美，那就直接返回它。如果找不到，就会在父注入器中搜寻，直到找到这个依赖。如果最终也没有找到，就会抛出异常。

从这，我们可以 总结出两点：

-   在根注入器中声明的依赖可以在应用的任意组件中使用。比如，ApiService和RaceService可以在任何地方使用。

-   我们可以在模块之外的层级去声明依赖。怎么做呢？

\@Component装饰器可以接受另一个配置选项，叫做providers。这个providers属性可以接受一个列表，里面是一系列的依赖，这和\@NgModule的providers属性一样。

我们可以假定一个RacesComponent会声明其自身的RaceService提供者：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-races',

providers: \[{provide: RaceService, useClass: FakeRaceService}\],

template: \`

\<strong\>Races list: {{ list() }}\</strong\>

\`

})

export class RacesComponent {

constructor(private raceService: RaceService) {

}

list() {

return this.raceService.list();

}

}

在这个组件中，提供者符号RaceService总是会给出FakeRaceService的一个实例，而不会关心根注入器的相关定义。当你想要对某个组件使用不同的服务实例，或者想要完美封装一个组件，所有的东西都由其自己声明的情况下，这就非常有用了。

注意：如果你在你的应用的模块声明了一个依赖，同时在你的组件中的providers属性声明了这个依赖，就会有两个不同的依赖实例被创建和使用！

这里我们就有了：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image6.png){width="5.388888888888889in" height="3.486111111111111in"}

注入过程会做如下的解析：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image7.png){width="6.5in" height="3.5659722222222223in"}

根据经验法则，如果只有一个组件需要访问一个服务，只将这个服务在组件的providers属性中提供是一个不错的选择。如果依赖会被整个应用使用，就在根模块中声明。

## 没有类型的DI

在依赖注入中也可以不使用类型，而是使用\@Inject()装饰器。使用这个装饰器，你可以注入服务，也可以是简单的值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Inject, Injectable } from '\@angular/core';

import { BACKEND\_URL } from './tokens';

\@Injectable({

providedIn: 'root'

})

export class RaceService {

constructor(@(BACKEND\_URL) private url: string) {

}

}

要使用\@Inject()，你必须给其一个符号。这个符号是这样定义的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { InjectionToken } from '\@angular/core';

export const BACKEND\_URL = new InjectionToken\<string\>('API URL');

然后我们使用这个符号，在模块的providers中这样定义其值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{provide: BACKEND\_URL, useValue: 'http://localhost:8080'},

或者你可以直接在providedIn中注册它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export const BACKEND\_URL\_PROVIDED = new INjectionToken\<string\>('API URL', {

providedIn: 'root',

factory: () =\> 'http://localhost:8080'

});

注意这种情况下，你可以使用Angular CLI的环境变量特性。

Angular自身使用这种符号机制，使我们能够定义应用的本地语言，这是通过使用符号LOCALE\_ID实现的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@NgModule({

imports: \[BrowserModule\],

declarations: \[CustomLocaleComponent\], // 还有其它组件

providers: \[

{provide: LOCALE\_ID, useValue: 'fr-FR'}

\]

// ...

})

export class AppModule {}

\@Component({

selector: 'ns-locale',

template: \`

\<p\>The locale is {{ locale }}\</p\>

\<!\-- 将显示'fr-FR' \--\>

\<p\>{{ 1234.56 \| number }}\</p\>

\<!\-- 将显示 '1 234,56' \--\>

\`

})

class CustomLocaleComponent {

constructor(\@Inject(LOCAL\_ID) public locale: string) {}

}

我们会在稍后讨论国际化应用的时候继续探讨它。

# 服务

Angular包含了服务的概念：你可以在其它部分注入的类。

框架提供了几个服务，其中一些是由通用模块提供的，其它的你可以由你自己构建。我们可以在相关章节中看到通用模块提供的服务；现在，我们看一下核心的服务，并且弄清楚我们怎样构建自己的服务。

## Title服务

核心框架提供了极少数的服务，能在应用中使用的就更罕见了：基本上只有两个。

经常冒出的一个问题是我怎么才能够修改页面的标题？很容易！有一个可以注入的Title服务，它提供了getter和setter方法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { Title } from '\@angular/platform-browser';

\@Component({

selector: 'ns-root',

template: \`

\<h1\>PonyRacer\</h1\>

\`

})

export class AppComponent {

constructor(title: Title) {

title.setTitle('PonyRacer - Bet on ponies');

}

}

这个服务会在必要的情况下在head中创建title元素，并为你设置正确的值！

## Meta服务

另一个服务有些类似：它使我们获取或者更新页面的"元"值。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { Meta } from '\@angular/platform-browser';

\@Component({

selector: 'ns-root',

template: \`\<h1\>PonyRacer\</h1\>\`

})

export class AppComponent {

constructor(meta: Meta) {

meta.addTag({name: 'author', content: 'Ninja Squad'});

}

}

## 写出自己的服务

确实是非常简单。就是创建一个类而已：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class RacesService {

list() {

return \[{name: 'London'}\];

}

}

像是在AngularJS 1.x中一样，一个服务是一个单例，所以同样地，所有的注入都是注入的一个唯一的一个类实例。这样就使一个服务成为在相互无关的组件之间共享状态的合适选择！

如果你的服务自身也有一些依赖，那么你需要用\@Injectable()装饰器装饰它。如果没有这个装饰器，框架是不会做依赖注入的。

我们的RacesService应该使用REST API获取比赛信息，而不是每次都返回相同的列表。要做一个HTTP请求，框架提供了一个HttpClient服务。不要担心，我们很快就会看到它时怎样工作的。

我们的服务依赖HttpClient来获取比赛信息，所以我们需要添加一个构造器，HttpClient服务作为其中一个参数，并使用\@Injectable()装饰这个类。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Injectable } from '\@angular/core';

import { HttpClient } from '\@angular/common/http';

\@Injectable({

providedIn: 'root'

})

export class RacesServiceWithHttp {

constructor(private http: HttpClient) {}

list() {

return this.http.get('/api/races');

}

}

下面就需要去注册这个服务，或者是将其加入到一个组件的providers属性中，或者将其添加到根模块的providers中，或者在Angular 6.0之后，可以像上面一样在\@Injectable()中使用providedIn。

# 管线

有时候原始数据并不是我们想要在视图上展现的格式。我们通常想要转换它们、过滤它们、限制他们的数量等等。AngularJS 1.x有一种非常方便的特性来完成这种工作，但是不幸地是被命名成了"过滤器"。吸取教训之后，现在这些转换器有了更加有意义的名字！Nah，我就是开个玩笑，他们叫做"管线"。

管线可以应用在HTML或者你的应用代码中。让我们举个例子看看怎样使用它。

## json

在生产环境中可能没那么有用，但是在调试程序的时候确实非常有用的管线，就是JsonPipe。基本上，这个管线就是在你的数据上应用JSON.stringify()。比如你的组件中有一些数据，一个数组的小马，叫做ponies，并且你想要迅速看到里面的东西，你可能会这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ ponies }}\</p\>

真不走运，这里会显示\[object Object\]...

但是JsonPipe会来拯救我们。你可以在HTML中使用它，映红在任何表达式上：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ ponies \| json }}\</p\>

让后就会展示出你对象的JSON表示：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>\[{"name": "Rainbow Dash"}, {"name": "Pinkie Pie"}\]\</p\>

你可以看到'管线'这个名字是从什么地方来的了。要使用一个管线，你必须在你的数据后添加一个管线符（\|），然后就是管线的名字。表达式会进行计算，其结果会经过管线。也可以串联几个管线，先后排列，像是：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ ponies \| slice:0:2 \| json }}\</p\>

我们稍后会介绍slice管线，但是你能看到我们串联了slice管线和json管线。

你可以在插值表达式中使用，也可以在DOM属性表达式中使用，但是不能在时间声明中使用。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p \[textContent\]="ponies \| json"\>\</p\>

你也可以通过依赖注入在你的代码中使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

// 你需要导入想要使用的管线

import { JsonPipe } from '\@angular/common';

\@Component({

selector: 'ns-ponies',

template: \`\<p\>{{ poniesAsJson }}\</p\>\`

})

export PoniesComponent {

ponies: Array\<any\> = \[{name: 'Rainbow Dash'}, {name: 'Pinkie Pie'}\];

poniesAsJson: string;

// 注入要使用的管线

constructor(jsonPipe: JsonPipe) {

// 调用其转换方法

this.poniesAsJson = jsonPipe.transform(this.poines);

}

}

但是要知道：管线必须被加入到\@NgModule（或者\@Component）的providers中，才能这样使用。

由于每种管线都是这样，我后面将只会向你展示使用插值的HTML的例子。

## slice

如果你只是想展示列表的一部分，slice就派上用场了。它和JavaScript中slice方法类似，它接受两个参数：一个开始索引，和一个可选的终止索引。

要向一个管线传递参数，就必须添加一个冒号:，然后是第一个参数，然后是另一个分号和第二个参数等等。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ ponies \| slice:0:2 \| json }}\</p\>

这个例子将会展示小马列表的前两个元素。

slice可以在数组和字符串上应用，所以你也可以截断字符串：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \| slice:0:5}}\</p\>

这样其只会显示'Ninja'。

你可以只给slice管线传递一个索引n，这样它就会选取从n开始到结束的元素。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \| slice:3}}\</p\>

\<!\-- 将会显示 'ja Squad' \--\>

如果你给它一个负数，它就会选取后nge元素

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \| slice:-5 }}\</p\>

\<!\-- 将会显示'Squad' \--\>

正如我们看到的，你可以给这个管线一个终止索引：它会选取直到这个苏音的元素。如果这个索引是负的，它就会选取直到这个索引的元素，但是是从尾部开始。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \| slice: 2:-2 }}\</p\>

\<!\-- 将会显示'nja Squ' \--\>

因为你可以在任何表达式中使用slice，你甚至可以将其和NgFor一起使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`\<div \*ngFor="let pony of ponies \| slice:0:2"\>{{ pony.name }}\</div\>\`

})

export class PoniesComponent {

ponies: Array\<any\> = \[

{name: 'Rainbow Dash'},

{name: 'Pinkie Pie'},

{name: 'Fluttershy'}

\];

}

这个组件只会创建两个div元素，也就是前两个小马，这就是因为我们对集合应用了slice。

管线参数当然也可以是动态的值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`

\<div \*ngFor="let pony of ponies \| slice:0:size"\>{{ pony.name }}\</div\>

\`

})

export class PoniesComponent {

size = 2;

ponies = \[

{name: 'Rainbow Dash'},

{name: 'Pinkie Pie'},

{name: ''Fluttershy}

\];

}

你可以利用这点创建动态展示效果，比如你的用户可以选择他们想看到多少的元素。

注意，也可以将slice返回的结果存储在一个变量中，使用的语法是在4.0的时候引入的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-ponies',

template: \`

\<div \*ngFor="let pony of ponies \| slice:0:2 as total; index as i"\>

{{ i+1 }}/{{ total.length }}: {{ pony.name }}

> \</div\>

\`

})

export class PoniesComponent {

ponies: Array\<any\> = \[

{name: 'Rainbow Dash'},

{name: 'Pinkie Pie'},

{name: 'Fluttershy'}

\];

}

## uppercase

顾名思义，这个关键就是将一个字符串转换成大写个事：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \| uppercase }}\</p\>

\<!\-- 将显示为'NINJA SQUAD' \--\>

## lowercase

和上一个管线相对应，这个管线是将字符串转换为小写形式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'Ninja Squad' \|lowercase }}\</p\>

\<!\-- 显示为 'ninja squad' \--\>

## titlecase

Angular 4 引入了一个新的titlecase管线。它会将所有单词的第一个字母转换为大写格式：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 'ninja squad' \| titlecase }}\</p\>

\<!\-- 显示为'Ninja Squad' \--\>

## number

下面的管线（number、percent、currency、date）可以帮助国际化。在Angular 5.0中它们都经过了完全的检查，以后就不要使用浏览器的Intl API了（会引起大量的bug）。Angular团队已经自己实现了国际化逻辑。下面的例子使用了Angular 5的新实现的管线，而没有更深地涉及国际化细节，本书的最后一章覆盖了这个话题。例子也使用了Angular默认的locale，en-US。

这个管线能够格式化数字。

它接受一个参数，一个格式化的字符串：{integerDigits}.{minFractionDigits}={maxFractionDigits}，但是每一部分都是可选的。每部分分别代表：

-   在整数部分想要多少个数字

-   小数部分至少多少个数字

-   小数部分至多多少个数字

几个例子，从没有应用管线的情况开始：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 12345 }}\</p\>

\<!\-- 显示 '12345' \--\>

即使没有要求的数字，number管线还是会分组整数部分：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 12345 \| number }}\</p\>

\<!\-- 显示'12,345' \--\>

如果需要integerDigits将会用零做左填充：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 12345 \| number:'6.' }}\</p\>

\<!\-- 显示'012,345' \--\>

minFractionDigits是消暑部分的最小数量，所以如果达不到这个数量，就会在右侧填充零，直到满足条件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{{ 12345\|number:'.2' }}

\<!\-- 显示'12,345.00' \--\>

maxFractionDigits是小数部分的最大值。如果你想使用它的话，你必须指定一个minFrationsDigits，即使其为0也必须指定。如果数字小数部分的数字个数多于这个值，就会被做舍入处理：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 12345.13 \| number:'.1-1' }}\</p\>

\<!\-- 显示为'12,345.1' \--\>

\<p\>{{ 12345.16 \| number:'.1-1' }}\</p\>

\<!\-- 显示为'12,345.2' \--\>

## percent

和number适用于同样的原则，percent让我们能够显示百分比！

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 0.8\|percent }}\</p\>

\<!\-- 显示 '80%' \--\>

\<p\>{{ 0.8\|percent:.3 }}\</p\>

\<!\-- 显示 80.000% \--\>

## currency

可以想象到，这个管线是以某种货币格式化一定数量的钱。你必须给其至少一个参数：

-   代表货币的ISO字符串（'EUR', 'USD'...）

-   可选项，指定是否使用符号(\' €\', \'\$\', CA \$\')，可以选择'symbol'或者ISO编码'code'，或者可以通过'symbol-narrow'指定使用窄符号。加元窄符号就像是\$，而加元符号是CA\$。默认值就是'symbol'。

-   也是可选项，使用与number相同的语法来格式化金额

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ 10.6 \| currency:'CAD' }}\</p\>

\<!\-- 显示\'CA \$ 10.60\' \--\>

\<p\>{{ 10.6 \| currency:'CAD':'symbol-narrow' }}\</p\>

\<!\-- 显示 \'\$ 10.60\' \--\>

\<p\>{{ 10.6 \| currency:'EUR':'code':'.3' }}\</p\>

\<!\-- 显示'EUR10.600' \--\>

## date

date管线将日期格式化成期望格式的字符串。日期可以是一个Date对象或者毫秒数。指定的格式可以像是'dd/MM/yyyy'、'MM-yy'或者是预定义的符号化的名字，像是'short'、'longDate'等等。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ birthday \| date:'dd/MM/yyyy' }}\</p\>

\<!\-- 显示 '16/07/1986' \--\>

\<p\>{{ birthday \| date: 'longDate' }}\</p\>

\<!\-- 显示 'July 16, 1986' \--\>

当然，你也可以展示日期的时间部分：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>{{ birthday \| date:'HH:mm' }}\</p\>

\<!\-- 显示'15:30'\--\>

\<p\>{{ birthday \| date:'shortTime' }}\</p\>

\<!\-- 显示'3:30 PM' \--\>

## async

async管线允许异步获取的数据得以展示。在底层它会根据数据来自于一个Promise还是一个Observable来选择使用PromisePipe或者ObservablePipe来完成相应工作。我希望你已经知道了Promise是什么了（否则就回到ES6那章看看），我们不久之后就会谈及Observable了。

async管线在数据可用（如果是promise，就是等到promise被确定）之前都会返回一个空字符串。一旦确定，解析出来的值就会被返回。更重要的是，一旦数据可用它就会触发一个变化检测。

下面的例子使用一个Promise：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-greeting',

template: \`

\<div\>{{ asyncGreeting \| async}}\</div\>

\`

})

export class GreetingComponent {

asyncGreeting = new Promise(resolve =\> {

// 1秒钟之后，promise就可以确定了

window.setTimeout(() =\> resolve('hello'), 1000);

})

}

可以看到async管线被应用于asyncGreeting变量。这个变量是一个promise，1秒钟之后确定。一旦promise被确定，我们的浏览器就会显示：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div\>hello\</div\>

更有趣的是，如果源是一个Observable，当组件被销毁时，管线会自动完成解除订阅操作（比如，用户导航进入另一个组件的时候）。

为了避免多次订阅到你的Observable，或者是多次调用Promise，你可以将调用的结果通过as存储（4.0之后）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-user',

template: \`\<div \*ngIf="asyncUser \| async as user"\>{{ user.name }}\</div\>\`

})

export class UserComponent {

asyncUser = new Promise(resove =\> {

// 1秒之后，promise就可以被确定

window.setTimeout(() =\> resolve({name: 'Cedric'}), 1000);

});

}

## 创建你自己的管线

当然，你也可以创建你自己的管线。有些时候非常有用。在AngularJS 1.x中，我们经常使用自定义的过滤器。比如，我们要在应用中创建一个来显示用户做了某项操作之后所经历的时间（像是12秒之前或者3天之前）。让我们看看在Angular中我们可以怎么做！

首先我们需要创建一个类。它应该实现PipeTransform接口，这会要求我们实现一个tranform()方法，也就是真正做事情的方法。

看上去不怎么难，让我们试一下！

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Pipetranform, Pipe } from '\@angular/core';

export class FromNowPipe implements PipeTransform {

transorm(value, args) {

// 在这里做事情

}

}

我们要使用Moment.js的fromNow函数来显示某个时间之后过去了多长时间。

你可以使用NPM来安装Moment.js：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

npm install moment

Moment的类型已经包含在NPM的依赖中了，所以TypeScript编译器可以开心地接受，我们不用做任何事情。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { PipeTransform, Pipe } from '\@angular/core';

import \* as moment from 'moment';

export class FromPipe implements PipeTransform {

transorm(value, args) {

return moment(value).formNow();

}

}

现在我们需要在我们的应用中注册这个管线。为此，我们需要一个特殊的装饰器：\@Pipe：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import {PipeTransform, Pipe} from '\@angular/core';

import \* as moment from 'moment';

\@Pipe({name: 'fromNow'})

export class FromNowPipe implements PipeTransform {

transorm(value, args) {

return moment(value).fromNow();

}

}

选择的名字就是可以在模版中使用的管线的名字。

要在模版中使用这个管线，最后一项工作就是要将其加入到\@NgModule的declarations中。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@NgModule({

imports: \[BrowserModule\],

declarations: \[AppComponent, RacesComponent, FromNowPipe\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

# 响应式编程

## 给我电话

你最近可能听说过响应式或者函数响应式编程。在几种语言平台上正变得流行起来，比如.Net有Reactive Extension库，现在在几乎每种语言中都可用了（RxJava、RxJS等等）。

响应式编程并不是新生事物。它是一种通过使用事件并对事件作出响应（也就是其名字的由来）的机制来构建的应用。事件可以通过使用函数map、filter、等函数被组合、过滤、分组等等。这就是你经常看到术语"函数响应式编程"的原因。但是，为了准确起见，响应式编程并不是真正的函数式编程，因为它并不必包含不可变的概念，也就是缺乏消除副作用的概念。响应事件这种事情可能你早就做过：

-   在浏览器中，对于用户的事件设置监听器

-   在后端，响应来自于消息队列的事件

在响应式编程中，所有的数据都以流的形式获取。这些流可以被监听、当然也可以修改（过滤，合并...），甚至可以变成可以被监听的全新的流。这个技术能够产生相当解耦合的程序：你不需要担心方法调用的影响，你仅仅就是触发一个事件，你应用中对此感兴趣的部分会做出相应的响应。可能这些部分之一也会触发一个事件。

现在，我为什么要告诉你这些呢？它和Angular又有什么关系呢？

好吧，Angular是使用响应式编程构建的，我们也会在某些部分用到这项技术。响应一个HTTP请求？响应式编程。为我们的组件生成一个自定义事件？响应式编程。处理表单中值的变化？响应式编程。

所以，让我们花几分钟在在这个主题上。没有什么困难的地方，但是对此必须保持一个清晰的思路。

## 通用原则

在响应式编程中，所有的东西都是流。一个流是一个有序的事件序列。这些事件代表值（看，另一种值！）、错误（糟糕了）或者完成事件（做完了）。所有这些都是从数据生产者压向数据消费者。作为开发者，你的工作就是**subscribe**到这些流上，然后定义一个监听器以处理三种可能的情况。这样的监听器叫做**observer**，而流叫做**observable**。这些术语很早之前就有了，因为这是一种非常有名的设计模式：观察者模式。

它们和promise不同，即使它们看上去有点儿类似，因为它们都是用来处理异步值的。但是一个observer并不是想promise那样是一个一次性的东西：它会在收到'完成'事件之前一直监听。

现在，observable还不是ECMAScript规格的一部分，但是在未来的版本中就可能包含进来了，因为现在正在努力将其标准化。

Observables和数组非常相似。一个数组是值的集合，这点和observable类似。一个observable仅仅是加入了**在时间上的值（values over time）**的概念：在一个数组中，你一次性获取所有的值，而在一个observable中，值会随着时间不断进来，或许是每几分钟一次。

在JavaScript生态中最受欢迎的响应式编程库就是RxJS。这也是Angular依赖的库，我们就使用它了。

所以我们来看一下。

## RxJS

每个observable，就像每一个数组一样，可以使用函数对其进行转换，这些函数你可能都已经碰到过了：

-   take(n) 获取前n个事件（比如，前5个）。

-   map(fn)将fn应用到每个事件，并返回结果。

-   filter(predicate) 只会放行满足预期条件的事件。

-   reduce(fn) 对每个事件应用fn，将流简化成一个值。

-   merge(s1, s2) 合并流。

-   subscribe(fn) 对于接收到的每个事件应用fn。

-   还有很多

这样，如果你有一个数组的数字，想要每个都乘以2，然后过滤小于5的值，最后打印出来，你可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\[1, 2, 3, 4, 5\]

.map(x =\> x \* 2)

.filter(x =\> x \> 5)

.forEach(x =\> console.log(x)); // 6, 8, 10

RxJS允许我们从一个数组构建一个observable。正如下面所看到的，我们可以做和数组同样的事情：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { from } from 'rxjs';

import {filter, map} from 'rxjs/operators';

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

from(\[1, 2, 3, 4, 5\]).pipe(

map(x =\> x \*2),

filter(x =\> x \> 5)

).subscribe(x =\> console.log(x)); // 6, 8, 10

但是一个observable可不仅仅是一个集合。它是一个异步的集合，事件会随着时间不断到来。一个很好的例子就是浏览器时间。浏览器时间会随着时间不断发生，所以它们是使用observable的好的候选。这里是一个使用JQuery的例子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { fromEvent } from 'rxjs';

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const input = \$('input');

fromEvent(input, 'keyup')

.subscribe(() =\> console.log('keyup!'));

input.trigger('keyup'); // 记录"keyup!"

input.trigger('keyup'); // 记录"keyup!"

你可以从AJAX请求、浏览器时间、Web Scokets响应、一个promise，以及任何你能想到的东西来构建observables。当然也可以从一个函数来构建了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const observable = Observable.create((observer) =\> observer.next('hello'));

observable.subscribe((value) =\> console.log(value));

// 记录 "hello"

Observable.create接受一个相observer提交事件的函数作为参数。这里作为说明，它仅仅提交了一个事件。

你也可以处理错误，因为你的observable可能会出错。subscribe方法可以接受另一个参数，其就是被设计用来处理错误的。

这里map方法抛出了一个异常，所以subscribe方法的第二个处理句柄就会记录下来。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

range(1, 5).pipe(

map(x =\> {

if (x % 2 === 1) {

throw new Error('something wen wrong');

> } else {
>
> return x;
>
> }

}),

filter(x =\> x \> 5)

).subscribe(x =\> console.log(x), error =\> console.log(error)); // 出问题了

一旦observable完成，它就会提交一个完成事件，这可以通过第三个处理句柄获得。这里，range方法会从1迭代到5，然后提交"完成"信号：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

range(1, 5).pipe(

map(x =\> x \* 2),

filter(x =\> x \> 5)

).subscribe(x =\> console.log(x), error =\> console.log(error), () =\> console.log('done'));

// 6, 8, 10 , done

对于一个observable，你可以做很多很多事情：

-   转换（delaying、debouncing...）

-   组合（merge、zip、combineLastest...）

-   过滤（distinct、filter、last...）

-   数学计算（min、 max、average、reduce...）

-   条件判断（amb、includes...）

我们需要一整本书才能全面介绍它们！如果你想更进一步，可以看一下Rx Book。它包含了在这个主题上我看到的最棒的介绍。如果你想全面了解每个函数都做了什么，可以到这里rxmarbles.com。

现在，让我们看一下我们会在Angular中怎样使用observables。

## Angular中的响应式编程

Angular使用了RxJS，也允许我们使用它。框架在Observable对象基础上提供了一个适配器：EventEmitter。EventEmitter有一个叫做subscribe()的方法用来对事件作出响应，这个方法可以接受三个参数：

-   一个响应事件的方法

-   一个响应错误的方法

-   一个响应完成的方法

EventEmitter可以通过调用emit()方法提交一个事件。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const emitter = new EventEmitter();

emitter.subscribe(

value =\> console.log(value),

error =\> console.log(error),

() =\> console.log('done')

);

emitter.emit('hello');

emitter.emit('there);

emitter.complete();

// 记录 "hello", 然后 "there"，然后 "done"

注意subscribe方法返回了一个订阅对象，可以通过其unsubscribe来解除订阅。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const emitter = new EventEmitter();

const subscription = emitter.subscribe(

value =\> console.log(value),

error =\> console.log(error),

() =\> console.log('done')

);

emitter.emit('hello');

subscription.unsubscribe(); // 解除订阅

emitter.emit('there');

// 只会记录 "hello"

现在你对响应式编程和EventEmitter已经了解一些了，让我们看一下Angular是怎样使用它的。

# 构建组件和指令

## 介绍

目前为孩子，我们看到了一些小的组件。当然，你可以感觉到，它们就是我们应用的骨架，它们会比我们看到的更复杂。我们怎样传递数据？我们怎样管理我们组件的生命周期？构建这些东西的最佳实践是什么？

指令：它们是做什么的？它们做事情吗？让我们搞明白！

## 指令

指令和组件特别像，只是它没有模版而已。事实上，在框架中，Compnent类继承自Directive类。

所以先学习指令就说得过去了，我们看到的指令相关的多有的东西也都能够应用于组件。我们将会研究最可能使用的配置项。更加高级的内容会放到后面的章节中，如果你已经掌握了基础的东西，就可以去看它们了。

和组件类似，你的指令也会被一个装饰器注解，只是使用的不是\@Component，而是\@Directive。

指令时非常小的片段。你可以将其认为是你HTML的装饰器：它们会在DOM的元素中添加行为。你可以在同一个元素上拥有多个指令。

一个指令必须有一个CSS选择器，用来指示在我们模版中的什么地方激活它。

## 选择器

选择器有很多种：

-   元素，也就是组件所使用的：footer。

-   类，不是特别常用：.alert 。

-   属性，指令最常用：\[color\]。

-   带有某个值的属性：\[color=red\]。

-   以上的组合：footer\[color=red\]匹配一个叫做footer的元素，并且其color属性值为red。\[color\],footer.alert匹配任意有一个color属性的元素或者（,）带有一个alert CSS类的名为footer的元素。footer:not(.alert)匹配名为footer的元素，但是要求其不具有（:not()）alert CSS类。

比如，这是一个什么都不做的指令，如果一个元素有一个doNothing属性其就会被激活：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[doNothing\]'

})

export class DoNothingDirective {

constructor() {

console.log('Do nothing directive');

}

}

这样的指令将会在如下的TestComponent组件中被激活：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-test',

template: \`

\<div doNothing\>Click me\</div\>

\`

})

export class TestComponent {

}

一个更加复杂的选择器：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: 'div.loggable\[logText\]:not(\[notLoggable=true\])'

})

export class ComplexSelectorDirective {

constructor() {

console.log('Complex selector directive');

}

}

这样其就会匹配所有的带有loggable类并且有一个logText属性且不具有一个值为true的notLoggable属性。

所以这个模版将会触发指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div class="loggable" logText="text"\>Hello\</div\>

但是这个却不能：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div class="loggable" logText="text" notLoggable="true"\>Hello\</div\>

还是说实话吧：如果你这样写，其实是错的!

太好了，我们知道怎样去声明一个指令了。让我们写一个真正做事的指令吧。

## Inputs

数据绑定通常是创建组件或者指令的一大部分工作。从顶层组件向子组件传递数据，你就会用户到属性绑定。

为此，我们要定义接受数据绑定的所有的属性，我们通过使用\@Directive装饰器的inputs属性达到此目的。这个属性接受一个字符串数组，每个的形式为：property: binding。property代表指令实例属性，bingding是包含表达式的DOM属性。

比如，这个指令将DOM属性logText绑定到指令实例属性text：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]',

inputs: \['text: logText'\]

})

export class SimpleTextDirective {

}

如果你的指令中不存在次属性，就会自动创建。然后每次输入变化，属性也会自动更新。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable logText="Some text"\>Hello\</div\>

如果属性变化的的时候想要获得通知，可以再指令中添加一个setter。logText属性每次变化，此setter也会被调用。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]',

inputs: \['text: logText'\]

})

export class SimpleTextWithSetterDirective {

set text(value) {

console.log(value);

}

}

我们使用它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable logText="Some text"\>Hello\</div\>

// 我们的指令会记录 "Some text"

不久之后我们也会看到另一种方式。

这里的text是静态的，当然，通过插值，很容器将其变为动态值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable logText="{{ expression }}"\>Hello\</div\>

// 我们的指令会记录组件中 'expression'的值

或者通过中括号语法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable \[logText\]="expression"\>Hello\</div\>

// 我们的指令会记录组件中 'expression'的值

这是新模版语法最棒的特性之一：作为组件开发者，并不关心组件被如何使用，而是仅仅定义哪些属性被绑定（如果你写过一些AngularJS 1.x，你会知道'@'和'='语法之间是有一些细微的差别的）。

也可以在绑定中使用管线：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable \[logText\]="expression \| uppercase"\>Hello\</div\>

// 我们的指令会以大写形式记录组件中 'expression'的值

如果你想绑定一个DOM属性到一个具有同名的指令的属性中，你可以只写property，而不用写property: binding:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]',

inputs: \['logText'\]

})

export class SameNameInputDirective {

set logText(value) {

console.log(value);

}

}

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div loggable logText="Hello"\>Hello\</div\>

// 我们的指令会记录"Hello"

在指令中有另一种方式来定义输入：通过使用\@Input装饰器。我非常喜欢它，官方的指导风格也推荐使用它，所以后续的大量例子都会使用这种形式。

上面的例子可以重写成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]'

})

export class InputDecoratorDirective {

\@Input('logText') text: string;

}

或者，属性和绑定具有相同的名字：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]'

})

export class SameNameInputDecoratorDirective {

\@Input() logText: string;

}

这增加了一个字段，如果这个时候添加一个同名的setter将会导致TypeScript编译器报错。如果需要（并不是一直需要的）一个setter，一种修复方式是直接在setter上添加\@Input装饰器。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]'

})

export class InputDecoratorOnSetterDirective {

\@Input('logText')

set text(value) {

console.log(value);

}

}

或者，如果setter和绑定同名：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[loggable\]'

})

export class SameNameInputDecoratorOnSetterDirective {

\@Input()

set logText(value) {

console.log(value);

}

}

Inputs非常棒，能够将数据从顶层元素传递到底层元素。比如，如果你需要一个展示小马的列表，很可能你会有一个包含这个列表的顶层组件，还有另一个用于展示一个小马的组件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-pony',

template: \`\<div\>{{ pony.name }}\</div\>\`

})

export class PonyComponent {

\@Input() pony: Pony;

}

\@Component({

selector: 'ns-ponies',

template: \`

\<div\>

\<h2\>Ponies\</h2\>

// pony通过\[pony\]="currentPony"交由PonyComponent处理

\<ns-pony \*ngFor="let currentPony of ponies" \[pony\]="currentPony"\>\</ns-pony\>

> \</div\>

\`

})

export class PoniesComponent {

ponies: Array\<Pony\> = \[

{id: 1, name: 'Rainbow Dash'},

{id: 2, name: 'Pinkie Pie'}

\]

}

好了，怎么向上传递数据呢？我们不能够使用属性将数据从PonyComponent传递到PoniesComponent。但是我们可以使用事件！

## Outputs

让我们回到我们最新的例子，比如我们想要通过点击选择一个小马，并且通知父组件。为此，我们使用一个自定义事件。

这很重要。在Angular中，数据通过属性流入组件，通过事件流出组件。

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image8.png){width="6.5in" height="3.50625in"}

还记得前面章节中的响应式编程吗？太棒了，这里就派上用场了！自定义事件通过一个EventEmitter提交，其必须在装饰器中的outputs属性声明。与inputs属性类似，它接受一个数组，里面包含了你想要你的指令/组件提交的事件列表。也和inputs类似，最好使用\@Output()装饰器。

比如我们想要提交一个叫做ponySelected的事件。我们有三件事情要做：

-   在装饰器中声明这个输出

-   创建一个EventEmitter

-   在小马被选择的时候提交一个事件

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-pony'

// 方法'selectPony()'在点击的时候会被调用

template: \`\<div (click)="selectPony()"\>{{ pony.name }}\</div\>\`

})

export class SelectablePonyComponent {

\@Input() pony: Pony;

// 我们将自定义事件声明为输出

// EventEmitter用于提交事件

\@Output() ponySelected = new EventEmitter\<Pony\>();

/\*\*

\* 当组件被点击的时候

\* 提交一个自定义事件。

\*/

selectPony() {

this.ponySelected.emit(this.pony);

}

}

在模版中使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony \[pony\]="pony" (ponySelected)="betOnPony(\$event)"\>\</ns-pony\>

在上面的例子中，用户每次点击小马的名字，它就会提交一个事件ponySelected，小马本身就是其值（emit()方法的参数）。正如你在模版中看到的，父组件会监听这个事件，并且会以事件\$event为参数调用它的betOnPony方法。必须使用\$event来访问提交的事件：这里就是提交的小马。

父组件必须有一个方法betOnPony()，这个方法会以选中的小马为参数被调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

betOnPony(pony) {

// 对pony做一些事情

}

如果你想，你可以指定一个和事件提交器名字不同的事件名，语法为emitter: event：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-pony'

template: \`\<div (click)="selectPony()"\>{{ pony.name }}\</div\>\`

})

export class OtherSeletablePonyComponent {

\@Input() pony: Pony;

// 提交器叫做\`emitter\`

// 事件名叫做\`ponySelected\`

\@Output('ponySelected') emitter = new EventEmitter\<Pony\>();

selectPony() {

this.emitter.emit(this.pony);

}

}

## 生命周期

你可能想要你的指令在其声明的某个时刻作出响应。

这是非常高级的话题，你不会每天都用到它，我们会快速通过。

有一件重要的事情需要理解，这样会节省你的时间：**组件的输入在其构造器中并不会被计算**。

这意味着下面的组件不会正常工作：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[undefinedInputs\]'

})

export class UndefinedInputsDirective {

\@Input() pony: string;

constructor() {

console.log(\`inputs are \${this.pony}\`);

// 会一直记录'inputs are undefined'

}

}

如果想要访问一个输入的值，比如从服务器加载附加的数据，你就必须使用一个生命周期。

有几个可用的阶段，每个都有其特性：

-   ngOnChanges会在一个绑定的属性变化后第一个被调用。它将接受一个变化以ing舍，包含了此绑定的当前值和先前值，它们被封装在一个SimpleChange中。如果没有变化就不会被调用。

-   ngOnInit只会在第一次变化之后调用一次（而ngOnChanges在每次变化时都会被调用）。这使得此节点成为做初始化工作的绝佳位置，其名字也暗示了这一点。

-   ngOnDestroy在组件被移除后被调用。可以做一些清理工作。

另一些阶段，但是都是用于更加高级的场景：

-   ngDoCheck有点儿不同。如果存在，它就会在每次变化检测循环中被调用，覆盖默认的变化检测算法，用来查找每个绑定变量值之间的不同。这意味着，如果至少一个输入变化了，默认情况下框架就会认为这个组件有了变化，它的子组件将会被检查和重新渲染。但是如果你知道一些输入即使变化了也不会有任何影响，那就可以选择覆盖它。如果想通过只检测最少的值来加速变化检测或者不使用默认的算法，这就非常有用了，但是一般你是不会用到这个的。

-   ngAfterContentInit在组件所有投射的内容第一次被检测之后被调用。

-   ngAfterContentChecked在组件所有的投射内容被检测后调用，即使没有变化也会调用。

-   ngAfterViewInit模版所有的绑定第一次被检测后调用。

-   ngAfterViewChecked早模版所有的绑定第一次被检测后调用，即使没有变化也会被调用。有些情况下非常有用，比如如果你的组件或者指令正在等待一个元素变得可用，然后对其做一些操作，比如将焦点给它。

如果这听上去很难去掌握，不用担心：继续读，我们会在高级组件和指令一章中作出更好的解释。

我们前面的例子最好使用ngOnInit。方法ngOnInit()如果存在，Angular就会调用它，所以你只需要在你的指令中实现就好。如果你正在使用TypeScript开发应用，你可以使用可用的接口OnInit来强迫你实现这个方法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[initDirective\]'

})

export class OnInitDirective implements OnInit {

\@Input() pony: Pony;

ngOnInit() {

console.log(\`inputs are \${this.pony}\`);

// 输入不是undefined了

}

}

现在我们就可以访问到我们的输入了！

如果你想要在每次属性变化的时候都做一些事情，使用ngOnChanges接口：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[changeDirective\]'

})

export class OnChangesDirective implements OnChanges {

\@Input() pony: string;

ngOnChanges(changes: SimpleChanges) {

const ponyValue = changes\['pony'\];

console.log(\`changed from \${ponyValue.previousValue} to \${ponyValue.currentValue}\`);

console.log(\`is it the first change? \${ponyValue.isFirstChange()}\`);

}

}

changes参数时一个映射，绑定名作为键，带有两个属性（先前值和当前值）的SimpleChange对象作为值，还有一个方法isFirstChange()来判断是否时第一次变化！

如果想要响应一个绑定的变化，就可以使用一个setter。下面的例子和上面的效果一样。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[setterDirective\]'

})

export class SetterDirective {

private ponyModel: string;

\@Input()

set pony(newPony) {

console.log(\`changed from \${this.ponyModel} to \${newPony}\`);

this.ponyModel = newPony;

}

}

在想要同时观察多个绑定的时候ngOnChanges更有用。它只会在至少一个绑定发生变化之后才会被调用，并且只会包含已经变化的属性。

ngOnDestroy阶段时清理组件的完美时机------比如，取消一个后台任务。这里，OnDestroyDirective创建后会每隔一秒钟记录"hello"。当组件从页面移除后，你需要停止setInterval来避免内存泄露：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[destroyDirective\]'

})

export class OnDestroyDirective implements OnDestroy {

sayHello: number;

constructor() {

this.sayHello = window.setInterval(() =\> console.log('hello'), 1000);

}

ngOnDestroy() {

window.clearInterval(this.sayHello);

}

}

如果你不这样做，现成会一直记录'hello'直到结束或者崩溃...

## Providers

我们在之前的依赖注入一章中已经讨论过providers了。这属性被用来声明服务，以使其能够在当前指令或者它的子指令中注入。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[providersDirective\]',

providers: \['PoniesService'\]

})

export class ProvidersDirective {

constructor(poiniesService: PoniesService) {

const ponies = poniesService.list();

console.log(\`ponies are: \${ponies}\`)

}

}

## 组件

组件和指令并没有什么不同：只是多了更多的可选的属性，并且**必须**有一个关联的视图。与指令相比它也没有带来很多的新属性。

## 视图提供者

你可是用providers来指定可注入的对象。viewProviders有点儿类似，但是这些提供者仅仅应用于当前的组件，而非其子项。

## 模版/模版URL

\@Component的主要特征是有一个模版，而指令是没有的。你可以使用template以内联的方式声明模版，或者使用templateURL将其写在单独的文件中（两者只能二选一）。

一条经验法则，如果你的模版较小（1-2行），保持其内联是很合适的。当其开始增长的时候，将其转移到它自己的文件中以避免其搞乱你的组件。

你可以为URL指定一个绝对路径，相对路径或者甚至是完整的HTTP URL。

当组件被加载后，Angular解析URL并尝试获取模版。如果成功，这个模版就是组件的Shadow Root，它的表达式也会被计算。

如果我有一个大的组件，我通常将这个模版放在同一个目录的一个单独的文件中，并使用相对URL来加载它。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-templated-pony',

templateURL: 'components/pony/templated-pony.html'

})

export class TemplatedPonyComponent {

\@Input() pony: any;

}

如果你使用一个相对URL，会基于你应用的基础URL来解析出来。URL可能会很笨重，因为你的组件可能在目录components/pony下，你的模版URL就会是components/pony/pony.html。

如果使用CommonJS模块打包应用后，通过使用moduleId属性会稍微好一些。它的值必须是module.id，CommonJS会在运行时设置。Angular后续就可以使用这个值并构建出正确的相对URL。你的模版URL现在可以是这样了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-templated-pony',

templateURL: 'templated-pony.html',

moduleId: module.id

})

export class ModuleIdPonyComponent {

\@Input() pony: any;

}

可以像你的组件一样在同样的目录中定位你的模版了！

更好的是：如果你正在使用Webpack，需要一些配置（如果使用Angular CLI的话，一切就已经准备好了），你甚至可以删除module.id并且直接使用相对路径。Webpack能够为你搞清完整的URL！

## 样式/样式URL

你也可以指定组件的样式。如果你计划开发独立的组件，这非常有用。你可以通过styles或者styleUrls来指定。

正如下面能看到的，styles属性接受一个数组，没元素都是一个CSS规则字符串。可以想见其会增长很快，所以使用一个独立的文件和styleUrls是一个好主意。顾名思义，可以指定一个数组的URLs。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-styled-pony',

template: \`\<div class="pony"\>{{ pony.name }}\</div\>\`,

styles: \['.pony{color: red;}'\]

})

export class StyledPonyComponent {

\@Input() pony: any;

}

## 声明

记住，你必须在你的\@NgModule中声明你使用的每一个指令和组件。如果你不这样做，模版就拿不到你的组件，你也会浪费时间来搞清楚为什么。

两个最常见的问题是忘记声明指令和使用了错误的选择器。如果你发现没有什么效果，可以查查这两项！

我们忽略了一些东西，像是查询、变化检测、导出、封装选项等等。由于它们是更加高级的选项，你不必立即需要它们；但是不要担心，我们会在一个高级章节中看到它们。

# 组件样式和封装

我们先停下来讨论一下样式和CSS。我知道，不是吗？为什么要讨论反复无常的CSS呢？

因为Angular在背后为我们做了很多事情。

作为一个Web开发者，你经常为元素添加CSS类。CSS的一个要素就是串联。有时你确实需要它这样（比如修改应用中所有的字体），另一些时候却不想。比如你想要为列表中一个选中的元素添加一个样式：你通常会使用一个非常窄的CSS选择器，像是li.selected。或者使用一个更加窄的，使用像是BEM风格，因为你仅仅是想要在你应用的某个部分为选中的元素调整样式。

这里Angular就派上用场了。你在组件中定义的风格（不论是通过styles属性，或者是通过styleUrls指定的独立的CSS文件），被Angular限定在这个组件之内，并且只在这个组件内生效。这叫做风格封装。这是怎样做到的呢？

首先你写下一些样式。然后就基于组件装饰器的encapsulation属性的策略选择了。这个属性可以有三种不同的值：

-   ViewEncapsulation.Emulated，默认选项

-   ViewEncapsulation.Native，基于Shadow DOM

-   ViewEncapsulation.None，不需要任何封装

当然每种值意味着不同的行为，我们来看一下。我们拿一个你非常熟悉的组件举例吧，比如我们的PonyComponent。这确实是这个组件的一个简单版本，只是在一个div中展示了小马的名字。为了示例的目的，我们增加了一个CSS类red到这个div中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component, ViewEncapsulation } from '\@angular/core';

\@Component({

selector: 'ns-pony',

template: \`\<div class="red"\>{{ name }}\</div\>\`,

styles: \[\`.red {color: red;}\`\],

// 这就是默认的模式

encapsulation: ViewEncapsulation.Emulated

})

export class PonyComponent {

name = 'Rainbow Dash';

}

这个类就会被用于组件的风格：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

.red {

color: red;

}

正如你看到的，我们以红色的字体展示了小马的名字。

## Native策略

如果你使用Native选项，你就是在告诉Angular来使用浏览器的Shadow DOM来管理封装。Shadow DOM是新的Web组件规范中的一部分。这个规范允许在一个特殊的DOM中创建元素，以完成完美封装。使用这个策略，如果我们用浏览器的查看器查看创建的DOM，我们会看到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-pony\>

\#shadow-root (open)

\<style\>.red {color: red}\</style\>

\<div class="red"\>Rainbow Dash\</div\>

\</ns-pony\>

你注意到\#shadow-root (open)在Chrome的查看器中显示：这是因为我们的组件被包含在一个Shadow DOM元素中了！我们也可以看到样式被添加到我们组件内容的顶部。

使用Native策略，你可以确保你的组件样式不会"侵入"到子项中。如果我们在PonyComponent中有另一个组件，它也可以定义自己的red CSS类为不一样的样式：你确信它们会正确应用，相互之间没有交叉！

但是记住，Shadow DOM是一个相当新的规范，并不是每个浏览器都可用。你可以在网站caniuse.com上来检查可用性。所以，在你的应用中使用的时候要小心一些！

## Emulated策略

如之前所说的，这是默认的策略。理由也非常简单：它模拟了（名字由来）Native策略，但是没有使用Shadow DOM。所以可以在任何地方安全使用，并有相同的行为。

为此，Angular会接管为组件定义的CSS，然后将其内联在页面（而不是我们在Native策略中看到的在每个组件中）的\<head\>元素中。但是在内联它之前，它会重写CSS选择器，附加一个唯一的属性标识。这个唯一的属性之后会被增加到我们组件模版中的所有元素！通过这种方，样式就只会应用到我们的组件中了。同样的例子，现在就是这个样子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<html\>

\<head\>

\<style\>.red\[\_ngcontent-dvb-3\] {color: red}\</style\>

\</head\>

\<body\>

...

\<ns-pony \_ngcontent-dvb-2="" \_nghost-dvb-3=""\>

\<div \_ngcontent-dvb-3="" class="red"\>Rainbow Dash\</div\>

\</ns-pony\>

\</body\>

\</html\>

red类的选择器被重写成.red\[\_ngcontent-dvb-3\]，所以其只会应用在同时具有类red和属性\_ngcontent-dvb-3的元素上。你可以看到这个属性也被自动添加到div中了，所以其能完美地工作。\<ns-pony\>元素也有几个元素：\_ngcontent-dvb-2，也就是为其父元素创建的唯一标识符，还有一个\_nghost-dvb-3是宿主元素自身的唯一标识符。是的，我们添加应用于宿主元素的样式，稍后就会看到。

## None策略

这个策略不会做任何封装。样式会被内联在页面（和Emulated策略类似）的顶端，但是不会被重写。它们的行为就像是"普通的"样式一样，会串联到其子项中。

## 调整宿主样式

存在一个专门为宿主元素调整样式的特殊CSS选择器。它叫做：host，它来自于Web组件规范：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

:host {

display: block;

}

如果使用Native策略就会保持其原样，如果使用Emulated就会被重写为\[\_nghost-xxx\]。

总结一下，你并不需要费心去获取完美封装的样式，因为Emulated策略已经为我们做好了。如果你真对特别的浏览器开发，就可以使用Native策略，如果不需要封装样式就可以使用None策略。策略可以真对每个组件微调，或者在根模块中真对应用全局调整。

# 测试你的应用

## 发现并解决问题的难题在于麻烦会回来

我爱自动化测试。我的职业生涯围绕在IDE中不断变绿的测试进度条上，为我做出的工作鼓励我。我希望你也关心测试，因为它们是我们写代码时的唯一的安全网。没有什么是比手写测试代码更枯燥的了。

Angular让我们能够轻松地写测试。AngularJS 1.x也是这样，也是我喜欢使用它的部分原因。在AngularJS 1.x中，我们写两种类型的测试：

-   但愿测试

-   端到端测试

第一类就是一些简短的代码（一个组件、一个服务、一个管线...）能够独立正确工作的断言。而不用关心它的依赖。写这样的单元测试，要求我们执行每个组件/服务/管线方法，根据相应的输入能否得到预期的输出。我们也可以检查这个单元所需要的依赖也被正确地调用了，比如，我们可以检查一个服务能够进行正确的HTTP请求。

我们也可以写端到端的测试。它们的目的在于模拟一个真实的用户与应用交互，这主要是通过开启一个真实的实例，然后让浏览器输入值，点击按钮等等。我们稍后检查渲染出的页面是我们需要的状态，确保URL也是正确的，你能想到的任何东西。

我们将会覆盖所有这些，但是我们以一个单元测试部分开始。

## 单元测试

正如我们先前看到的，单元测试是独立检查一个小单元的代码。这些测试只能够断言你的应用的一小部分按照预期工作，但是它有几个优点：

-   它们很快，你可以在几秒钟内运行几百个单元测试

-   它们可以高效地测试你所有的代码，特别是在一些很难在真实应用中人工测试的棘手的情况下。

单元测试的一个核心概念是隔离：我们不想让我们的测试受其依赖影响。所以我们经常使用"伪装"对象作为依赖。这些假对象仅仅就是用来测试的。

为此，我们会依赖几个工具。首先我们需要一个库来写测试。最受欢迎之一（如果不是最受欢迎的）的库就是Jasmine，所以我们要使用它！

## Jasmine和Karma

Jasmine给出了几个方法来声明我们的测试：

-   describe() 声明一个测试套件（一组测试）

-   it() 声明一个测试

-   expect() 声明一个断言

使用Jasmine的基础的JavaScript测试看上去像这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class Pony {

constructor(public name: string, public speed: number) {

}

isFasterThan(speed) {

return this.speed \> speed;

}

}

describe('My first test suite', () =\> {

it('should construct a Pony', () =\> {

const pony = new Pony('Rainbow Dash', 10);

expect(pony.name).toBe('Rainbow Dash');

expect(pony.speed).not.toBe(1);

expect(pony.isFasterThan(8)).toBe(true);

});

});

expect()调用可以被大量类似于toBe()、toBeLessThan()、toBeUndefined()的方法级联。每个方法都可以通过expect()返回的对象的not属性取反。

测试文件和你想要测试的代码所在的文件相互独立，其扩展名通常为.spect.ts。pony.ts中Pony类的测试文件的命名可能就是pony.spec.ts。你可以将测试放在正在被测试的代码的旁边，也可以放在一个包含你所有测试的单独的目录中。我倾向于将测试和代码放在同一个目录下，但是两种方法都是没有问题的：站队就行了。

你可以可以使用beforeEach()方法为每个测试创建一个上下文：固定物。如果我在一个相同的小马上有几个测试，使用beforeEach()来初始化这个小马，就比在每个测试中拷贝/粘贴同样的东西更好了。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('Pony', () =\> {

let pony: Pony;

beforeEach(() =\> {

pony = new Pony('Rainbow Dash', 10);

});

it('should have a name', () =\> {

expect(pony.name).toBe('Rainbow Dash');

});

it('should have a speed', () =\> {

expect(pony.speed).not.toBe(1);

expect(pony.speed).toBeGreaterThan(9);

});

});

也有一个afterEach方法，但是我基本上从来不用。

最后一个技巧：Jamine让我们能够创建假对象（也可以叫做伪装、间谍），甚至可以伪装一个真实对象的方法。我们之后就可以在这些方法上做一些断言，像是toHaveBeenCalled()来检查这个方法是否被调用过，或者toHaveBeenCalledWith()来检查调用方法的确切参数。你也可以检查方法被调用了多少次，或者检查其是否之前调用过等等。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('My first test suite with spyOn', () =\> {

let pony: Pony;

> beforeEach(() =\> {
>
> pony = new Pony('Rainbow Dash', 10);
>
> // 定义一个伪装方法
>
> spyOn(pony, 'isFasterThan').add.returnValue(true);
>
> });
>
> it('should test if the Pony is fast', () =\> {
>
> const runPonyRun = pony.isFasterThan(60);
>
> expect(runPonyRun).toBe(true); // 伪装方法一直返回true
>
> expect(pony.isFasterThan).toHaveBeenCalled();
>
> expect(pony.isFasterThan).toHaveBeenCalledWith(60);
>
> });

})

当你写单元测试的时候，记住要保持它们小巧和可读性。不要忘记让它们第一时间失败，以确保你在测试正确的东西。

下一步就是运行我们的测试。为此，Angular团队开发了Karma，唯一目的就是在一个或几个浏览器中运行测试。它也会监视你的文件，一有修改就会重新运行测试。由于运行测试非常快，能够获取近乎实时的代码反馈是一件非常好的事情。

我们不会在怎样构建Karma上深入更多细节，但是它是一个非常有意思的项目，有许多插件可以使用，可以和你最喜欢的工具一起使用，可以提供覆盖报告等等。如果你像我一样使用TypeScript编码，你可以适配的策略就是让TypeScript编译器监视你的代码并测试，在其它输出目录中生成编译后的文件，然后让Karma监视这个目录。

现在我们知道怎样在JavaScript中写单元测试了。让我们把Angular加进来。

## 使用依赖注入

我们有一个Angular应用，其带有一个简单的服务叫做raceService，它包含了一个返回硬编码比赛列表的方法。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable({

providedIn: 'root'

})

export class RaceService {

list(): Array\<RaceModel\> {

const race1: RaceModel = {name: 'London'};

const race2: RaceModel = {name: 'Lyon'};

return \[race1, race2\];

}

}

让我们为它写一个测试。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('RaceService', () =\> {

it('should return races when list() is called', () =\> {

const raceService = new RaceService();

expect(raceService.list().length).toBe(2);

});

});

非常棒。但是我们也可以使用Angular提供的依赖注入来获取RaceService，并将其注入到我们的测试中。如果我们的RaceService自身有一些依赖，就特别有帮助了：我们并不自己初始化这些依赖，我们只需要依赖注入器："嘿，我们想要RaceService，去看看你需要啥，然后创建一个给我"。

要在我们的测试中使用依赖注入系统，框架在TestBed中有一个工具方法叫做get。

这个方法是我们能够在一个测试函数中从注入器获取一个特定依赖。

让我们回到我们的例子，这次使用TestBed.get：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { TestBed } from '\@angular/core/testing';

describe('RaceService', () =\> {

it('should return races when list() is called', () =\> {

const raceService = TestBed.get(RaceService);

expect(raceService.list().length).toBe(2);

});

});

工作正常，因为这个服务已经用providedIn: 'root'声明过了，这样器在测试中也就可用了。它会被初始化，并在需要的时候注入。

正如我们在简单的Jasmine例子中做的，我们可以将RaceService的初始化转移到beforeEach方法中。我们可以在beforeEach中使用TestBed.get，做一下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { TestBed } from '\@angular/core/testing';

describe('RaceService', () =\> {

let service: RaceService;

beforeEach(() =\> service = TestBed.get(RaceService));

it('should return races when list() is called', () =\> {

expect(service.list().length).toBe(2);

});

});

我们将TestBed.get逻辑转移到了beforeEach中，现在我摸的测试更加清晰了。

当然，一个真实的RaceService不会有一个硬编码的比赛列表，非常有可能的是响应是一个异步的。让我们假设list返回一个observable。这会在我们的测试中改变什么呢？好的，我们现在需要在subscribe会调用设置我们的expect：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { async, TestBed } from '\@angular/core/testing';

describe('RaceService', () =\> {

let service: RaceService;

beforeEach(() =\> service = TestBed.get(RaceService));

it('should return an observable of 2 races', async(() =\> {

service.list().subscribe(races =\> {

expect(races.length).toBe(2);

> });

}));

});

你可能会想这可能不会正常工作，因为测试会在subscribe被调用之前结束，我们的预期永远也达不到。

但是这里我们将测试包在了async()函数中。这个方法非常聪明：它跟踪测试中的异步调用并等待它们确定。

Angualr使用了一个新的概念，叫做zones。这些zones是执行上下文，并且，简单来说，它们追踪其内的所有的东西（超时、事件监听器、回调...）。它们也提供了我们进入或者离开zone的时候的钩子。一个Angular应用运行在一个zone中，这也是框架在一个异步操作结束时去刷新DOM的原理。

如果你的测试使用了async()你也使用了这个概念：测试运行于一个zone中，这样框架就知道异步操作什么时候结束，直到异步操作结束测试才结束。

所以我们的异步预期是可以执行的。太棒了！

在Angular中有另一种方式来处理异步测试，就是通过使用fakeAsync()和tick()，但是那是太高级的主题了。

## 假依赖

TestBed类会帮助我们声明假依赖。它的configureTestingModule方法能够声明什么可以被注入到测试中，这是通过值包含我们需要的东西的测试模块实现的。在测试中只注入那些需要的东西，使它们和应用的其它部分尽可能解耦合。这个方法在Jasmine的beforeEach方法中被调用，接受一个模块配置作为参数，和\@NgModule装饰器传入的参数差不多。属性providers接受一个依赖数组，这些依赖就是可注入的。

能够通过测试模块声明依赖有其用处。我们可以不费力地声明一个假服务作为依赖来替代真实的。

为了举例，比如我的RaceService使用本地存储来存储比赛，其键为'races'。你的同事开发 了一个服务叫做LocalStorageService用来出来JSON序列化等等，也就是我们的RaceService要用到的。list()方法看上去就像：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable({

providedIn: 'root'

})

export class RaceService{

constructor(private localStorage: LocalStorageService) {

}

list() {

return this.localStorage.get('races');

}

}

仙子啊，我们不想要测试LocalStorageService服务了，我们仅仅想要测试我们的RaceService。利用依赖注入系统使用一个假LocalStorageService就可以轻松做到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class FakeLocalStorage {

get(key) {

return \[{name: 'Lyon'}, {'name': 'London'}\];

}

}

对于测试中的RaceService，使用provide：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { TestBed } from '\@angular/core/testing';

describe('RaceService', () =\> {

beforeEach(() =\> TestBed.configureTestingModule({

providers: \[

{provide: LocalStorageService, useClass: FakeLocalStorage}

> \]

}));

it('should return 2 races from localStorage', () =\> {

const service = TestBed.get(RaceService);

const races = service.list();

expect(races.length).toBe(2);

});

});

太棒了！但是我们并不十分满意。手动创建假服务很枯燥，Jasmine可以帮助我们入侵服务并且用一个假的实现替换其原有实现。它也允许验证get()方法被使用合适的键"races"来调用。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { TestBed } from '\@angular/core/testing';

describe('RaceService', () =\> {

const localStorage = jasmine.createSpyObj('LocalStorageService', \['get'\]);

beforeEach(() =\> TestBed.configureTestingModule({

providers: \[

{provide: LocalStorageService, useValue: localStorage}

> \]

}));

it('should return 2 races form localStorage', () =\> {

localStorage.get.and.returnValue(\[{name: 'Lyon'}, {name: 'London'}\]);

const service = TestBed.get(RaceService);

const races = service.list();

expect(races.length).toBe(2);

expect(localStorage.get).toHaveBeenCalledWith('races');

});

});

## 测试组件

测试一个简单的服务之后的下一步就是测试一个组件。组件测试有些许不同，因为我们必须创建组件。我们不能靠依赖注入系统给我们一个组件的实例来测试（你现在可能注意到一个组件并不能在其它组件中注入）。

我们先写一个要测试的组件。为什么不是PonyComponent组件呢？它接受一个小马作为输入，并且在组件被点击的时候提交了一个ponyClicked事件。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-pony',

template: \`

\<img \[src\]="'/images/pony-' + pony.color.toLowerCase() + '.png'" (click)="clickOnPony()"\>

\`

})

export class PonyComponent {

\@Input() pony: PonyModel;

\@Output() ponyClicked = new EventEmitter\<PonyModel\>();

clickOnPony() {

this.ponyClicked.emit(this.pony);

}

}

它有一个非常简单的模版：根据小马颜色变化的动态图片资源，和一个点击处理句柄。

要测试这样一个组件，首先要创建一个实例。为此，我们也需要TestBed。这个类有一个工具函数，叫做createComponent，用来创建一个组件。这个方法返回一个ComponentFixture，一个我们组件的代表。注意要创建一个组件，次组件必须在测试模块中已知才可以，所以我们必须将其加入到declearations属性中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { TestBed } from '\@angular/core/testing';

import { PonyComponent } from './pony\_cmp';

describe('PonyComponent', () =\> {

it('should have an image', () =\> {

TestBed.configureTestingModule({

declarations: \[PonyComponent\]

> });
>
> const fixture = TestBed.createComponent(PonyComponent);
>
> // 给出一个带有初始化小马的组件实例
>
> const ponyComponent = fixture.componentInstance;
>
> ponyComponent.pony = {name: 'Rainbow Dash', color: 'BLUE'};
>
> // 我们触发变化检测
>
> fixture.detectChanges();
>
> // 根据小马颜色
>
> // 确定正确的图片资源属性
>
> const element = fixture.nativeElement;
>
> expect(element.querySelector('img').getAttribute('src')).toBe('/images/pony-blue.png');

});

});

这里，遵循"GIVEN/WHEN/THEN"模式来书写单元测试。你可以找到此主题很多资料，但是大致上就是：

-   GIVEN阶段，设置测试上下文。我们创建了组件实例并且提供了一个小马。模拟了一个真实应用中来自于父组件的输入。

-   WHEN阶段，我们使用detectChange()手动触发变化检测。在一个测试中，变化检测是我们自己的事情：不像在应用中是自动化的。

-   THEN阶段，包含了预期。我们可以获取到原声的元素，像在浏览器中一样查询DOM（比如使用querySelector()）。这里我们测试图片资源的准确性。

我们也测试组件是否真正提交了一个事件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

it('should emit an event on click', () =\> {

TestBed.configureTestingModule({

declarations: \[PonyComponent\]

});

const fixture = TestBed.createComponent(PonyComponent);

// given一个小马

const ponyComponent = fixture.componentInstance;

ponyComponent.pony = {name: 'Raibow Dash', color: 'BLUE'};

// 一个假的事件提交器

spyOn(ponyComponent.ponyClicked, 'emit');

// when我们点击pony

const element = fixture.nativeElement;

const image = element.querySelector('img');

image.dispatchEvent(new Event('click'));

// 触发变化检测

fixture.detectChanges();

// then，事件提交器应该触发一个事件

expect(ponyComponent.ponyClicked.emit).toHaveBeenCalled();

});

让我们看一下另一个组件：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-race',

template: \`

\<div\>

\<h1\>{{ race.name }}\</h1\>

\<ns-pony \*ngFor="let currentPony of race.ponies" \[pony\]="currentPony"\>\</ns-pony\>

> \</div\>

\`

})

export class RaceComponent {

\@Input() race: any;

}

它的测试：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('RaceComponent', () =\> {

let fixture = ComponentFixture\<RaceComponent\>;

beforeEach(() =\> {

TestBed.configureTestingModule({

declarations: \[RaceComponent, PonyComponent\]

> });
>
> fixture = TestBed.createComponent(RaceComponent);

});

it('should have a name and a list of ponies', () =\> {

// given 给出一个组件实例，并给其一个初始化的比赛实例

const raceComponent = fixture.componentInstance;

raceComponent.race = {name: 'London', ponies: \[{name: 'Rainbow Dash', color: 'BLUE'}\]};

// when 触发变化检测

fixture.detectChanges();

// then 我们应该有一个静态名称的婊气

const element = fixture.nativeElement;

expect(element.querySelector('h1').textContent).toBe('London');

// 有一个列表的小马

const ponies = fixture.debugElement.queryAll(By.directive(PonyComponent));

expect(ponies.length).toBe(1);

// 检查小马是否被正确初始化

const raibowDash = ponies\[0\].componentInstance.pony;

expect(rainbowDash.name).toBe('Raibow Dash');

});

});

这里我们查询了所有PonyComponent类型的指令，并且测试了第一个小马是否被正确初始化。

你可以通过使用children获取你的组件中的组件，或者使用query()和queryAll()查询它们。这些方法接受一个预期作为参数，可以是By.css或者By.directive。这就是我们对于显示的ponies所做的，因为它们是PonyComponent的实例。记住这和使用querySelector()的DOM查询不同：它只会找到Angular管理的元素，并返回一个ComponentFixture，而不是DOM元素（所以你才能访问到结果的componentInstance）。

## 用假模版，providers... 测试

测试一个组件的时候，有些时候我们想要创建一个使用它的父组件。并且，如果有多个应用场景，我们需要创建多个父组件来尝试不同的输入。

幸运的是，测试的时候，我们可以通过覆盖它的模版来修改任何组件，在不同的测试中重用它。

为此，TestBed提供了一个overrideComponent()方法，在createComponent()之前调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('RaceComponent', () =\> {

let fixture: ComponentFixture\<RaceComponent\>;

begoreEach(() = {

TestBed.configureTestingModule({

declarations: \[RaceComponent, PonyComponent\]

> });
>
> TestBed.overrideComponent(RaceComponent, {set: {template: '\<h2\>{{ race.name }}\</h2\>'}});
>
> fixture = TestBed.createComponent(RaceComponent);

});

it('should have a name', () =\> {

// given 一个组件实例，为其提供一个舒适化的比赛

const raceComponent = fixture.componentInstance;

raceComponent.race = {name: 'London'};

// when 触发变化检测

fixture.detectChanges();

// then 应该有个名字

const element = fixture.nativeElement;

expect(element.querySelector('h2').textContent).toBe('London');

});

});

正如你看到的，这个方法接受两个参数：

-   你想要覆盖的组件

-   你想要设置、添加或者删除（这里我们设置模版）的元数据。

这意味你可以修改你正在测试的组件的模版，或者它的子项（把一个具有巨大模版的组件替换成一个简单的）。

template并不是唯一的可用的元数据，你也可以使用

-   providers，替换一个组件的依赖

-   styles，替换一个组件中使用的样式

-   你可以在\@Component装饰器中设置的一起属性

由于替换模版是最常见的情况，Angular 4引入了一个overrideTempalte()方法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('RaceComponent', () =\> {

let fixture: ComponentFixture\<RaceComponent\>;

beforeEach(() =\> {

TestBed.configureTestingModule({

declarations: \[RaceComponent, PonyComponent\]

> });
>
> TestBed.overrideTemplate(RaceComponent, '\<h2\>{{race.name}}\</h2\>');
>
> fixture = TestBed.createComponent(RaceComponent);

});

it('should have a name', () =\> {

// given 一个组件实例，并为其提供一个初始化的比赛

const raceComponent = fixture.componentInstance;

raceComponent.race = {name: 'London'};

// when 触发变化检测

fixture.detectChanges();

// then 应该有一个名字

const element = fixture.nativeElement;

expect(element.querySelector('h2').textContent).toBe('London');

});

});

现在你就可以测试你的应用了！

## 端到端测试（e2e）

端到端测试是另一种类型的测试。一个端到端测试需要在浏览器中加载你的应用，并且模拟一个真实的用户预期交互（点击按钮，填充表单等等）。它可以测试应用整体，但是：

-   慢（每个测试几秒钟）

-   很难测试边界情况

你可能会想，你不需要在单元测试和e2e测试之间选择：你会联合这两者以获取更好的测试覆盖率和应用按照预期运行的担保。

E2E测试依赖于一个叫做Protractor的工具。他是我们在AngularJS 1.x中用到的工具。好消息是，它在AngularJS 1.x和Angular中都能工作！

你会使用Jasmine写出你的单元测试套件，会使用Protractor API与应用交互。

一个简单的测试，是这个样子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

describe('Home', () =\> {

it('should display title, tagline and logo', () =\> {

browser.get('/');

expect(element.all(by.css('img')).count()).toEqual(1);

expect(\$('h1').getText()).toContain('PonyRacer');

expect(\#('small').getText()).toBe('Always a pleasure to bet on ponies');

});

});

Protractor给我一个浏览器对象，它提供了一些工具方法，像是get()用来打开一个页面。然后可以用element.all()选取一个预期的元素。预期一般依赖于by和它各种各样的方法（by.css()做CSS查询，by.id()通过id获取一个元素等等）。element.all()会返回一个promise，其有一个特殊的count()方法，就是上面用到的。

\$('h1')是一个简写，它等价于element(by.css('h1'))。它会返回匹配到的第一个元素。你可以使用\$()返回的promise的几个方法，像是getText()和getAttribute()来获取信息，或者类似于click()和sendKeys()的方法来做出一些动作。

这些测试可能会很长，需要很多时间调试（比单元测试多多了），但是它们很有用。你可以做所有的事情，像是测试几个浏览器，每次测试失败做视频截图等。

通过单元测试和e2e测试，你就掌握了构建健壮和可维护应用的钥匙。

# 通过HTTP发送和接收数据

没有什么惊讶的，但是很多任务都包含从后端获取数据，并将数据发送给我们的应用，然然后将数据再发回去。

通常这都是在HTTP上完成的，尽管今天有很多其它选择，比如WebSockets。Angular提供了一个http模块，但是并不强制你使用它。如果你想，你可以使用你喜欢的HTTP库来发送异步请求。

一个后来者就是fetch API，最近以polyfill的形式可用了，后续会成为浏览器标准。你可以使用fetch或者其它库完美地构建你的应用。事实上，我在Angular之前的HTTP部分中就是这样做的。它非常棒，不需要特别的调用来让框架知道我们接收到数据了，需要运行变化检测了（AngularJS 1.x中，如果使用外部的库，需要调用\$scope.apply()，Angular却不用，这归功于Angular的魔术和zones！）。

但是如果你想要使用框架，你就会使用一个叫做HttpClientModule的模块，这是由核心团队提供的。这是一个独立的模块，所以，真的，按你想要的去做。注意它从Fetch API提案借鉴了足够的东西。

如果你想要使用它，你需要使用\@angular/common/http包中的类。

为什么倾向于使用这个模块，而不是fetch呢？答案很简单：测试。正如将要看到的，Http模块允许你伪装后端服务器并且返回假的响应。这是非常有用的。

深入这个API之前的最后一个事情：Http模块重度使用了响应式编程模式。如果你跳过了响应式编程一章，现在是回去读一下的好时机。

## 获取数据

Http模块提供了一个叫做HttpClient的服务，你可以将其注入到任何构造器中。由于这个服务来自于另一个模块，你需要手动使其对你的组件或者服务可用。为此，需要将HttpClientModule导入到根模块中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { HttpClientModule } from '\@angular/common/http';

\@NgModule({

imports: \[BrowserModule, HttpClientModule\],

declarations: \[AppComponent\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

一旦完成，就可以在需要的时候注入HttpClient服务了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-races',

template: \`\<h1\>Races\</h1\>\`

})

export class RacesComponent {

constructor(private http: HttpClient) {

}

}

默认情况下，HttpClient会使用XMLHttpRequest进行AJAX请求。

它提供了几个方法，与常见的HTTP动词匹配：

-   get

-   post

-   put

-   delete

-   patch

-   head

-   jsonp

如果你在AngularJS 1.x中使用过\$http服务，你可能记得它重度依赖promises。在Angular中，所有这些方法都返回了Observable对象。

HttpClient使用Observable由几个优点，像是取消请求的能力，重试的能力，能够轻松地将其组合等等。

让我们PonyRacer中注册的比赛。我们会假设一个后端服务器已经正在运行，提供了一个RESTful API。要获取比赛，我们向类似于'http://backend.url/api/races'的URL发送一个GET请求。

通常，HTTP调用的基础URL会被存储在一个变量或者服务中，这样就可以随着环境的变化方便配置。或者，如果REST API由Angular应用同样的服务器提供，你就可以简单地使用相对URL： '/api/races'。

使用HttpClient服务，这样的请求是指关的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

http.get(\`\${baseUrl}/api/races\`)

这返回一个Observable，你可以订阅它以获取响应。

响应体是最有意思的部分，它是直接由Observable提交的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

http.get(\`\${baseUrl}/api/races\`)

.subscribe((response: Array\<RaceModel\>) =\> {

console.log(response);

// 记录比赛数组

})

当然，你也可以访问完整的HTTP响应。返回的对象是一个HttpResponse对象，有一些像是status、code、header等的字段。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

http.get(\`\${baseUrl}/api/races\`, {observe: 'response'})

.subscribe((response: HttpResponse\<Array\<RaceModel\>\>) =\> {

console.log(response.status); // 记录 200

console.log(response.headers.keys()); 记录 \[\]

});

如果返回的响应状态不是2xx或者3xx，observable就会抛出一个错误，错误的类型就是HttpErrorResponse。

发送数据也相当简单。调用post()方法就行，传给它URL和对象：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 当前需要将发送的对象stringify

http.post(\`\${baseUrl}/api/races\`, newRace);

我不会写出其它方法了，相信你已经知道怎么做了。

## 转换数据

这种工作通常是在一个独立的服务中完成的。我倾向于创建一个服务，像是RaceService，在这里做完所有的工作。然后，我的组件仅仅需要订阅我的服务方法即可，并不需要关心底层的实现。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

raceService.list()

.subscribe(races =\> {

// 将比赛的数组存储在组件中

this.races = races;

});

你也可以利用RxJS来重试失败的请求，比如：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

raceService.list().pipe(

// 如果请求失败，重试3次

retry(3)

).subscribe(races =\> {

// 将比赛数组存储在组件中

this.races = races;

});

## 高级选项

当然，你可以更细微地调节你的请求。每个方法都会接受一个可选的options对象，在这里你就可以配置你的请求。几个选项是非常有用的，你可以在此请求中覆盖任何东西。

params代表了被加在URL中的搜索参数（也被称为查询字符串）。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const params = {

'sort': 'ascending',

'page': 1

};

http.get(\`\${baseUrl}/api/races\`, {params})

// 将调用URL \${baseUrl}/api/races?sort=ascending&page=1

.subscribe(response =\> {

// 返回排序后的比赛

this.races = response;

})

headers选项用于为请求增加自定义的头。它对于像是JSON Web令牌这种认证技术非常有用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const headers = {'Authorization': \`Bearer \${token}\`};

http.get(\`\${baseUrl}/api/races\`, {headers})

.subscribe(response =\> {

// 返回对认证用户可见的比赛

this.races = response;

});

## Jsonp

为了能让你绕过浏览器的同源策略，一些web服务不使用CORS，而是使用JSONP（带有Padding的JSON）。

服务器并不会直接返回JSON数据，而是将它们封装在函数中，将此函数作为回调函数传递。应答以一个脚本的形式返回，而脚本并不受同源策略限制。一旦加载完毕，你就可以在应答中访问JSON值。

除了经典的HTTP方法，HttpClient提供了一个jsonp方法。你需要做的就是指定好你要访问的URL，还有你想要的回调的名字即可。

下面的例子中，我们使用JSONP从我们的Github组织账户中获取所有的公开仓库。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

http.jsonp('http://api.github.com/orgs/Ninja-Squad/repos', 'callback').pipe(

// 提取数据

map((res: {data: Array\<any\>}) =\> res.data)

).subscribe(response =\> {

// 将返回Ninja-Squad的公开仓库

this.repos = response;

});

## 拦截器

Http模块被重写的原因之一是引入拦截器。当你想要在应用中拦截请求或者响应时，拦截器就有用处了。

比如，你想要拦截所有的请求，为其中的一些请求添加特定的头，你现在可以写像下面这样的拦截器：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable()

export class GithubAPIInterceptor implements HttpInterceptor {

intercept(req: HttpRequest\<any\>, next: HttpHandler): Observable\<HttpEvent\<any\>\> {

// 如果是一个Github API请求

if (req.url.includes('api.github.com')) {

// 我们需要添加一个OAUTH令牌头来访问Github API

const clone = req.clone({setHeaders: {'Authorization': \`token \${OAUTH\_TOKEN}\`}});

return next.handle(clone);

> }
>
> // 如果不是一个Github API请求，直接将其交由下一个处理器
>
> return next.handle(req);

}

}

注意需要通过克隆来更新它（请求是不可变的）。

让后将你的拦截器通过依赖注入添加到HTTP\_INTERCEPTORS数组中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

providers: \[

{provide: HTTP\_INTERCEPTORS, useClass: GithubAPIInterceptor, multi: true}

\]

现在每个请求都会经过拦截器了，如果需要就会添加对应的头（这里就是请求Github API的请求）。

你也可以拦截响应，这样可以以通用的方式来处理错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable()

export class ErrorHandlerInterceptor implements HttpInterceptor {

constructor(private router: Router, private errorHandler: ErrorHandler) {}

intercept(req: HttpRequest\<any\>, next: HttpHandler): Observable\<HttpEvent\<any\>\> {

return next.handle(req).pipe(

// 我们捕获错误

catchError((errorResponse: HttpErrorResponse) =\> {

// 如果状态是未授权

if (errorResponse.status === 401) {

// 重定向到登陆

this.router.navigateByUrl('/login');

> } else {
>
> // 通知用户
>
> this.errorHandler.handle(errorResponse);
>
> }
>
> return throwError(errorResponse);
>
> })
>
> );

}

}

## 测试

我们现在有了一个HTTP终端来获取比赛。我们怎样测试呢？

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable({

providedIn: 'root'

})

export class RaceService {

constructor(private http: HttpClient) {}

list(): Observable\<Array\<RaceModel\>\> {

return this.http.get\<Array\<RaceModel\>\>('/api/races');

}

}

在一个单元测试中，你并会真想要请求一个HTTP服务器：那不是我们要测试的东西。我们想要一个假的HTTP请求来返回假的数据。为此，我们可以通过导入HttpClientTestingModule将HttpClient服务的依赖替换为假的实现。我们然后就可以使用一个框架提供的叫做HttpTestingController的类来伪造这个HTTP响应。

你也可以对底层的HTTP请求添加几个断言：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { async, TestBed } from '\@angular/core/testing';

import { HttpClientTestingModule, HttpTestingController } from '\@angular/common/http/testing';

describe('RaceService', () =\> {

let raceService: RaceService;

let http: HttpTestingController;

beforeEach(() =\> TestBed.configureTestingModule({

imports: \[HttpClientTestingModule\]

}));

beforeEach(() =\> {

raceService = TestBed.get(RaceService);

http = TestBed.get(HttpTestingController);

});

it('should return an Observable of 2 races', async(() =\> {

// 假响应

const hardcodedRaces = \[{name: 'London'}, {name: 'Lyon'}\];

// 调用服务

let actualRaces = \[\];

raceService.list().subscribe(races =\> actualRaces = races);

// 确保底层HTTP请求准确

http.expectOne('/api/races')

// 当收到一个请求的时候返回假的响应

.flush(hardcodedRaces);

// 确保返回的数组按照预期反序列化

expect(actualRaces.length).toBe(2);

}));

});

一切就好了。

## 路由

将一个URL映射到一个应用的某个状态是经常的事情。这是有道理的：你想要让你的用户收藏一个页面然后回来，这样就能提供更好的用户体验了。

这部分工作是由路由来完成的，每个框架都有自己的路由（或者几种）。

Angular中的路由有一个简单的木匾：用有意义的URL反应应用的状态，对于每个URL都知道应该初始化哪个组件并插入到页面中。这个过程不会刷新页面或者向后端发出请求：这是单页应用的整体观点。

你可能已经知道在AngualrJS 1.x中已经有一个路由了，这是由核心团队维护的，其位于一个叫做ngRoute的模块中。你也可能知道它是非常简单的：对于简单的应用没有问题，但是它只允许每个URL有单个视图，不允许有嵌套的情况。对于较大的应用就显得不够用了，在大应用中视图中包含视图是常有的事情。有一个非常受欢迎的社区模块，叫做ui-router，很多人都在使用，它确实也非常出色。

Angular背后的团队决定弥合鸿沟，创建了一个叫做RouterModule了模块。这个模块会满足我们所有的需要！

一些新的特性也很有趣。让我们开始吧！

## 开启路由

开始使用路由吧。它是一个可选的模块，也就是说它并未包含在核心框架中。

正如我们看到的其它模块，如果想要使用它，就要将其包含在根模块中。为此我们需要一个定义URL和组件之间映射的配置。我们可以使用一个独立的文件来做，命名一般是app.routes.ts，其包含了一个代表配置的数组：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Routes } from '\@angular/router';

import { HomeComponent } from './home/home.component';

import { RacesComponent } from './races/races.component';

export const ROUTES: Routes = \[

{path: '', component: HomeComponent},

{path: 'races', component: RacesComponent}

\];

然后我们需要在我们根模块中导入路由模块，并用正确的配置初始化它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { RouterModule } from '\@angular/router';

import { ROUTES } from './app.routes';

import { HomeComponent } from './home/home.component';

import { RacesComponent } from './races/races.component';

\@NgModule({

imports: \[BrowserModule, RouterModule.forRoot(ROUTES)\],

declarations: \[AppComponent, HomeComponent, RacesComponent\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

正如你所看到的，Routes是一个对象的数组，每个就是一个路由。一个路由配置通常是一对属性：

-   path：触发导航的URL

-   component：被初始化和插入的组件

你可能想知道组件被插入到页面的什么地方，是个好问题。对于一个插入到我们应用的组件来说，像是上面例子中的RacesComponent，我们必须在主组件的模版中使用一个特殊标签：\<router-outlet\>。

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image9.png){width="6.5in" height="2.9791666666666665in"}

这当然是一个Angular的指令，它的唯一的工作就是当前路由组件模版的占位符。我们的应用模版看上去是这个样子的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<header\>

\<nav\>...\</nav\>

\</header\>

\<main\>

\<router-outlet\>\</router-outlet\>

\<!\-- 组件的模版将会被插入到这里 \--\>

\</main\>

\<footer\>make with &lt; 3 by Ninja Squad\</footer\>

当我们导航的时候，所有的东西都会留下（header、main和footer），与当前路由相匹配的组件会被插入到RouterOutlet指令之后。

## 导航

我们怎样在不同的组件之间导航呢？你可以手动输入URL并且重新加载页面，但是这不是很方便。我们也不想使用经典的链接，\<a href=""\>\</a\>。事实上，点击这样的链接会让浏览器加载哪个URL的页面，并且重新启动整个Angular应用。但是Angular的目标是避免这样的页面重加载：我们想要创建一个单页面应用。当然，是有内建的解决方案的。

在一个模版中，你可以使用指令RouterLink插入一个链接到你想要的路径。因为我们的根模块已经导入了RouterModule，这样在根模块中RouterModule所有的导出指令都是可用的。RouterLink指令可以接受一个常量或者一个字符串数组。比如，在我们的RacesComponent模版中，如果我们想要导航到HomeComponent，我们可以想象应该是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a href="", routerLink="/"\>Home\</a\>

\<!\-- 等价于 \--\>

\<a href="" \[routerLink\]="\['/'\]"\>\</a\>

运行时，链接href会被路由器计算出来并指向/。

RouterLink指令可以和RouterLinkActive指令一起使用，后者在链接指向当前路由的时候会自动设置CSS类。这样当菜单中的某项指向当前页的时候，就可以对其添加样式了。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a href="" routerLink="/" routerLinkActive="selected-menu"\>Home\</a\>

我们甚至可以在这个指令上获取一个引用，来获知路由是否是激活的，并在模版中使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a href="" routerLink="" routerLinkActive \#route="routerLinkActive"\>Home {{ route.isActive ? '(here)' : '' }}\</a\>

通过使用Router服务和它的navigate()方法，也可以直接从代码中导航。当你想在用户某个动作之后重定向的时候非常方便：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class RacesComponent {

constructor(private router: Router) {}

saveAndMoveBackToHome() {

// ...保存逻辑...

this.router.navigate(\[''\]);

}

}

这个方法接受参数的数组，想要导航的路径是第一个元素。

也可以在URL中包含参数，这对于定义动态URL来说非常有用。比如，我们想要展示一匹小马的详细信息，我们需要这个页面的URL看上去有意义，像是ponies/id-of-the-pony/name-of-the-pony。

为此，我们要在配置文件中定义一个带有一个（或多个）动态参数的路由。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export const routes: Routes = \[

{path: '', component: HomeComponent},

{path: 'races', component: RacesComponent},

{path: 'races/:raceId/ponies/:ponyId', component: PonyComponent}

\];

我们可以用routerLink定义动态链接：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a href="" \[routerLink\]="\['races', race.id, 'ponies', pony.id\]"\>See pony\</a\>

当然，目标组件需要能够访问这些参数以显示给定id的小马。要获取参数的值，路由器提供了一个服务，可以注入到组件中，这个服务就是ActivatedRoute。这个对象可以在ngOnInit中使用，并且有一个非常有用的字段：snapshot。这个字段的paramMap中拥有这个URL的中所有的参数！

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class PonyComponent implements OnInit {

pony: any;

constructor(private ponyService: PonyService, private route: ActivatedRoute) {

}

ngOnInit() {

const id = this.route.snapshot.paramMap.get('ponyId');

this.ponyService.get(id).subscribe(pony =\> this.pony = pony);

}

}

正如你看到的，这个钩子也是做初始化工作的好地方。

你可能注意到了，我们正在使用snapshot。难道有一个非snapshot版本？是的。而且它提供了一种订阅参数变化的方式，这是通过一个observable实现的。这个observable叫做paramMap。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class PonyReusableComponent implements OnInit {

pony: any;

constructor(private ponyService: PonyService, private route: ActivatedRoute) {

}

ngOnInit() {

this.route.paramMap.subscribe((params: ParamMap) =\> {

const id = params.get('ponyId');

this.ponyService.get(id).subscribe(pony =\> this.pony = pony);

> });

}

}

这里我们订阅了ActivatedRoute提供的observable。现在每次的URL变化，比如从/ponies/1到/ponies/2，paramMap observable就会提交一个事件，然后我们就能够获取到正确的小马展示在屏幕上了。

注意我们可以不用在参数更新订阅内部去订阅PonyService的结果，我们可以通过使用switchMap操作符更加优雅地实现：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class PonySwitchMapComponent implements OnInit {

pony: any;

constructor(private ponyService: PonyService, private route: ActivatedRoute) {

}

ngOnInit() {

this.toute.paramMap.pipe(

map((params: ParamMap) =\> params.get('ponyId')),

switchMap(id =\> this.ponyService.get(id))

> ).subscribe(pony =\> this.pony = pony);

}

}

你刚刚学到的应该能够覆盖基础的路由使用。但是路由器比较复杂并提供了许多其它的特性。覆盖全部细节是一个太大的任务，学习全部的话可能会有挫败感。

这部分将会尽可能简明的展示多数的附加特性，解释它们在什么时候有用。但是也不是说要覆盖每个细节。如果你确实需要路由器特性的完全覆盖，这里有一整本书，是由Angular Router的主要贡献者，Victor Savkin写的。

## 重定向

一种常见的应用场景就是在应用中让一个URL简单地重定向到另一个URL。比如你想要将你的新闻应用重定向到/breaking新闻类目下，或者在重构之后将一个旧的URL重定向到一个新的，就需要用到重定向了。可这样用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: '', pathMatch: 'full', redirectTo: '/breaking'},

## 匹配策略

上面的例子解释了一个重定向，我应用了一个匹配路由的策略：'full'。默认的策略是'prefix'，就是当URL以路由路径为前缀的时候就能够匹配上。如果我们这里使用默认的策略，所有的URL都会重定向到/breaking，因为所有的URL都是以一个空字符串开始的。

匹配策略在于找到匹配完整URL的第一个路由。比如，如果你定义了如下的路由

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: 'races/:id', component: RaceComponent},

{path: 'races/new', component: RaceCreationComponent}

并且URL是races/new，路由器将会激活的组件事实上是RaceComponent。确实没错，races/:id匹配races/new并且是第一个出现的路由。为了解决这个问题，可以修改路由的顺序：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: 'races/new', component: RaceCreationComponent},

{path: 'races/:id', component: RaceComponent}

## 层级化和空路径路由

路由可以有子项。原因在于：

-   一次性为多个路由应用守卫（看后面）

-   一次性为多个路由应用解析器（看后面）

-   在不同的几个路由上共享一个通用的模版

正如我们前面看到的，当路由器激活了路由，路由的组件就会被插入到页面上，其插入位置由指令router-outlet指定。

这个机制也可以在嵌套组件中使用。比如你有一个展示小马资料的复杂页面。这个页面将会在顶部展示它的名字和头像，底部有几个tabs：一个用来展示其出生证明，一个用来展示它的比赛记录，另一个用来展示关于这匹小马的报道记录。你想为每个tab都分配一个URL，这样就能直接到达它们了。但是你并不想重新加载这匹小马，也不想为这三个tab组件每次都重复其名字和头像。

解决方案就是在PonyComponent模版中使用一个嵌套的router-outlet，并且定义个父小马路由，这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: 'ponies/:ponyId',

component: PonyComponent,

children: \[

{path: 'birth-certificate', component: BirthCertificateComponent},

{path: 'track-record', component: TrackRecordComponent},

{path: 'reviews', component: ReviewsComponent}

\]

}

当打开URL ponies/42/reviews时，路由器会将PonyComponent插入到根组件中主router-outlet指定的位置。PonyComponent的模版，除了小马的名字和头像外，还包含了一个二级router-outlet。在这里插入子ReviewsComponent。

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image10.png){width="6.5in" height="2.99375in"}

当打开ponies/42的时候，小马组件会展示出来，但是三个子组件不会展示。你可能想要默认展示出生证明。这可以通过一个空路径路由达到，重定向到birth-certificate路由：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: 'ponies/:ponyId',

component: PonyComponent,

children: \[

{path: '', pathMatch: 'full', redirectTo: 'birth-certificate'},

{path: 'birth-certificate', component: BirthCertificateComponent},

{path: 'track-record', component: TrackRecordComponent},

{path: 'reviews', component: ReviewsComponent}

\]

}

注意，在上面的例子中，重定向是相对于ponies/:ponyId路由的，因为它并未以一个/开头。

不使用重定向，你可能想要在URL ponies/42上展示出生证明。这个也可以通过一个子空路径路由达成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: 'ponies/:ponyId',

component: PonyComponent,

children: \[

{path: '', component: BirthCertificateComponent},

{path: 'track-record', component: TrackRecordComponent},

{path: 'reviews', component: ReviewsComponent}

\]

}

## 守卫

基于相关的权限设置，应用的某些路由是不可以被所有用户访问的。当然，如果用户不能访问它们你可以将其隐藏或者禁用。也必须确保后端不允许未授权的用户去修改资源。但这些还是不能阻止用户去访问那些它们不被允许的路由，他们仅需要在浏览器地址栏中输入URL就可以了。

这就是守卫要起作用的地方了。有4种守卫：

-   CanActivate：当在一个路由上设置的时候，守卫可以禁止此路由的激活。注意这个守卫有也一个副作用，像是其它地方的导航。这可用来显示一个错误页面，或者用户尝试访问一个需要授权的页面，但是其并未认证时，将其导航到登陆界面；

-   CanActivateChild：当在一个路由上设置的时候，守卫能够禁止那个路由的子路由的激活。这可以方便地根据URL，一次性地禁止许多子路由的访问；

-   CanLoad：这个守卫被用于一个带有loadChildren属性的路由上。这个属性允许懒加载一整个特征集，包含子路由（我们将在稍后谈论懒加载）。通过阻止加载特征集，它比CanActivate守卫更进一步。

-   CanDeactivate：这个守卫不同于其它三个。它被用来阻止从当前激活路由的外部导航。这对于表单确认的清醒非常有用。

这里是如何在一个路由上添加一个CanActivate守卫。另外三个也以类似的方式添加：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: 'races', component: RacesComponent, canActivate: \[LoggedInGuard\]}

上面的例子中，LoggedInGuard是一个Angular服务。和其他服务一样，它也必须被提供，通常是将其加在Angular模块的providers中。

这个服务必须实现CanActivate接口。它的作用在于决定路由是否应该被激活（通过检查用户是否已经登陆），并且返回一个boolean，一个Promise\<boolean\>或者一个Observable\<boolean\>。

如果返回的值是true，或者返回的promise最终被确定为true，或者返回的observable提交了一个true，那么路由器将会导航到这个路由。

这里是LoggedInGuard的样子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable({

providedIn: 'root'

})

export class LoggedInGuard implements CanActivate {

constructor(private router: Router, private userService: UserService) {}

canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\<boolean\>\|Promise\<boolean\>\|Boolean {

const loggedIn = this.userService.isLoggedIn();

if(!loggedIn) {

this.router.navigate(\['/login'\]);

> }
>
> return loggedIn;

}

}

层级化路由和空路径路由组合起来可以使一次性在多个路由上应用一个守卫变得容易。比如，如果你想让比赛和小马路由仅仅允许登陆的用户访问，不要这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: 'ponies/:ponyId', component: PonyComponent, canActivate: \[LoggedInGuard\]},

{path: 'races', component: RacesComponent, canActivate: \[LoggedInGuard\]}

你可以引入一个空路径，没有任何组件的路由作为父路由。这个路由不会消费任何URL的部分，也不会激活任何的组件，但是当其导航到它任意的子组件的时候，它的守卫会被调用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: '',

canActivate: \[LoggedInGuard\],

children: \[

{path: 'ponies/:ponyId', component: PonyComponent},

{path: 'races', component: RacesComponent}

\]

}

## 解析器

在多页面应用的旧时代，页面在服务器端生成，当点击一个链接的时候，发生了：一个请求被发向服务器，浏览器通常会在tab中显示一个纺纱图标，当响应最终从服务器返回时，地址栏中的URL变化，新页面的内容被展示出来。

在一个Angular的单页应用中，可不是这样的。用户点击一个链接显示一个小马比赛（例如）。路由器创建了一个RaceComponent的实例，然后组件发送一个AJAX请求来加载比赛。路由器立即将组件模版插入在router-outlet的位置并改变地址栏中的地址。这样，一点击，用户就能看到新的页面，但是没有任何比赛。当AJAX请求返回后，比赛被存储在组件中，DOM随即更新。

这有优点也有缺点：

-   导航到新页面感觉上更快了；

-   如果加载比赛时间较长，用户可能会困惑，因为页面看上去时空的，看上去就是一个bug

-   模版必须小心编码，使其在比赛为null或者undefined的时候也能正常工作

-   模版可以提供一个即时的反馈，比如一条信息或者纺纱动画来提醒用户比赛正在加载中

-   如果加载比赛失败了（比如，连接丢失了），即使不能展示任何比赛，但是导航操作已经做出了，URL也变化了，而不是停留在先前的页面上。

解析器使应用行为看上去像一个传统的多页面应用。不让比赛组件加载比赛，你在此路由上应用一个解析器，解析器代表此组件来加载比赛。

类似于一个守卫，解析器可以同步地返回数据（通过返回一个race），或者异步地（通过返回一个race的promise或者observable）。一旦promise被确定，或者一旦一个observable提交了一个race并完成，路由器只导航到这个路由。这里就是一个race的解析器的样子：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Injectable({

providedIn: 'root'

})

export class RaceResolver implements Resolve\<RaceModel\> {

constructor(private raceService: RaceService) {}

resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\<RaceModel\>\|Promise\<RaceModel\>\|RaceModel {

return this.raceService.get(+route.paramMap.get('raceId'));

}

}

正如你看到的，它是一个简单的服务，它使用了路由器的激活路由快找来获取raceId参数的值，并且返回了一个Observable\<RaceModel\>。

这里时这个解析器如何应用到路由：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: 'races/:raceId',

component: RaceComponent,

resolve: {

race: RaceResolver

}

}

正如你看到的，RaceResolver和一个名字为race的键联系起来。路由器将使用这个键将数据存储在激活的路由快找的data属性中。所以比赛组件就可以通过下面的方式获取比赛了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class RaceComponent implements OnInit {

race: RaceModel;

constructor(private route: ActivatedRoute) {}

ngOnInit() {

this.race = this.route.snapshot.data\['race'\];

}

}

注意，如果你容一个路由导航到相同的路由，但是使用不同的参数（比如，在页面上有下一场比赛的链接），应用于此路由的守卫和解析器都会被重新调用。这种情况下，组件还是会被重用的，这样就应该订阅一个observable来获取比赛（或者仅仅就存储这个observable，在模版中使用async管线）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export class RaceComponent implements OnInit {

race: RaceModel;

constructor(private route: ActivatedRoute) {}

ngOnInit() {

this.route.data.subscribe(data =\> this.race = data\['race'\]);

}

}

解析器和从激活的组件加载数据有几点优势：

-   导航过程更加传统

-   不同的路由可以共享和重用

-   它使得组件的代码和它的模版更加简单：不用加载数据了，也不用关心临时的未定以或者空值了，也不需要应用某些复杂的RxJS操作符从参数中获取数据了；

-   如果导航失败，当前页面还时保存的，用户可以再次点击链接重试。

唯一的确定就是，当你知道数据加载很慢（因为它需要潜在的计算或者服务器外部服务调用），然后应用可能感觉有点儿不响应：你点击一个链接，在数据加载完毕之前什么也不会发生。这就是从激活的组件加载数据，并且展示一个信息或者动画可能更加对用户友好。另一个解决方法可能就要依靠路由器事件来展示加载信息了。

## 路由器事件

当导航到一个路由的时候，路由器提交几个事件。你可以通过注入Router服务并订阅它的events observable来获取这些通知。提交的事件有几种类型，你可以使用event instanceof NavigationStart（举例）来过滤。以下是几种路由器事件：

-   NavigationStart：当一个导航被请求的时候提交（比如当点击一个链接的时候）。可以被用来展示一个转盘；

-   NavigationEnd：当导航成功结束后提交。可以被用来停止转盘。另一种场景是发送数据给分析服务（像是Google分析），这可以帮助分析浏览习惯和应用中的受欢迎页面；

-   NavigationError：当因为未知错误（比如解析器返回一个空或者错误的observable）导致导航失败时提交。可以被用来停止展示转盘，或者尝试发送一个错误给服务器；

-   NavigationCancel：当一个导航被取消时提交，比如一个守卫阻止了导航。如果一个在导航开始的时候被展示了出来，在这个事件提交后应该将其隐藏。

还有其它几种路由配置加载的事件（RouteConfigLoadStart、RouteConfigLoadEnd、RoutesRecognized），从4.3开始解析器也有了（ResolveStart、ResolveEnd），守卫也有了（GuardsCheckStart、GuardsChekEnd）。从5.0开始增加了更加细粒度的导航事件（ChildActivationStart、ChildActivationEnd）。

## 参数和数据

我们之前看到过路由可以有参数。比如，路由races/:raceId有一个叫做raceId的参数，这个参数的值，在导航到/races/42的时候就是'42'。但是这个路由可以有叫做矩阵参数的附加参数。

如果你导航到URL

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

/races/42;foo=bar;baz=wiz

然后params和激活路由的paramMap属性将包含两个额外的参数'foo'和'baz'，其值分别时'bar'和'wiz'。

这些矩阵参数是针对这个路由的。所以，比如这个URL是：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

/races/42;foot=bar;baz=wiz/ponies

然后于ponies关联的组件的激活路由中不会有foo也不会有bar。只有关联于races/42的组件才会有。

要导航到这样的URL，你可以使用下面的代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

router.navigate(\['/races', 42, {foo: 'bar', baz: 'wiz'}, 'ponies'\]);

或者一个等价的路由器链接：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a \[routerLink\]="\['/races', 42, {foo: 'bar', baz: 'wiz'}, 'ponies'\]"\>Link\</a\>

另一方面，查询参数，是各个部分共享的。在这个URL中像是这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

/races/42/ponies?foo=bar&baz=wiz

这些查询参数可以从任何路由中访问，通过使用queryParams或者queryParamMap属性。

要导航到这样的URL，可以使用如下的代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

router.navigate(\['/races', 42, 'ponies'\], {queryParams: {foo: 'bar', baz: 'wiz'}});

等价的路由器链接：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<a \[routerLink\]="\['/races', 42, 'ponies'\]" \[queryParams\]="{foo: 'bar', baz: 'wiz'}"\>Link\</a\>

最后，我们见到过，在路由被激活之前，解析器允许为激活路由的data属性添加属性。也可以直接在配置中给路由添加数据。在同一个组件在两种上下文中使用的时候非常有用。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{

path: 'races',

component: RacesComponent,

data: {

allowDeletion: false

}

}

## 懒加载

本部分将会总结Angular路由器。

当应用规模和特性不断增加，一次性加载整个应用就会是个问题：应用太大了，以至于要花费大量时间来加载和解析。而且，应用某些部分只是部分用户能够使用到的，或者很少使用到，积极地加载它们就是浪费时间和带宽。这里懒加载就有用了。

懒加载在于将应用划分成不同的Angular模块，不同的JavaScript集合。一个懒加载模块定义其自己的路由、组件和服务，打包到一个单独的JavaScript文件。主模块仅仅是定义了一个路由能够访问懒加载模块。正如名字所暗示的，Angular路由器等待用户导航到此路由，才会加载这个JavaScript模块，然后添加子路由、模块、组件和服务到应用中。

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image11.png){width="6.5in" height="2.8229166666666665in"}

要说明如何配置懒加载，我们将假定你想要在你的应用中定义一个管理部分，这部分应该是懒加载的。我们也假定你使用了Angular CLI来构建你的应用。

第一步是定义一个子Angular模块。admin.module.ts看上去是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@NgModule({

imports: \[

CommonModule

\],

declarations: \[\]

})

export class AdminModule {}

与根模块有一个重要的不同：这个子模块没有导入Browsermodule。而是导入了一个CommonModule。

第二步是定义一个管理组件，并在叫做admin.routes.ts中定义至少一个路由：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

export const ADMIN\_ROUTES: Routes = \[

{path: '', component: AdminComponent}

\];

这个路由配置必须在管理模块中被导入，但是再一次，和根模块相比，这儿有一个细微但是重要的区别：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@NgModule({

imports: \[

CommonModule,

RouterModule.forChild(ADMIN\_ROUTES)

\],

declarations: \[AdminComponent\]

})

export class AdminModule {}

这里没有使用RouterModule.forRoot()，我们必须使用RouterModule.forChild()，因为这是一个子模块。由于路由是一个有状态的单例服务，我们不能在这个子模块中第二次提供它。

AdminComponent在这个子管理模块中声明了，而没有在根模块中声明。在根模块中声明它会毁掉我们的目标：只是在需要的时候、惰性地加载。

最后一步就是在主app.routes.ts文件中添加一个路由，告诉路由器对于当路由到此路由的时候对于管理模块进行懒加载。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

{path: 'admin', loadChildren: './admin/admin.module\@AdminModule'}

正如你看到的，这是使用路由定义的loadChildren属性实现的。

当构建此应用的时候，Angular CLI解析路由配置，检测到管理子模块是懒加载的。

其它什么都不需要做，他会为管理模块生成单独的JavaScript集（叫做0.chunk.js），当路由器需要'./admin/admin.module'的时候生成必要的JavaScript来加载这个集。

# 表单

本章使用新的表单API（来自于\@angular/forms，它出现于rc.2）。如果你还在使用旧的，不推荐使用的表单，是时候更新了。本章会帮助你迁移！

## 表单，亲爱的表单

表单一直是Angular中的亮点。这也是在1.x中最被经常提到的特性之一，由于几乎每个应用都有表单，所以它赢得了大量开发者的心。

表单是非常难以写好的：你必须验证你用户的输入，展示错误，可以有必填字段，或者基于另一个字段，你想要响应某些字段变化等等。我们也必须测试这些表单，AngularJS 1.x中是不能用单元测试完成的。只能够用端到端测试，然而这是比较慢的。

在Angular中，也给予了表单同样的关注，框架给我们提供了两种书写表单的方式。事实上，它给我们提供了好几种方式！

你可以只在你的模版中使用指令来写表单：这就是"模版驱动"方式。从我们的经验来看，对于简单的没有很多验证的简单表单，它非常合适。

另一种方式就是"代码驱动"，你需要在你的组件中写出表单的描述，然后使用指令将这个表单绑定到你模版的inputs/textareas/selects中。这种方式更冗余，但是也更强大，特别是你想要添加自定义验证或者生成动态表单的情况下。

让我们一个例子走两次，每次使用不同的实现方式，看看区别。

我们将要写一个简单的表单，在我们的PonyRacer应用中注册用户。我们需要为这两种情况提供一个基础的组件，开始是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-register',

template: \`

\<h2\>Sign up\</h2\>

\<form\>\</form\>

\`

})

export class RegisterFormComponent {

}

没什么新鲜的：一个带有简单模版的组件，模版中有一个表单。下面的时间里，我们将要构建一个以用户名和密码注册一个用户的表单。

对于两种方式，Angular将创建一个我们表单的表示。

在"模版驱动"方式中，这个过程几乎是自动的：我们只需要在模版中添加合适的指令，框架会负责表单表现的创建。

在"代码驱动"方式中，我们手动创建这个表单表示，然后使用指令将表单表示绑定到输入。

背后，一个表单字段，像是input或者select，在Angular中是由一个FormControl表示的。它是表单的最小部分，它封装了字段的状态和值。

一个FormControl由几个属性：

-   valid：基于要求和应用的验证，判断这个字段是否是合法的

-   invalid：基于要求和应用的验证，判断中这个字段是否是非法的

-   errors：包含字段错误的对象

-   dirty：用户修改值之前，一直为false

-   pristine：dirty的反面

-   touched：用户进入它之前，一直为false

-   untouched：touched的反面

-   value：字段的值

-   valueChanges：这是一个Observable，每次字段变动都会提交

它也提供了一些像是hasError()的方法来检查其是否有某种从物。

所以你可以：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const password = new FormControl();

console.log(password.dirty); // 用户输入一个值之前，是false

console.log(password.value); // 用户输入一个值之前，是null

console.log(password.hasError('required')); // false

注意你可以给其构造器传递一个参数，这个参数就是其值。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const password = new FormControl('Cedric');

console.log(password.value); // 记录"Cedric"

这些控制都可以被组合在一个FormGroup中，以代表这个表单的一部分，有其独立的验证规则。表单自身就是一个组。

一个FormGroup和FormControl由相同的属性，但是有几点不同：

-   valid：如果所有的字段都是合法的，那这个组就是合法的

-   invalid：如果有一个字段是非法的，那么这个组就是非法的

-   errors：一个包含组错误的对象，如果是合法的就是null，每个错误是一个键，其值是一个数组，包含了所有被这个错误影响的字段

-   dirty：直到其中一个控制变脏之前都是false

-   pristine：dirty的反面

-   touched：知道其中一个控制被触控之前，都是false

-   untouched：touched的反面

-   value：group的值。更准确来说，它是一个带有键值对代表控制和它们值的对象

-   valueChanges：一个Observable，本组每次的变化都会有一个提交

它也提供了和FormControl一样的方法，像是hasError()。它也提供了一个get() 方法从组中获取一个控制。

你可以这样创建一个：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const form = new FormGroup({

username: new FOrmControl('Cedric'),

password: new FormControl()

});

console.log(form.dirty); // 直到用户输入一个值之前，都是false

console.log(form.value); // 记录 {usrename: "Cedric", password: null}

console.log(form.get('username')); // 记录这个控制

让我们以一个"模版驱动"表单开始！

## 模版驱动

使用这种方式，我们就要在我们的模版中使用一堆指令，让框架来构建必要的FormControl和FormGroup实例。比如，NgForm指令将form元素转化成强大的Angular版本------那就是布鲁斯韦恩和蝙蝠侠的差距。

我们需要的所有的指令都包含在FormsModule模块中，我们需要将其导入到我们的根模块中。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { NgModule } from '\@angular/core';

import { BrowserModule } from '\@angular/platform-browser';

import { FormsModule } from '\@angular/forms';

\@NgModule({

imports: \[BrowserModule, FormsModule\],

declarations: \[AppComponent\],

bootstrap: \[AppComponent\]

})

export class AppModule {

}

FormsModule包含了"模版驱动"方式的指令。我们稍后会看到在同一个包\@angular/forms中存在另一个模块，ReactiveFormsModule，这是"代码驱动"方式需要的。

让我们增加一个提交按钮：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-register',

template: \`

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()"\>

\<button type="submit"\>Register\</button\>

> \</form\>

\`

})

export class RegisterFormComponent {

register() {

// 处理提交

}

}

我增加了一个按钮，在form标签中为ngSubmit定义了一个事件处理句柄。ngSubmit事件是在submit触发的时候由NgForm指令提交的。它调用我们控制器的register()方法，后面我们会实现它。

最后：我们的模版增长很快，我们将其放在一个单独的文件中，使用templateUrl：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

register() {

// 处理提交

}

}

在"模版驱动"方式中，你几乎像是在AngularJS 1.x中写表单，多数情况是在模版中处理，而不是组件中。

最简单的情况下，你只需要向你的表单模版中添加ngModel指令即可，其它什么都不需要做。NgModel指令为你创建FormControl，表单会自动创建FormGroup。注意，你必须给输入一个名字，这会被框架用来创建FormGroup。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel\>

\</div\>

\<button type="sumbit"\>Register\</button\>

\</form\>

现在我们需要为提交做一些事情，获取用户名和密码的值。为此，我们可以定义一个本地变量，用Angular为此表单创建的NgForm对象为其赋值。还记得这些模版章节的内容吗？这里，我们将定义一个变量，userForm，来应用这个表单。我们之所以能这样做是因为form指令导出了NgForm指令实例，它和FormGroup有相同的方法。当我们学习怎样构建高级指令的时候，就会看到怎样导出。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<!\-- 我们使用了本地变量 \#userForm \--\>

\<!\-- 将其值传递给register方法 \--\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input tpe="password" name="password" ngModel\>

\</div\>

\<button type="submit"\>Register\</button\>

\</form\>

现在我们的register方法，调用的时候多了一个表单值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

\@Component({

selector: 'ns-register',

templateUrl: 'register.component.html'

})

export class RegisterFormComponent {

register(user) {

console.log(user);

}

}

这仅仅是单向数据绑定。如果你更新了字段，模型也会更新，但是更新模型并不会更新你的字段值。但是ngModel比你想象的更强大！

## 双向数据绑定

如果你已经用过AngularJS 1.x，或者仅仅是读过关于它的文章，你可能见过一个著名的例子，它有一个input和一个展示这个input值的表达式，用户每次修改input都会更新，当模型变化的时候字段也会自动更新。也就是著名的"双向数据绑定"，像是：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<!\-- AngularJS 1.x代码示例 \--\>

\<input type="text" ng-model="username"\>

\<p\>{{ username }}\</p\>

我们可以用Angular完成类似的事情。

首先定义一个会在表单中填充的模型。我们在User类中完成这些：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

class User {

username: string;

password: string;

}

我们的RegisterFormComponent应该有一个User类型的user字段：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

class User {

username: string;

password: string;

}

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html',

})

export class RegisterFormComponent {

user = new User();

register() {

console.log(this.user);

}

}

正如现在你看到的，register()方法直接记录user对象了。

我们准备好增加我们表单的输入了。我们需要绑定我们inputs到我们定义的模型上。为此，我们将使用ngModel指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()"\>

\<div\>

\<label\>Username\</label\>\<input name="username" \[(ngModel)\]="user.username"\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" \[(ngModel)\]="user.password"\>

\</div\>

\<button type="submit"\>Register\</button\>

\</form\>

哦！\[(ngModel)\]？这是什么语法？它是下面这种形式的语法糖而已：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input name="username" \[ngModel\]="user.username" (ngModelChange)="user.username = \$event"\>

NgModel指令在关联的模型user.username每次变化都会更新input值，就是\[ngModel\]="user.username"这部分。用户每次更新input的值都会通过一个叫做ngModelChange的输出提交一个事件，事件本身就是新的值，也就是(ngmodelChange)="user.username = \$event"部分，这就会将模型user.username改成这个新值。

不用写这中长的格式，我们可以使用新的语法\[()\]。如果像我一样，你分不清是\[()\]还是(\[\])，有一个非常好的帮助记忆的方法：它是一个香蕉盒子！是的，看：\[\]是个盒子，里面是两个相互面对的香蕉()！

仙子啊，每次我们在input中输入东西，模型也会更新。如果我们组件中更新了模型，我们的字段也会显示正确的值：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()"\>

\<div\>

\<label\>Username\</label\>\<input name="username" \[(ngModel)\]="user.name"\>

\<small\>{{ user.username }} is an awesome username!\</small\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" \[(ngModel)\]="user.password"\>

\</div\>

\<button type="submit"\>Register\</button\>

\</form\>

如果你尝试上面的例子，你会看到双向数据绑定是可以工作的。我们的表单也是可以工作的：我们可以提交它，组件就会打印出user对象。

## 代码驱动

在AngularJS 1.x中，你不得不在模版中完成大部分的模版工作。Angular引入了引入了一种命令的方式，使我们能够以编程的方式构建表单，而不是通过模版。

现在我们可以在我们的代码中直接处理表单了。它更加冗余，但是更加强大。

要在我的组件代码中构建一个表单，我们需要我们谈论过的抽象：FormControl和FormGroup。

使用这些基础的元素，我们可以在我们的组件中构建一个表单。但是我们并不使用new FormControl()或者new FormGroup()，我们使用帮助类，FormBuilder，我们可以将其注入：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

constructor(fb: FormBuilder) {

// 我们需要构建表单

}

register() {

// 处理提交

}

}

FormBuilder是一个帮助类，有很多便利的方法来创建控制和组。让我们从简单的情形开始，创建一个带有两个控制的小表单，一个用户名和一个密码。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormGroup } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

userForm: FormGroup;

constructor(fb: FormBuilder) {

this.userForm = fb.group({

username: '',

password: ''

> });

}

register() {

// 处理提交

}

}

我们创建了一个带有两个控制的表单。可以看到每个控制的值都是''。这和以这个字符串为参数使用FormBuilder的controle()方法是一样的，也和使用new FormControl('')一样：这个字符串代表了你想要在你的表单中显示的值。这里是空，所以输入会是空。当然了是你可以在这里有值，比如当你正在修改一个已经存在的实体时。帮助方法也有其它特定的属性，我们稍后会看到。

我们需要实现register方法。真如我们之前看到的，FormGroup独享有一个value属性，我们可以像下面一样记录它的内容：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormGroup } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

userForm: FormGroup;

constructor(fb: FormBuilder) {

this.userForm = fb.group({

username: fb.control(''),

password: fb.control('')

> });

}

register() {

console.log(this.userForm.value);

}

}

我们现在需要在模版中做一些工作了。我们会使用一些和"模版驱动"表单不同的指令。这些指令在ReactiveFormsModule中，我们需要在根模块中引入它。名字以form开始，而不是ng，因为ng是"模版驱动"的习惯。

表单需要被绑定到我们的userForm对象上，使用formGroup指令可以做到。每个input字段被绑定到一个控制上，这可以通过formControlName指令实现：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" formControlName="password"\>

\</div\>

\<button type="submit"\>Register\</button\>

\</form\>

我们想要绑定我们组件中的userForm属性到formGroup，我们使用了中括号记号\[formGroup\]="userForm"。每个input都接受了一个formControlName指令，给其指定了他所绑定字符串直接量。如果你指定了一个不存在的名字，就会得到一个错我。因为我们是传递的一个值（并不是一个表达式），所以我们并没有为formControlName添加\[\]。

我们都做好了：点击提交按钮将会记录一个包含用户名和密码的对象！

如果需要，可以从组件中更新FormControl的值，使用setValue()：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormGroup, FormControl } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

usernameCtrl: FormControl;

passwordCtrl: FormContorl;

userForm: FormGroup;

constructor(fb: FormBuilder) {

this.usernameCtrl = fb.control('');

this.passwordCtrl = fb.control('');

this.userForm = fb.group({

username: this.usernameCtrl;

password: this.passwordCtrl;

> });

}

reset() {

this.usernameCtrl.setValue('');

this.passwordCtrl.setValue('');

}

register() {

console.log(this.userForm.value);

}

}

## 添加一些验证

验证是表单构建中的大项。比如一些字段是必填的，一些事基于其它字段的，一些必须符合某种格式，一些要求不大于或者小于某个值X。

我们添加一些基本的验证规则：所有的字段都是必填的。

## 在一个代码驱动表单中

要指定每个字段都是必填的，我们会使用一个Validator。一个验证器如果检测到错误就返回一个错误的映射，如果检测不到就返回null。

框架提供了几个验证器：

-   Validators.required确保一个控制不是空的

-   Validators.minLength(n)，确保输入的值至少有n个字符

-   Validators.maxLength(n)，确保输入的值至多有n个体字符

-   Validators.email()，（4.0之后可用）确保输入的值事一个合法的电子邮件地址（v 你自己能够找到正确的正则表达式用来完成这个判断是很幸运的）

-   Validators.min(n)（4.2之后可用）确保输入至少是n

-   Validators.max(n)（4.2之后可用）确保输入之多是n

-   Validators.pattern(p)，确保值匹配正则表达式p

你可以通过使用一个数组，对FormControl或者FormGroup一次性应用多个验证器。这里我们想要每个字段都是强制的，所以我们为每个控制都添加了一个必填验证器，并且确保用户名至少是3个字符。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormGroup, Validators } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

userForm: FormGroup;

constructor(fb: FormBuilder) {

this.userForm = fb.group({

username: fb.control('', \[Validators.required, Validators.minLength(3)\]),

password: fb.contorl('', Validators.required)

> });

}

register() {

console.log(this.userForm.value);

}

}

## 在一个模版驱动表单中

在一个模版驱动的表单中添加一个必填字段也是直观的：你只需要在inputs上添加required属性即可。required是一个提供的指令，会自动的添加验证器到这个字段上。同样的原理，还有minlength、maxlength、和email（min和max还不是可用的指令）。

从双向绑定的例子继续：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel required minlength="3"\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel required\>

\</div\>

\<button type="submit"\>Register\</button\>

\</form\>

注意这也可以在"代码驱动"的表单中做到。

## 错误和提交

当然，如果还有错误，就不应该提交表单，这些错误必须完美的展示出来。

如果你尝试这些例子，你会发现即使字段是要求必填的，我们也可以提交表单。也许我们应该做些什么？

我们知道我们可以通过disabled属性禁用一个按钮，但是我们需要给它一个反应当前表单状态的表达式。

## 代码驱动表单的错误和提交

我们在我们的组件中增加了一个字段userForm，其类型是FormGroup。这个字段给了我们关于表单和字段状态和错误的完整视图。

比如，我们可以在表单非法的情况下禁止表单提交：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\</div\>

\<div\>

\<label\>Pasword\</label\>\<input type="password" formControlName="password"\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

如最后一行看到的，我们只需要将disabled和userForm的invalid属性联系在一起即可。

现在我们在所有的控制都合法的情况下提交了。要帮助用户了解为什么表单还不能提交，我们需要展示错误信息。

还是使用userForm，我们可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\<div \*ngIf="userForm.get('username').hasError('required')"\>Username is required\</div\>

\<div \*ngIf="userForm.get('username').hasError('minlength')"\>Username should be 3 characters min\<\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" formControlName="password"\>

\<div \*ngIf="userForm.get('password').hasError('required')"\>Password is required\</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

太酷了！如果字段为空错误就会展示出来，如果有值就会自动消失。但是它们在表单出现的时候就会显示出来。或许我们可以让其在用户做出修改之前，先隐藏它们？

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\<div \*ngIf="userForm.get('username').dirty && userForm.get('username').hasError('required')"\>Username is required

> \</div\>
>
> \<div \*ngIf="userForm.get('username').dirty && userForm.get('username').hasError('minlength')"\>
>
> Username should be 3 characters min
>
> \</div\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" formControlName="password"\>

\<div \*ngIf="userForm.get('password').dirty && userForm.get('password').hasError('required')"\>

Password is required

> \</div\>

\</div\>

\<button type="submit" \[disabled="userForm.invalid"\]\>Register\</button\>

\</form\>

有些冗余，但是你可以在组件中为每个控制创建一个引用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

userForm: FormGroup;

usernameCtrl: FormControl;

passwordCtrl: FormControl;

constructor(fb: FormBuilder) {

this.usernameCtrl = fb.control('', Validators.required);

this.passwordCtrl = fb.control('', Validators.required);

this.userForm = fb.group({

username: this.usernameCtrl,

password: this.passwordCtrl

> });

}

register() {

console.log(this.userForm.value);

}

}

然后在你的模版中就可以使用这些引用了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required

> \</div\>
>
> \<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('minlength')"\>
>
> Username should be 3 characters min
>
> \</div\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" formControlName="password"\>

\<div \*ngIf="passwordCtrl.dirty && passwordCtrl.hasError('required')"\>

> Password is required
>
> \</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

## 模版驱动表单中的错误和提交

在一个模版驱动的表单中，我们在组件中不会有任何字段来引用FormGroup，但是我们已经在模版中声明了一个本地变量，它引用了表单指令中导出的NgForm对象。再一次，这个变量使我们能够知道表单的状态并且访问它的控制。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel required\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel required\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

现在我们需要展示每个字段的错误。

类似于表单指令，每个控制都导出了它的FormControl对象，所以我们可通过创建一个本地变量来访问错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel required \#username="ngModel"\>

\<div \*ngIf="username.dirty && username.hasError('required')"\>User name is required\</div\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel required \#password="ngModel"\>

\<div \*ngIf="password.dirty && password.hasError('required')"\>Passoword is required\</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

一切正常！

## 添加一些样式

不论你选择如何创建你的表单，Angular为我们做了一项非常棒的工作：在每个字段（和表单上）上自动地添加和删除CSS类，这样我们就可以添加一些样式了。

比如，如果一个字段的某个验证器失败了，它就会具有ng-invalid类，如果所有的验证器都通过了，就会有ng-valid类。这意味着你能非常容易的添加一些样式，像是在失败的字段上添加一个红色的边框：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<style\>

input.ng-invalid {

border: 3px red solid;

}

\</style\>

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel required\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel required\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

另一个有用的CSS类是ng-dirty，它会在用户改变了值的情况下存在。它的对立面是ng-pristine，如果用从未改变值，它就会存在。我通常只在用户至少更改一次值之后显示红色的边框：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<style\>

input.ng-invalid.ng-dirty {

border: 3px red solid;

}

\</style\>

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register(userForm.value)" \#userForm="ngForm"\>

\<div\>

\<label\>Username\</label\>\<input name="username" ngModel required\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" name="password" ngModel required\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

最后一个CSS类：ng-touched。如果用户进入并离开这个字段至少一次（即使其并未变更值），它就会出现。它的反面是ng-untouched。

当你第一次展示表单的时候，一个字段通常会具有类ng-pristine ng-untouched ng-invalid。然后当用户进入并离开字段的时候，它切换成ng-prinstine ng-touched ng-invalid。当用户改变了值，但是仍有非法的，我们就得到ng-dirty ng-touched ng-invalid。最终，当值为合法时：ng-dirty ng-tuched ng-valid

## 创建自定义的验证器

小马比赛是一个让人上瘾的游戏，所以它只允许大雨18岁的用户注册。我们需要用户输入两次密码，以避免用户犯下错误。

我们怎样做呢？我们创建一个自定义的验证器。

为此，我们需要创建一个接受一个FormControl的方法，测试它的值，返回一个带有错误的对象，如果验证通过就返回null。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const isOldEnough = (control: FormControl) =\> {

// 控制时一个日期输入，所以我们可以从值来构建日期

const birthDatePlus18 = new Date(control.value);

birthDatePlus18.setFullYear(birthDatePlus18.getFullYear() + 18);

return birthDatePlus18 \< newDate() ? null : {tooYoung: true};

}

我们的验证方法非常简单：我们获取控制的值，构建了日期，检查其第18个生日是否在现在之前，如果不是返回一个键为'tooYoung'的错误。

现在我们需要包含这个验证器。

## 在代码驱动的表单中使用一个验证器

我们需要在表单中增加一个带有这个验证器的控制，通过使用FormBuilder来达成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormControl, FormGroup, Validators } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

usernameCtrl: FormControl;

passwordCtrl: FormControl;

birthdateCtrl: FormControl;

userForm: FormGroup;

static isOldEnough(control: FormControl) {

// 控制时一个日期输入，所以我们可以从其值构建出Date

const birthDatePlus18 = new Date(control.value);

birthDatePlus18.setFullYear(birthDatePlus18.getFullYear() + 18);

return birthDatePlus18 \< new Date() ? : null : {tooYoung: true};

}

constructor(fb: FormBuilder) {

this.usernameCtrl = fb.control('', Validators.required);

this.passwordCtrl = fb.control('', Validators.required);

this.birthdateCtrl = fb.control('', \[Validators.required, RegisterFOrmComponent.isOldEnough\]);

this.userForm = fb.group({

username: this.usernameCtrl;

password: this.passwordCtrl;

birthdate: this.birthdateCtr;

> });

}

register() {

console.log(this.userForm.value);

}

}

正如你看到的，我们增加了一个新的控制birthdate，它有两个验证器。第一个验证器是required，另一个我们类的静态方法isOldEngough。当然如果你想的话，这个方法也可在另一个类中（required也是一个静态的方法）。

不要忘记在表单中添加这个字段并展示错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>\<input formControlName="username"\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required.

> \</div\>

\</div\>

\<div\>

\<label\>Password\</label\>\<input type="password" formControlName="password"\>

\<div \*ngIf="passwortCtrl.dirty && passwortCtrl.hasError('required')"\>

Password is required

> \</div\>

\</div\>

\<div\>

\<label\>Brithdate\</label\>\<input type="date" formControlName="birthdate"\>

\<div \*ngIf="brithdateCtrl.dirty"\>

\<div \*ngIf="birthdateCtrl.hasError('required')"\>

Birth date is required

> \</div\>
>
> \<div \*ngIf="birthdateCtrl.hasError('tooYoung')"\>
>
> You're way too young to be betting on pony races
>
> \</div\>
>
> \</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

相当简单，不是吗？

注意也是可以创建和添加异步验证器的（比如通过后端检查一个用户名是否可用）。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

usernameCtrl: FormControl;

userForm: FromGroup;

constructor(fb: FormBuilder, private userService: UserService) {

this.usernameCtrl = fb.control('', Validators.required, control =\> this.isUsernameAvailable(control));

this.userForm = fb.group({

username: this.usernameCtrl

> });

}

isUsernameAvailable(control: AbstractControl) {

const username = control.value;

return this.userService.isUsernameAvailable(username).pipe(

map(available =\> available ? null : {alradyUsed: true})

> );

}

register() {

console.log(this.userForm.value);

}

}

这次的异步验证器不是静态的了，因为它需要访问服务。

服务中的方法返回一个Observable，如果没有错误（用户名可用）就提交一个null，否则就提交一个代表错误的对象（键就是错误，和同步的情况一样）。

一个有趣的特性，类ng-pending会在异步验证器工作的时候被添加到字段上。这可以用于在验证器正在工作的时候显示一个转圈。

## 在模版驱动的表单中使用一个验证器

要在一个模版驱动的表单中添加一个自定义验证器，我们需要将其加在模版中！

为此，比需要创建一个自定义的指令应用于这个input，但是坦诚来说，这里用代码驱动的表单更简单 ...

或者你可以结合两者的好处！

## 分组字段

到此为止，我们只有一个组：整个的表单。但是我们可以在一个组中声明其它组。在你需要验证一组像是地址这样的字段的时候，就非常好用了，或者在我们的例子中，你可以用于验证密码和其验证是否匹配。

解决方案就是使用代码驱动表单（这样就可以结合模版驱动表单的好处）。

首先，创建一个新的组，带有两个字段的passwordForm，并且将其添加到组userForm中。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormControl, GromGroup, Validators } from '\@angular/forms';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

passwordForm: FormGroup;

userForm: FormGroup;

usernameCtrl: FormControl;

passwordCtrl: FormControl;

confirmCtrl: FormControl;

static passwordMatch(group: FormGroup) {

const password = group.get('password').value;

const confirm = group.get('confirm').value;

return password === confirm ? null : {matchingError: true};

}

constructor(fb: FormBuilder) {

this.usernameCtrl = fb.control('', Validators.required);

this.passwordCtrl = fb.control('', Validatators.required);

this.confirmCtrl = fb.control('', Validators.required);

this.passwordForm = fb.group({

password: this.passwordCtrol,

confirm: this.confirmCtrl

> }, {validator: RegisterFormComponent.passwordMatch});
>
> this.userForm = fb.group({
>
> username: this.usernameCtrl, passwordForm: this.passwordForm
>
> });

}

register() {

console.log(this.userFOrm.value);

}

}

正如你看到的，我们为 组添加了一个验证器，passwordMatch，只要有一个字段发生变化就会触发其执行。

让我们更新一下模版以反映出新的表单，使用指令formGroupName：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" formGroup="userForm"\>

\<div\>

\<label\>Username\</label\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required

> \</div\>

\</div\>

\<div formGroupName="passwordForm"\>

\<div\>

\<label\>Password\</label\>

\<input type="password" formControlName="password"\>

\<div \*ngIf="passwordCtrl.dirty && passwordCtrl.hasError('required')"\>

Password is required

> \</div\>
>
> \</div\>
>
> \<div\>
>
> \<label\>Confirm password\</label\>
>
> \<input type="password" formControlName="confirm"\>
>
> \<div \*ngIf="confirmCtrl.dirty && confirmCtrl.hasError('required')"\>
>
> Confirm your password
>
> \</div\>
>
> \</div\>
>
> \<div \*ngIf="passwordForm.dirty && passwordForm.hasError('matchingError')"\>
>
> Your password does not match
>
> \</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

一切正常！

## 响应变化

代码驱动表单的最后一个非常棒的特性：你可以通过使用observable valueChanges非常容易的应对值的变化。响应式编程太棒了！比如，我们想要我们的密码字段展示强度提示器。我们想要在值变化的时候计算密码的强度：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component } from '\@angular/core';

import { FormBuilder, FormControl, FormGroup, Validators } from '\@angular/forms';

import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

\@Component({

selector: 'ns-register',

templateUrl: 'register-form.component.html'

})

export class RegisterFormComponent {

userForm: FormGroup;

usernameCtrl: FormControl;

passwordCtrl: FormControl;

passwordStrength = 0;

constructor(fb: FormBuilder) {

this.usernameCtrl = fb.control('', Validators.required);

this.passwordCtrl = fb.control('', Validators.required);

this.userFOrm = fb.group({

username: this.usernameCtrl;

password: this.passwordCtrl;

> });
>
> // 我们订阅每个密码的变化
>
> this.passwordCtrl.valueChanges.pipe(
>
> // 只有用户停止输入400ms之后重新计算
>
> debounceTime(400),
>
> // 只有和上一个值不同的时候才计算
>
> distinctUntiChanged()
>
> ).subscribe(newValue =\> this.passwordStrength = newValue.length);

}

register() {

console.log(this.userForm.value);

}

}

现在我们的组件中有一个passwordStrength字段了，我们可以将其展示给我们的用户：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h2\>Sign up\</h2\>

\<form (ngSubmit)="register()" \[formGroup\]="userForm"\>

\<div\>

\<label\>Username\</label\>

\<input formContorlName="username"\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required

\</div\>

\</div\>

\<div\>

\<label\>Password\</label\>

\<input type="password" formControlName="password"\>

\<div\>Strength: {{ passwordStrength }}\</div\>

\<div \*ngIf="passwordCtrl.dirty && passwordCtrl.hasError('required')"\>

Password is required

> \</div\>

\</div\>

\<button type="submit" \[disabled\]="userForm.invalid"\>Register\</button\>

\</form\>

我们使用了RxJS操作符添加了几个酷的特性：

-   debounceTime(400)，只有在用停止输入400ms之后才会提交值。这避免了用户每次输入都会重新计算。这对于计算花费时间较长或者做HTTP请求的情况非常有用。

-   distinctUntilChanged()只有在新的值和旧值不同的情况下才会提交值。这样非常有趣：比如用户输入'password'然后停止输入。我们计算密码强度。然后他输入了一个新的字符并且很快删除了他（在400ms之内）。debounceTime的下一个事件也还是'password'。没有必要重新计算强度！这个操作符甚至不会提交这个值，我们也不会重新计算了。

RxJS可以为我们做很多事情：想象一下如果我们自己来实现上面两行做的事情。它也很容易和HTTP结合使用，因为HttpClient服务也使用Observable。

## 只在blur或者提交的时候更新

Angular 5.0使等待blur或者提交时间发生时才更新字段的值和合法性称为可能。为此，FormControl第二个参数接受一个options对象，来定义同步和异步的验证器，还有updateOn选项。它的值可以是：

-   change，这是默认情况，每次值的变化都会计算合法性

-   blur，当字段失去焦点的时候才会被计算

-   submit,当父表单被提交的时候才会计算合法性

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.usernameCtrl = new FormControl('', Validators.required);

this.passwordCtrl = new FormControl('', {

validators: Validators.required,

updateOn: 'blur'

});

也可以一次性在一组字段上进行配置：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.userFOrm = new FormGroup({

username: this.usernameCtrl,

password: this.passwordCtrl

}, {

updateOn: 'blur'

});

同样的特性在模版驱动表单中也可用，这要使用NgModel指令的ngModelOptions输入：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<label\>Username\</label\>

\<input name="username" \#usernameCtrl="ngModel"

\[(ngModel)\]="user.username" \[ngModelOptions\]="{updateOn: 'blur'}" required\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required

\</div\>

全局的设置可以通过NgForm指令的NgFormOptions输入（出现在5.0）：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<form (ngSubmit)="register()" \[ngFormOptions\]={updateOn: 'blur'}\>

\<div\>

\<label\>Username\</label\>

\<input name="username" \#usernameCtrl="ngModel" \[(ngModel)\]="user.username" required\>

\<div \*ngIf="usernameCtrl.dirty && usernameCtrl.hasError('required')"\>

Username is required

> \<div\>

\</div\>

\</form\>

## 总结

Angular提供了两种构建表单的方式：

-   在模版中构建。但是，正如你看到的，它强制我们必须使用自定义指令来做验证，并且很难测试。这对于简单的表单很有用，比如只有一个或者很少的字段，并且它给了我们双向数据绑定的能力。

-   另一种是在组件中构建。这让我们更容易构建验证和测试，可以有多层的组。构建复杂表单的时候它非常合适。你甚至可以响应一个组的变化，或者一个字段的变化。

-   结合两者，减少"模版驱动个"的冗余和"代码驱动"表单的验证。

这可能是很实用主义的：如果你喜欢可以使用基于模版并和双向绑定，一旦你需要访问表单组或者表单控制，比如添加自定义验证或者响应动作，然后就可以在组件中声明你需要的东西，然后绑定输入，然后使用合适的指令将其加入。

# ZONES和Angular魔法

使用AngularJS 1.x开发有一种"魔法"的感觉，Angular仍旧给你同样的感觉：你在一个input中输入一些值，所有东西都魔术般的更新了。

我喜欢魔术，但是我们更像理解我使用的工具背后正在发生什么。如果你和我一样，我想这部分也会引起你的兴趣：我们将看到Angular底层是怎样工作的！

但是首先，我们先了解一下AngularJS 1.x是怎样工作的，即使你永远不会用到，但是也是很有意思的。

所有的JavaScript框架以大致相同的方式工作：它们帮助开发者响应应用事件，更新应用状态，刷新相应的DOM。但是它们有各自不同的使用方式。

比如EmberJS，要求开发者使用setters来改变对象的状态，这样框架才能够拦截对这些setters的调用。这使它能够知道模型有什么变化，然后才能相应地更新DOM。

另一方面，React选择在每次变化之后重新计算DOM。但是由于修改整个DOM是一个繁重的操作，它将这些变化应用于一个虚拟DOM，然后应用虚拟DOM和真实DOM之间的变化。

Angular不使用任何的setter，也不使用什么虚拟DOM。那么，它是怎样知道DOM中需要改变什么呢？

## AngularJS 1.x和整理循环

第一步是检测模型中的变化。一个变化总是由一个事件触发，可以直接来自于用户（比如，按钮点击护着表单输入），或者来自于"系统"事件（HTTP响应，超过超时时间后一个异步方法被调用等）。

所以，AngularJS 1.x是怎样知道一个事件已经发生了呢？这部分非常简单：它强制我们使用它的指令，比如ng-click来响应点击事件，或者ng-model来观察一个输入的变化。它也强制我们使用它的服务，比如用\$http做HTTP请求，或者\$timeout来执行异步任务。

使用这些指令和服务使框架能够了解发生的任何事件。这是魔法的第一部分！正是第一部分触发了第二部分：框架现在必须分析对模型做出的变化，来决定DOM的哪部分需要被更新（如何更新）。

为此，在1.x版本中，框架维护了一系列的watchers，它们负责观察和响应模型的某一部分。为了简化起见，每个在HTML模版中的动态表达式都会创建一个相应的watcher。这可能导致一个页面中有几百个watchers。

这些watcher就是AngularJS 1.x的核心：它是框架的记忆，这里用来记住应用的状态。

框架每检测到一个事件（用户通过ng-model在一个输入中输入一些东西，一个HTTP相应，一个超时执行等等），它就会触发一个整理循环。

这个整理循环求值所有存储在watchers中的表单事，比较它们的新值和旧值。如果有变化，框架知道它必须更新DOM，所以UI展示了新的值。这个技术叫做脏检查：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image12.png){width="6.5in" height="2.0930555555555554in"}

在整理循环之中，Angular会循环所有的watchers，并求值每一个监测的表达式。这里需要注意一点：它会在结果稳定之前，不断执行此循环，比如，所有的新值都和旧值一样。

为什么会这样做？因为每次被监测表达式的值被观察到发生变化的时候，一个回调函数就会被调用。这个回调函数，反过来，又可以修改模型，这样就可能修改一个或几个其它被监测的表达式。

让我们举一个最小化的例子：一个带有两个用户必须填写的字段的页面：名字和密码。我们假设页面显示了密码的强度。一个watcher被用来监测密码的值，并且在其变化的时候重新计算强度的值。

在整理循环第一次迭代之后，一旦用户输入了密码的第一个字母，我们就有以下的watchers：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\$\$watchers (expression -\> value)

-   "user.name" -\> "Cedric"

-   "user.password" -\> "h"

-   "passwordStrength" -\> 0

观察user.password表达式的watcher的回调函数就会被调用，他会计算出新的密码强度：3.

Angular并不知道哪些变化会引用于模型，所以它又启动了第二次整理迭代来确保模型是稳定的。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\$\$watchers

-   "user.name" -\> "Cedric"

-   "user.password" -\> "h"

-   "passwordStrength" -\> 3

这个模型并没有稳定：passwordStrength的值在第一次迭代之后有变化了。所以它又开启了另一次整理迭代。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\$\$watchers

-   "user.name" -\> "Cedric"

-   "user.password" -\> "h"

-   "passwordStrength" -\> 3

这次，模型稳定了。此时AngularJS 1.x才会将结果刷新到DOM中。所以整理循环对于应用中的每次变化都会至少发生2次。整理可以迭代到10次，但是不会更多：10次迭代之后，如果结果还不稳定，框架就会认为有一个无限循环，并且抛出一个异常。

所以我们可以将这个过程进一步画成：

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image13.png){width="6.5in" height="2.1458333333333335in"}

强调一下：这会在每个事件之后发生。这意味着，如果你的用户在密码字段中输入了5个字符，整理循环将会执行5次，每次又有3个迭代，总共就有15个迭代。

在一个真实的应用中，你会有几百个watchers，这样每个事件之后就会有数以千计的表达式求值！

尽管听上去非常疯狂，但却没有什么问题，因为现代浏览器非常快，如果有需要，有多种方式来做优化。

现在让我们总结一下关于AngularJS 1.x的两个重要的点：

-   你必须使用框架的服务和指令，以让框架能够掌握对模型做出的所有变化

-   在一个并非由Angular管理的事件后修改模型也是可以的，但是你必须县式（通过使用著名的\$scope.\$apply()方法，它就是用来启动整理循环的）的启动检测变化的机制。比如，如果你想要不使用\$http服务去发送一个HTTP请求，你需要在应答会调用通过调用\$scope.\$apply来告诉框架：嘿，我在模型中存储了新的值，你可以启动一个整理循环吗？

框架的魔法可以分成两部分：

-   每个事件之后触发变化检测

-   变化检测自身，通过watchers和整理循环实现

现在我看看Angular是怎样做的，它和AngularJS有什么不同。

## Angular和zones

Angular基于同样的原则，但是实现的方式是不一样的。我们也可以说，以一种更加聪明的方式实现。

问题的第一部分------触发变化检测------Angular团队构建了一个小的子项目叫做Zone.js。这个项目并不和Angular绑定，因为zones是一个可以在其它项目中使用的工具。Zones也不是一个新的概念：它已经在Dart语言（Google的另一个项目）存在了很长一段时间了。它也和Node.js中的Domains（现在已经被废弃了）和Java中的ThreadLocals有类似的地方。

但是着可能是在JavaScript中第一次使用zones。不要担心，我们将会慢慢学习。

## Zones

一个zone就是一个执行上下文。这个上下文接收并执行代码，代码本身可以是同步的，也可以是异步的。zone带了几个好处：

-   钩子可以在代码之前或者之后执行

-   拦截要执行的代码的潜在错误的一种方式

-   存储绑定与这个上下文的变量的一种方式

让我们举个例子。假设我们的应用中有如下的代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

// 分数计算 -\> 同步

const score = computeScore();

// 用户得分更新 -\> 同步

updatePlayer(playerOne, score);

当我们执行这个代码的时候，我们得到：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

computeScore: new score: 1000

updatePlayer: player 1 has 1000 points

假设现在我们想要衡量执行这些代码需要的时间。我可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

startTimer();

const score = computeScore();

updatePlayer(playerOne, score);

stopTimer();

这会产生：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

start

computeScore: new score: 1000

updatePlayer: player 1 has 1000 points

stop: 12ms

很简单。现在如果updatePlayer是一个异步函数会怎么样呢？JavaScript工作方式非常特殊：异步操作会置于执行队列的尾部，这样其就会在同步操作之后执行。

所以，先前的代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

startTimer();

const score = computeScore();

updatePlayer(playerOne, score); // 异步

stopTimer();

会生成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

start

computeScore: new score: 1000

stop: 5ms

updatePlayer: player 1 has 1000 ponits

我的执行时间不再准确 了：它仅仅衡量了同步操作的执行时间，而分数更新的时间被漏掉了！这里可以用zones解决问题。我们将会在一个独立的执行上下文：一个zone中执行代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const scoreZone = Zone.current.fork({name: 'scoreZone'});

scoreZone.run(()=\> {

const score = computeScore();

updatePlayer(playerOne, score); // 异步

});

这为什么会有帮助？如果zone.js被浏览器加载，它就会在JavaScript运行时为所有的异步函数打补丁。所以，我们每次使用setTimout() 或者 setInterval()，或者使用异步API像是promises、XMLHttpRequest、WebSocket、FileReader、GeoLocation等等的时候，我们实际上调用的是zone.js打补丁之后的版本。所以，Zone.js之后异步操作什么时候结束，并且允许开发者在那时执行一些钩子。

一个zone提供了几个钩子：

-   onInvoke会在zone中包含的代码执行之前执行

-   onHasTask会在zone包含的代码完成执行后执行

-   onHandleError会在zone包含的代码抛出一个异常的时候执行

-   onFork会在zone创建的时候执行

所以我们可以使用一个zone和它的钩子来衡量我们的异步操作花费的总时间：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const scoreZone = Zone.current.fork({

name: 'scoreZone',

onInvoke(delegate, current, target, task , applyThis, applyArgs, source) {

// 开始计时器

startTimer();

return delegate.invoke(target, task, applyThis, applyArgs, source);

},

onHasTask(delegate, current, target, hasTaskState) {

delegate.hasTask(target, hasTaskState);

if (!hasTaskState.macroTask) {

// 如果zone完成了，结束计时器

stopTimer();

> }

}

});

scoreZone.run(() =\> {

const score = computeScore();

updatePlayer(playerOne, score);

});

这次，结果是正确的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

start

computeScore: new score: 1000

updatePlayer: player 1 has 1000 points

stop 12ms

现在你可以猜到Angular如何利用这种机制了。事实上，框架的第一个问题就是知道何时触发变化检测。通过使用zones，通过在一个zone中运行我们的代码，框架非常了解正在发生什么。它可以以更好的方式处理错误。更重要的是，每一个异步操作结束，它都可以触发变化检测。

简单起见，Angular做了类似如下的事情：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const angularZone = Zone.current.fork({

name: 'angular',

onHasTask: triggerChangeDetection

});

angularZone.urn(() =\> {

// 你的应用代码

});

第一个问题就解决掉了！这样就是在Angular中，没有必要像AngularJS 1.x一样使用特殊的服务来获取自动变化检测的好处。你可以使用你任何东西，zones会处理一切。

注意zones是在一个标准化的进程中的，在不远的将来可能会成为ECMAScript条文的一部分。另一个有序的信息是，当前的zone.js的实现也提供了WTF的信息（这里不是What The Fuck，而是Web Tracing Framework）。这个库允许在开发模式下描述你的应用，确切的知道应用的每一部分和框架代码的执行时间。简而言之，如果需要，就有很多的信息用来分析性能问题。

## Angular中的变化检测

问题的另一部分是变化检测自身。一件需要知道的事情就是何时、怎样开始，但是另一个要知道的就是它怎样工作。

首先，我们必须记住Angular应用是一个组件树。当变化检测开始的时候，框架遍历树中所有的组件以获知它们的状态是否已经发生变化，并确定新的状态是否影响它们的视图。如果是，组件的DOM部分就会跟新受影响的部分。

树的遍历从根到树叶，并且不同于AngualrJS 1.x，这只会遍历一次。因为这里有一个重大的区别：变化检测并不会改变Angular中的应用模型，而AngularJS 1.x的wathcer在此阶段能够改变模型。

另一个大的不同是一个组件可以修改自身的状态，和其子组件的状态，但是不能修改它祖先的状态。所以，串联的变化是不存在的！

变化检测只用于检查模型中的变化和改变相应的DOM。它不能像1.x那样对模型有副作用，所以只需要一次树遍历，因为遍历并不能修改模型！

准确一些，开发模式的遍历会执行两次以确定副作用不存在（比如，一个子组件修改了父组件的模型）。如果第二次遍历检测到这样的变化，会抛出一个异常来警告开发者这个问题。

这个策略有许多优点：

-   应用更好归因，因为状态的变化是一个防线的，从父到子，而非两者皆可。

-   变化检测不再有无限循环了；

-   变化检测更快了

最后一点，可以相对简单的意识到：AngularJS 1.x做了(M wachers) \* (N cycles)的验证，而Angular只需要M次验证。

性能提升也需要考虑另一个因素：框架做这些验证所花费的时间。再次，Google团队利用了它所掌握的所有关于计算机可选和虚拟机的知识。

要理解性能的提升，我们需要搞清楚表达式的计算和值的比较在两个框架下的不同。

在1.x中，机制非常通用。每个watcher都会调用一个通用的方法，用来比较新值和旧值。问题是我们浏览器中的用于执行JavaScript代码的虚拟机（如果你正在使用Google Chrome，那就是V8）并不喜欢通用代码。

如果你不介意，我会先谈论一点儿关于虚拟机的行为的东西。在一个关于JavaScrit框架的书中，你可能并不期待这样的知识点，不是吗？虚拟机是非常特别的程序：你给它们一段代码，然后它们将其转化为机器码并执行它。我们中的很少人（肯定不包括我）能够生成高效的机器码，但是我们确实不关心：我们使用高级语言，让虚拟机来处理它。它们不但转化代码，而且会做优化工作。并且它们很善于做这些事情。一些虚拟机甚至能够生成比人工优化的代码更快的机器码，因为它们得益于运行时的一些信息，而这些信息是不能提前知道的。

要改善性能，像是执行动态JavaScript代码的虚拟机，使用一种叫做内联缓存的方式。它是一种非常老的技术，40年前为SmallTalk发明的，它基于一个简单的原则：如果一个程序经常用相同形状的对象调用一个函数，虚拟机应该记忆如何求值属性。这个技术使用了一个缓存，也就是内联缓存的来源。当获取一个对象的时候，它会查看缓存确定它是否识别了对象的形状。如果是，它会使用缓存的优化过的方式来访问对象的属性。

如果函数的参数有一样的形状，这种缓存就非常有好处。比如， {name: 'Cedric'} 和{name: 'Cyril'}有相同的形状。但是{name: 'JB', skills: \[\]}和上两个就是不同的形状。

如果参数一直有相同的形状，那么缓存就是同态的，就能产生非常快的结果。如果缓存有几种记录，它就是多态的。这意味着这个方法可以使用到几种不同类型的对象上，这会使得代码变慢一些。最后，如果有太多不同的对象形状，虚拟机会完全删除缓存，因为它是复态的。这当然在性能傻姑娘就是最坏的情况了。

现在回到我们AngularJS 1.x中的变化检测。我们现在理解了这个在所有watchers上调用的通用函数并不会使用内联缓存优化。我们处于复态中，代码是最慢的。即使在多数情况下不成问题，一个具有很多watchers的页面会让我们达到一个上线，而使得情况不再那么高效。

为了获取内联缓存的好处，Angular适配了一个不同的策略。不用单一的方法去比较所有类型的对象，Google团队决定为每种类型动态生成比较器。在应用开启的时候，框架遍历组件树，生成一组变化检测函数，每个组件都不一样。

比如，有一个组件PonyComponent中有一个name属性需要在视图中展示，框架会为整个组件生成一个变化检测函数，类似于这个：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

(view) =\> {

var component = view.component;

const currVal = Component.name;

if (currVal !== view.oldValue) {

view.oldValue = currVal;

updateView(view, 'p', currVal);

}

};

这个代码和你手写的代码类似，因为其是同态的，所以虚拟机可以进行优化。结果就是明显更快的代码，允许更加复杂的页面。

总结一下，Angular对比于AngularJS 1.x需要计算更少的表达式和比较更少的值（一遍就够了），这些求值和比较更快。

从开始，Google团队一直在用benchmarks监控性能和AngularJS 1.x、Angular和甚至Polymer和React在不同的场景下作比较，这还是为了检查新版是否变得更快。

如果真的需要，也可能比框架提供的自动优化更进一步：ChangeDetection策略可以修改其默认值，这样就可以适配并为某种使用场景作优化。但是这是另一章的内容了。

# Angular编译：即时编译和提前编译

## 代码生成

在前面的章节中，我们简单地提到了框架会为每个组件生成变化检测函数。

这在Angular中是非常有趣和特殊的点，在其它框架是是没有的：Angular会在应用开启的时候编译模版并为每个组件动态生成代码。

在模版中写的HTML不会被浏览器直接读取。Angular会为你在模版中写的东西每个对应的组件生成一个类。这个类的款站名为ngfactory.js，如果在浏览器控制台中查看Source tab就可以看到。

让我们举个例子，用我们熟知的PonyComponent。这个模版主要是一个带有绑定DOM属性的图片，还有一个插值的图片说明。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<figure\>

\<img \[src\]="getPonyImageUrl()"\>

\<figcaption\>{{ ponyModel.name }}\</figcaption\>

\</figure\>

当Angular编译这个的时候，它首先会解析模版生成所谓的抽象语法树（AST）。一个AST就是代表模版的结构的，一般编译器都会这样表示东西。这是编译的语法分析步骤的结果。这个AST后续会被用于生成动态JavaScript代码，每个组件（我们这里是View\_PonyComponent）一个"视图定义"。视图定义包含了模版的节点。节点有几种类型，比如一个元素（elementDef），它包含了名字和属性，或者是简单的文本节点（textDef）。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function View\_PonyComponent() {

return viewDef(\[

elementDef('figure', \[

elementDef('img', \['src'\]),

elementDef('figcaption', \[

textDef()

> \])
>
> \])

\]);

}

事实上，编译器并没有创建一个树的结构，而是创建了一个平展的数组（深度优先，每个节点都会指示其有多少个子节点），这主要是出于性能考虑：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function ViewPonyComponent() {

return viewDef(\[

elementDef(2, 'figure'),

elementDef(0, 'img', \[src\]),

elementDef(1, 'figcaption'),

textDef()

\]);

}

通过这种表示，Angular能够生成对英语我们PonyComponent的DOM：它既是针对数组的每个元素，将对应的HTMLElement附加到DOM上。

但是它如何处理变化检测呢？视图定义事实上有最后一个参数：一个变化检测函数。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

function View\_PonyComponent() {

return viewDef(\[

elementDef(2, 'figure'),

elementDef(0, 'img', \['src'\]),

elementDef(1, 'figcaption'),

textDef()

\], (checkBinding, view) =\> {

var component = view.component;

const currval\_0 = component.getPonyImageUrl();

checkBinding(view, 1, currval\_0);

const currVal\_1 = component.ponyModel.name;

checkBinding(view, 4, currVal\_1);

});

}

这个变化检测函数所做的基本上和自己写的一样。框架会在需要的时候调用它以检测是否有变化（看上一章）。它就是获取动态部分的值（src属性和插值），然后对视图数据、要更新的元素索引和新值调用框架的函数。checkBinding函数只有一个工作：它会比较这个元素先前的值，如果有变化，就更新它，然后用新值替换它。

这样生成的代码很快，能够被JS引擎优化（看先前章节的同态和内联缓存）。另外在应用启动的时候会花费一些时间来生成代码。这叫做即时编译（JIT）。

总结一下，当你使用JIT编译的时候：你写出TypeScript代码和HTML模版，你编译你的TypScript为JavaScript并将JS和HTML发送给用户。运行时，HTML也会被编译成JS代码。

## 提前编译

我们能够在应用启动之前就生成代码吗？可以的，使用Angular团队写的一个编译器即可：提前编译编译器（AOT）。你可以在你的项目中手动调用它，或者使用CLI（你应该使用），在你构建或者部署应用的时候添加一个简单额标记：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ng build \--aot

现在构建会使用Angular编译器来将模版编译成TypeScript文件。编译成TypeScript？是的，因为之后我们可以检查我们的模版没有问题！生成的TypeScript代码和我们的应用代码会被TypeScript编译（ngc会立即调用TypeScript编译器），如果在模版中有一个错误，你会看到一个错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<figure\>

\<!\-- 错误的方法名 \--\>

\<img \[src\]="getPonyImageUr()"\>

\<figcaption\>{{ ponyModel.name }}\</figcaption\>

\</figure\>

之后Angular编译器会生成这样的TypeScript代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

(checkBinding, view) =\> {

var component: PonyComponent = view.component;

const currVal\_0 = component.getPonyImageUr();

checkBinding(view, 1, currVal\_0);

const currVal\_1 = component.ponyModel.name;

checkBinding(view, 4, currVal\_1);

};

这会在TypeScript编译中导致一个错误：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Property 'getPonyImageUr' does not exist on type 'PonyComponent'.

这太棒了，因为这意味着你可以在运行应用之前检查你的模版。你未来的重构也会更轻松：如果你修改了一个方法的名字或者组件中的一个属性，你会直接知道模版需要被更新，因为如果不更新就会打断构建过程。

这也意味着尽管在即时模式下代码可以正常运行，但是这种提前编译也可能报错。比如，如果在组件中有一个私有属性用在了模版中，在JIT模式下是没有问题的（因为JavaScript没有私有属性的概念），但是会在AoT模式下出问题（ngfactory生成的TypeScript代码需要访问这个变量）。现在，没有你必须使用Aot编译的规则的更好的文档，除了这个来自于Range的仓库。

在交付给用户之前编译应用也会提升应用的启动速度，因为编译已经提前完成了！

总的来说，在AoT模式下：你会写TypeScript和HTML，将HTML编译成TypeScript，然后所有的TypeScript代码编译成JavaScript，然后将JS代码交给用户。

缺点是交付给用户的JavaScript集：生成代码比未编译的模版更大。作为补偿你不需要将Angualr编译器交付给用户，因为模版已经被编译完了。编译器是一大堆代码，所以这是个好处。在一个中等或大规模应用中，这也不能抵消生成工厂增加的代码量。如果你想拥有AoT编译和小的JavaScript集的好处，你需要深入我们在路由器一章中的懒加载特性。

如果你想更加深入这个逐日，这里有一个在ng conf 2017上的关于编译器的讨论。

# 高级Observable

我必须承认我犯了一个错误：我低估了RxJS和Observable的价值。很遗憾，因为我对AngularJS 1.x和Promise也犯了同样的错误。Promises在AngularJS 1.x中非常有用，一旦你掌握它就可以优雅地处理应用的异步部分。但是那需要一些时间，并且有一些需要避免的陷阱（如果想了解更多，可以看一下我们的一个博客：陷阱，反模式和关于AngularJS Promise的提示）。

Angular基于RxJS，在几个API（Http，Forms，Router...）中都暴露了Observable。在用RxJS编码一段时间之后，我认为这本电子书需要一个关于Observable的"高级"这一章，包含它们的创建、订阅、操作符、Angular中可能的应用场景，因为RxJS会在阻止应用方面起关键作用，可以通过它简化我们的工作。

## 订阅、解除定于和asnyc管线

总结一下我们在响应式编程一章中学到的，一个Observable代表一系列我们可以订阅的事件。

事件流可以在任何时候发生，可能只有一个事件，也可能有数千个事件。但是需要理解两种Observable的区别：冷Observable和热Observable。

冷Observable只会在它们被订阅的时候才会提交事件。你可以将其想象为观看一个Youtube视频：视频只会在你点击"播放"按钮之后才会播放。比如，HttpClient类返回的observables就是冷observables：它们只会在你订阅的时候触发请求。

热observable有些不同：它们从创建开始就开始提交事件。你可以将其想象为电视直播：你打开电视机，你会看到表演的中间部分，它们可能已经开始几分钟甚至几个小时了。在一个FormControl中的表示valueChanges的observable就是一个热observable。在你订阅它之前你不会收到提交的值，只有在订阅之后才能得到值。

当你订阅一个observable 的时候，你可以传递三个参数：

-   一个处理下一个事件的函数

-   一个处理错误的函数

-   一个处理完成的函数

第一个非常明显。observable是一个事件流，你会定义当一个事件发生时该怎么做。

第二个允许处理潜在的错误。有时没有必要传递这个函数。如果事件流代表一个点击流，就没有发生错误的可能了，即时你的用户坏掉了手指也不会有错误（这个玩笑可不是我们发明的，它来自于Andre Staltz关于RxJS的一个在NgEurope 2016的演讲上。）。但是多数情况，定义一个错误处理器还是有必要的。比如，你可以定义当HTTP后端返回一个错误的应答的时候怎么做。

有一点需要明白：一个错误时一个终止事件，此后就不会在提交事件了。所以如果继续监听对你来说很重要，你可能需要稳妥地处理这种情况（我们稍后会继续讨论这点）。

第三个函数时处理完成的：这是因为一个observable可以结束（比如你的Youtube视频结束了）。有时你会在observable结束的时候做一些事情，像是警示用户或者计算一个值...

在我们的Ponyracer应用中，一个比赛就是有一个observable表示的，它提交了小马的位置。当比赛结束，observable会停止提交事件。然后我们需要计算哪个小马赢得了比赛，并据此更新UI界面。

也许用户在比赛结束之前都不在。会发生什么呢？组件会被销毁，其中的next函数会继续处理后续的每个事件。即时组件已经不再显示了！这可能导致内存泄露和其它麻烦...

所以最佳实践就是将subscribe函数返回的订阅保存起来，在组件销毁的时候（典型地就在ngOnDestroy方法内），在这个订阅上调用unsubscribe。将解除订阅的操作封装在一个检测此订阅是否存在的块中（可能订阅还没有初始化，如果你这时调用unsubscribe就会产生错误，因为对象还是为定义的）。

这个通用原则有几个特例。对于那些提交几个事件就结束的observables，就没有必要这样做了，像是HTTP请求。如果你订阅一个路由器observable，像是params observable也没有必要做这些：因为路由器会为你清理！

最后，就是async管线。Angular提供了一个特殊的管线，叫做async。你可以用它来在模版中直接订阅一个observable。

它有几个好处：

-   可以直接在组件中存储observable而不必手动订阅，并将提交的值存储到组件的字段中。

-   async管线会在组件销毁的时候处理解除订阅的操作。

-   可以利用它做一些性能魔法（后续会讲到）

当然它也有缺点：当在一个模版中多次使用这个语法的时候，需要小心。

让我们在一个RaceComponent中解释一下最后一点，这个组件用来展示比赛的属性：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-race',

template: \`

\<div\>

\<h2\>{{ (race \| async)?.name }}\</h2\>

\<small\>{{ (race \| async)?.date }}\</small\>

> \</div\>

\`

})

export class RaceComponent implements OnInit {

race: Observable\<RaceModel\>;

error: Boolean;

constructor(private raceService: raceService) {

}

ngOnInit() {

this.race = this.raceService.get().pipe(

// 这里的\`catchError\` 操作符允许处理一个潜在的错误

// 它必须返回一个observable （这里时一个空的）

catchError(error =\> {

this.error = true;

console.error(error);

return EMPTY;

> })
>
> );

}

}

这个代码样例假设方法raceService.get()返回一个提交RaceModel的observable。我们将这个observable存储在一个叫做race的字段中（在博客中你可能会看到race\$，因为其他框架中Observable的命名习惯就是这样的）。然后我们在模版中对race使用async管线两次：一次显示名字，另一次展示日期。这个足迹爱你的代码非常优雅：你不必手动订阅observable。

但是可能你已经注意到了问题。我们调用了两次async管线，这意味着我们对同一个observable订阅了两次。如果raceService.get()方法进行了一次HTTP请求来获取比赛细节，这个请求就会做两次！

第一种解决方案就是修改observable，在不同的订阅者之间共享。这可以使用publishReplay操作符实现：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component, OnInit } from '\@angular/core';

import { Observable, EMPTY } from 'rxjs';

import { catchError, publishReplay, refCount } from 'rxjs/operators';

import { RaceService, RaceModel } from './race.service';

\@Component({

selector: 'ns-race',

template: \`

\<div\>

\<h2\>{{ (race \| async)?.name }}\</h2\>

\<small\>{{ (race \| async)?.date }}\</small\>

> \</div\>

\`

})

export class RaceComponent implements OnInit {

race: Observable\<RaceModel\>;

error: Boolean;

constructor(private raceService: RaceService) {

}

ngOnInit() {

this.race = this.raceService.get().pipe(

// 这里的\`catchError\`操作符允许处理潜在的错误

// 它必须返回一个Observable（这里时空）

catchError(error =\> {

this.error = true;

console.error(error);

return EMPTY;

> }),
>
> // 会在订阅者之间共享订阅
>
> publishReplay(),
>
> refcount()
>
> );

}

}

但是，尽管现在对了，不会产生两个不同的HTTP请求，我确实不喜欢这个模版。很多时候，组件需要访问race，以做一些展示逻辑，而不是仅仅在模版中。它也必须处理错误。组件中的一个订阅，或者do() 和catch()操作符都是需要的。所以在一个字段中存储比赛并不是很大的负担，并且让模版代码更简单。

注意在4.0的时候引入了一个as语法，通过订阅一次并将结果存储于模版的一个变量来解决这个问题：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component, OnInit } from '\@angular/core';

import { Observable, EMPTY } from 'rxjs';

import { catchError } from 'rxjs/operators';

import { RaceService, RaceModel } from './race.service';

\@Component({

selector: 'ns-race',

template: \`

\<div \*ngIf = "race \| async as raceModel"\>

\<h2\>{{ raceModel.name }}\</h2\>

\<small\>{{ raceModel.date }}\</small\>

> \</div\>

\`

})

export class RaceComponent implements OnInit {

race: Observable\<RaceModel\>;

error: Boolean;

constructor(private raceService : RaceService) {

}

ngOnInit() {

this.race = this.raceService.get().pipe(

// 这里的 \`catchError\`操作符允许处理潜在的错误

// 它必须返回一个observable（这里是空）

catchError(error =\> {

this.error = true;

console.error(error);

return EMPTY;

> })
>
> );

}

}

这非常优雅。

另一种可行的方案是将我们的组件分成两个：一个智能组件（负责获取比赛），和一个哑组件（只是展示在input中收到的比赛）。

应该是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-racecontainer'

template: \`

\<div\>

\<div \*ngIf="error"\>

An error occurred while fetching the race

> \</div\>
>
> \<ns-race \*ngIf="race \| async as r" \[raceModel\]="r"\>\</ns-race\>

\</div\>

\`

})

export class RaceContainerComponent implements OnInit {

race: Observable\<RaceModel\>;

error: Boolean;

constructor(private raceService: RaceService) {

}

ngOnInit() {

this.race = this.raceService.get().pipe(

// 这里\`catchError\`操作符允许处理潜在的错误

// 它必须返回一个observable（这里是空）

catchError(error =\> {

this.error = true;

console.error(error);

return EMPTY;

> })
>
> );

}

}

\@Component({

selector: 'ns-race',

template: \`

\<div\>

\<h2\>{{ raceModel.name }}\</h2\>

\<small\>{{ raceModel.date }}\</small\>

> \</div\>

\`

})

export class RaceComponent {

\@Input() raceModel: RaceModel;

}

这种模式可能在应用的一些部分很有帮助，但是像是其他模式一样，你不必在任何地方用它。有的时候一个组件做两件事也不错。其他情况是，你想要将哑组件提取出来在你应用的其他部分复用，这时候两个组件就说的过去了。

## 利用操作符

我们到此看到过几个操作符，但是现在我们想以一步一步的例子来描述一下其它几个操作符。我们会开发一个超前键入的输入。超前键入使用户能够在一个输入中输入文本，然后应用会根据输入的文本展示几个提示（像是Google的搜索框）。

一个好的超前键入会有几个特性：

-   展示与请求匹配的结果（很明显）

-   如果输入文本至少有几个字符的长度，它允许只展示结果

-   它不会每次用户键入都会获取结果，会等一段时间来确定用户完成输入

-   如果用户输入了相同的值，那么也不会进行两次请求

这些都可以手动做到，但是需要耗费颇多。但是我们很幸运，Angular和RxJS组合起来能够很好的解决这个问题。

首先，我们看看你这样的组件看上去是什么样子的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Component, OnInit } from '\@angular/core';

import { FormControl } from '\@angular/forms';

import { PonyService, PonyModel } from './pony.service';

\@Component({

selector: 'ns-typeahead',

template: \`

\<div\>

\<input \[formControl\]="input"\>

\<ul\>

\<li \*ngFor="let pony of ponies"\>{{ pony.name }}\</li\>

> \</ul\>
>
> \</div\>

\`

})

export class PonyTypeAheadComponent implements OnInit {

input = new FormControl();

ponies: Array\<PonyModel\> = \[\];

constructor(private ponyService: PonyService) {}

ngOnInit() {

// todo： 对输入做一些事情

}

}

在ngOnInit方法中，我们可以通过订阅FormControl暴露的valueChanges observable开始（如果需要刷新记忆，可以看一下表单的那一章）。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges

.subscribe(value =\> console.log(value));

下面我们想要使用这个值获取匹配给定输入的小马。我们的PonyService有一个叫做search的方法来完成这个操作！我们可以假设这个方法在后台做了一个HTTP请求并从服务器获取结果，所以它返回一个Observable\<Array\<PonyModel\>\>，一个提交小马数组的observable。

让我们订阅这个方法来更新组件的ponies字段：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges

.subscribe(value =\> {

this.ponyService.search(value)

.subscribe(results =\> this.ponies = results);

});

好的，这可以工作。当时当我看到类似于这个的时候，这让我想起了Promises和嵌套的then调用，而这些then调用是可以展平的。事实上我们也可以对observables做同样的事情，通过使用concatMap操作符：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges.pipe(

concatMap(value =\> this.ponyService.search(value))

).subscribe(results =\> this.ponies = results);

哦，更加优雅一些了！concatMap"展平"了我们的代码。它将源observable的（输入的pony名字）替换为小马observable提交的事件。但是这不是应对这种情况的完美操作符。由于我们的search方法每次搜索都会进行一次HTTP请求，如果一个请求很慢，我们就会遇到麻烦。我们的用户可能查询n然后ni，但是对应于n的结果可能很慢，而对英语ni的可能很快。这意味着我们上面的代码只会在第一个结果之后展示第二个结果，尽管我们不再关心第一个的结果！这可以手动处理，但是非常麻烦。

RxJS为这种情形提供了一个超级有用的操作符：switchMap。不同于concatMap，switchMap只会关心最后提交的值，并会丢弃掉早起的值，所以我们能够确信对应于一个旧输入的结果不会被展示出来。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges.pipe(

switchMap(value =\> this.ponyService.search(value))

).subscribe(results =\> this.ponies = results);

好了，现在让我们丢弃掉少于3个字符的查询。简单：我们只需要一个filter操作符！

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges.pipe(

filter(query =\> query.length \>= 3),

switchMap(value =\> this.ponyService.search(value))

).subscribe(results =\> this.ponies = results);

我们也不想在每次键入之后就立即搜索：比如我们只想要让用户停止输入400ms之后才搜索。好的，你猜到了：有一个操作符，叫做debounceTime：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges.input(

filter(query =\> query.length \>= 3),

debounceTime(400),

switchMap(value =\> this.ponyService.search(value))

).subscribe(results =\> this.ponies = results);

现在一个用户可以输入一个值，删除一些字符，添加另一些，查询只会在最后一次键入之后400ms之后才会窒息感。但是如果用户输入了"Rainbow"等待了400ms（这会发送一个请求），然后又输入了"Rainbow Dash"，然后又立即删除了"Dash"又变回了"Rainbow"，会怎么样呢？这会发送两个队"Rainbow"的请求！也许我们可以发送一个不同的请求？当然可以，使用distinctUntilChanged:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

this.input.valueChanges.pipe(

filter(query =\> query.length \>= 3),

debounceTime(400),

distinctUntilchanged(),

switchMap(value =\> this.ponyService.search(value))

).subscribe(results =\> this.ponies = results);

非常好，不是吗？当用户输入了多于3个字符，并至少等待400ms之后才会触发搜索。我们保证了我们不会触发两次同样的请求，结果和请求总是保持一致！一共就需要5行代码。如果手动去做而又没有任何错误，那可真是需要好运气的...

这是RxJS的一个很好的应用场景，但是关键点在于它提供了很多操作符，它们的背后有很多有趣的东西。需要一些时间来理解它，但是这是值得的，因为它们会在你的应用中非常有用。

## 构建自己的Observable

有时让人遗憾的是，你不得不使用那些生成事件但是没有使用Observabled的库。希望还是有的，因为你可以创建自己的Observables，比如使用Observable.create(observer =\> {})方法。

传递的参数叫做subscribe函数：它负责提交事件和错误，在结束的时候完成。

比如，如果你想要创建一个提交1， 然后提交2，之后完成的Observable，你可以这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const numbers = Observable.create(observer =\> {

observer.next(1);

observer.next(2);

observer.complete();

});

现在我们能够订阅这样的observable：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

numbers.subscribe(

number =\> console.log(number),

error =\> console.log(error),

() =\> console.log('Complete!')

);

// 会记录

// 1

// 2

// Complete!

现在，比如我想要每隔2秒钟提交一个'hello'，从不完成。我们可以使用一些内置的操作符完成，但是我们也可以手动尝试，比如：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Observable } from 'rxjs';

export class HelloService {

get() : Observable\<string\> {

return Observable.create(observer =\> {

const interval = setInterval(() =\> observer.next('hello'), 2000);

> });

}

}

传递给Observable.create()的回调函数也可以返回一个函数，然后在其上调用解除订阅。这对于你做清理工作非常有用。像是我们的HelloService，我们需要在observable被解除订阅的时候停止setInterval。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { Observable } from 'rxjs';

export class HelloService {

get(): Observable\<string\> {

return Observable.create(observer =\> {

const interval = setInterval(() =\> observer.next('hello'), 2000);

return () =\> clearInterval(interval);

> });

}

}

在订阅之前interval不会被创建，所以我仅仅创建了一个冷observable。

我希望你对observable这一章能够乐在其中。它们也能被用来顺序化HTTP请求，或者在组件之间通信（马上就会看到更多）。但是你现在应该知道它能做什么了！

# 高级组件和指令

## 视图查询

在模版一章中，我们谈论了一个很棒的特性叫做"本地变量"，它使我们能够在模版中应用一个DOM。比如，你可以轻松地通过一个按钮将焦点置于一个输入上：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input \#myInput\>

\<button (click)="myInput.focus()"\>Focus\</button\>

我们也在表单一章中也看到了同样的特性，用于我们想要引用一个特定的指令的情况下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input name="login" \[(ngModel)\]="user.login" required \#loginCtrl="ngModel"\>

\<div \*ngIf="loginCtrl.dirty && loginCtrl.hasError('required')"\>

The login field is required

\</div\>

如果我们不仅想要在模版中，而且想要在组件代码中获取这些引用该怎么办呢？这就是"视图查询"登场的时候了，它能给我们带来很大的便利！

比如，你可能想要在组件被展示出来的时候就将焦点置于一个输入上。为此，我们需要使用VIewChild装饰器获取对输入的引用。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-login',

template: \`

\<input \#loginInput name="login" \[(ngModel)\]="credentials.login" required\>

\`

})

export class LoginComponent implements AfterViewInit {

credentials = {login: ''};

\@ViewChild('loginInput') private loginInput: ElementRef\<HTMLInputElement\>;

ngAfterViewInit() {

this.loginInput.nativeElement.focus();

}

}

我们声明了一个叫做loginInput的字段，用ViewChild装饰它。这个装饰器需要一个选择器作为参数：这里我们使用了模版中声明的本地变量。这个装饰器指示让框架知道它需要查询模版以找到一个带有这个本地变量名字的元素。这个字段将会用这个元素进行初始化，也就是ElementRef\<T\>。这个类型只有一个字段，类型为T的nativeElement，它是对于底层DOM元素的引用。

这个例子也展示了生命周期方法nfAfterViewInit的一个很好的应用场景。这个方法会在视图创建后立即被调用，所以你能够确信你需要的元素确实是存在的。如果你在ngOnInit中做同样的事情，就不会成功。也有另一个叫做ngAfterViewChecked的方法，它会在每次检查视图的时候调用（在每次变化检测之后）。

如果你想要在很多不同的组件中使用这个特性，你可以为此创建一个指令，而不是在每隔组件中重复相同的代码。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsFocus\]'

})

export class FocusDirective implements AfterViewInit {

ngAfterViewInit(): void {

}

}

这个指令现在什么也没有做，但是在模版中可以这样使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input nsFocus\>

这个指令需要访问其宿主元素来将焦点交给它。这就使ElementRef有趣的地方，它可以被注入到我们的指令中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsFocus\]'

})

export class FocusDirective implements AfterViewInit {

constructor(private element: ElementRef\<HTMLElement\>) {}

ngAfterViewInit(): void {

this.element.nativeElement.focus();

}

}

一切就绪：我们可以使用这个指令将焦点交给它的宿主元素！

让我们回到我们的ViewChild装饰器：它也可以接受一个类型作为选择器。

比如，在表单那一章中，我们看到在模版驱动方式下提交一个表单，你可以使用双向绑定，或者你可以获取表单的引用，将其值传递给提交方法：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<form (ngSubmit)="authenticate(form.value)" \#form="ngForm"\>

\<!\-- ... \--\>

\</form\>

但是我们也可以使用ViewChild来完成同样的事情：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-login',

template: \`

\<form (ngSubmit)="authenticate()"\>

\<!\-- ... \--\>

> \</form\>

\`

})

export class LoginFormComponent {

\@ViewChild(NgForm) credentialsForm: NgForm;

authenticate() {

console.log(this.credentialsForm.value);

}

}

ViewChild的出色之处在于它是一个动态的查询：它会和模版一直保持一致。如果查询元素被销毁了，字段就会使undefined。

这个装饰器也有一个兄弟叫做ViewChildren。不同于ViewChild只会获取一个匹配选择的引用（如果有多个匹配就匹配第一个），ViewChildren会获取到所有的字段的引用。它返回的是一个QueryList，这个类型有几个有用的属性：

-   first 返回第一个匹配的元素

-   last返回最后一个匹配的元素

-   length 返回匹配的元素数量

-   changes返回一个observable，每当一个匹配的元素被添加、删除或者移动的时候就会提交新的QueryList。

比如说我们有一个RaceComponent用于展示一系列的PonyComponent，当一个PonyComponent被添加或者删除的时候，我就能够轻松获知：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-race',

templateUrl: './race.component.html'

})

export class RaceComponent implements AfterViewInit {

\@Input() raceModel: RaceModel;

\@ViewChildren(PonyComponent) ponies: QueryList\<PonyComponent\>;

ngAfterViewInit() {

this.ponies.changes

// 会记录展示了多少个小马

.subscribe(newList =\> console.log(newList.length));

}

}

QueryList也有很多像是toArray(), map(), filter(), finder...这样的方法。

## 内容

作为一个开发者我们经常需要的另一种能力就是构建具有动态内容的UI组件。

比如，你想使用Bootstrap 4 CSS框架构建一个"card"组件。这样的卡片看上去是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div class="card"\>

\<div class="card-body"\>

\<h4 class="card-title"\>Card Title\</h4\>

\<p class="card-text"\>Some quick example text\</p\>

\</div\>

\</div\>

当然你可以在应用需要的时候，每次都重复这段HTML。但是现在，你可能想要构建一个组件。有两个部分是动态的（标题和内容），下面可能就是你需要的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-card',

template: \`

\<div class="card"\>

\<div class="card-body"\>

\<h4 class="card-title'\>{{ title }}\</h4\>

\<p class="card-text"\>{{ text }}\</p\>

> \</div\>
>
> \</div\>

\`

})

export class CardComponent {

\@Input() title: string;

\@Input() text: string;

}

然后这样使用它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-card title="Card Title" text="Some quick example text"\>\</ns-card\>

这能够完美工作。但是如果更加深入需求，你会意识到，卡片的内容可能是Bootstrap所支持的复杂的HTML，不仅仅是文本。

当然，Angular也能支持这种情况，很容易"传递"HTML给子组件，这主要是利用\<ng-content\>。这就是我们在AngularJS 1.x中的"transclusion"。

ng-content是一个可以用在模版中的特殊标签，用来包含父组件提供的HTML：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div class ="card"\>

\<div class="card-body"\>

\<h4 class="card-title"\>{{ title }}\</h4\>

\<p class="card-text"\>

\<ng-content\>\</ng-content\>

> \</p\>

\</div\>

\</div\>

然后就可以像这样使用这个组件了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-card title="Card title"\>

Some quick \<strong\>example\</strong\> text

\</ns-card\>

之后，你意识到标题也可以是复杂的HTML。当然，也有办法给card组件传递多个内容，需要使用带有选择器的多个ng-content。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<div class="card"\>

\<div class="card-body"\>

\<h4 class="card-title"\>

\<ng-content select=".title"\>\</ng-content\>

> \</h4\>
>
> \<p class="card-text"\>
>
> \<ng-content select=".content"\>\</ng-content\>
>
> \</p\>

\</div\>

\</div\>

使用方法如下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-card\>

\<p class="title"\>

Card \<strong\>title\</strong\>

\</p\>

\<p class="content"\>

Some quick \<strong\>example\</strong\> text

\</p\>

\</ns-card\>

## 内容查询

当你使用ng-content标签的时候，投射的内容不能被VIewChild或者ViewChildren查询。对于这些内容，你需要使用另外两个装饰器：ContentChild和ContentChildren。

加入你正在基于Bootstrap 4构建另一个UI组件，这次是一个 "tabs"组件。HTML根据文档必须是这样的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ul class="nav nav-tabs"\>

\<li class="nav-item"\>

\<a class="nav-link"\>Races\</a\>

\</li\>

\<li class="nav-item"\>

\<a class="nav-link"\>About\</a\>

\</li\>

\</ul\>

但是我们想要为团队提供一个漂亮的组件，像是这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-tabs\>

\<ns-tab title="Races"\>\</ns-tab\>

\<ns-tab title="About"\>\</ns-tab\>

\</ns-tabs\>

我们需要一个外部的Tabs组件，它必须能够搞清楚组件模版内部有多少个ns-tab指令，迭代它们，并生成合适的标记语言。

为此，我们先创建一个指令tabDirective：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: 'ns-tab'

})

export class TabDirective {

\@Input() title: string;

}

这个指令做的不多：它只有一个获取tab标题的输入。注意我们使用了一个元素作为选择器,ns-tab。

现在我们需要构建TabsComponent:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-tabs',

template: \`

\<ul class="nav nv-tabs"\>

\<li class="nav-item" \*ngFor="let tab of tabs"\>

\<a class="nav-link"\>{{ tab.title }}\</a\>

> \</li\>
>
> \</ul\>

\`

})

export class TabsComponent {

\@ContentChildren(TabDirective) tabs: QueryList\<TabDirective\>;

}

正如你看到的，模版中迭代了tabs数组为每个元素生成一个li元素。但是这个tabs数组从何而来？组件怎样知道两个ns-tab指令嵌入在ns-tabs组件中？这就是ContentChildren要做的事情了。

要获取到tabs的列表，我们需要使用ContentChildren，这里要应用于TabDirective。这就让我们获取了tabs的迭代列表，之后就可以将其用在NgFor上。由于这个列表的每个元素是一个TabDirective，所以我们能够访问其公共属性title，并显示tab的标题。

注意，如果出于某种原因，你有一个如下的模版：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ns-tabs\>

\<div\>

\<ns-tab title="Races"\>\</ns-tab\>

\</div\>

\<ns-tabgroup\>

\<ns-tab title="About"\>\</ns-tab\>

\</ns-tabgroup\>

\</ns-tabs\>

这种情况下，TabComponent中的QueryList只会包含第一个TabDirective。ContentChild和ContentChildren只会访问直接后代，会在ns-tabgroup组件上停止。

如果我们想要组件这种情况下也能够正常工作，可以在装饰器中设置一个选项：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-tabs',

template: \`

\<ul class="nav nav-tabs"\>

\<li class="nav-item" \*ngFor="let tab of tabs"\>

> \<a class="nav-link"\>{{ tab.title }}\</a\>
>
> \</li\>
>
> \</ul\>

\`

})

export class TabsWithDescendantsComponent {

\@ContentChildren(TabDirective, {descendants: true}) tabs: QueryList\<TabDirective\>;

}

现在它就能找到所有的TabDirective了！

tabs字段是一个QueryList，所以你也可以订阅变化，和我们在ViewChildren中看到的类似。再一次，QueryList在组件构造器甚至在ngOnInit中是不可访问的。要去定能够查询到内容（比如就是QueryList被填入了），使用ngAfterContentInit生命周期钩子。你也可以使用ngAfterContentChecked钩子，这样每次内容被检查都会被调用。

## 宿主监听器

当写一个指令的时候，通常要与宿主元素交互。

举个简单的例子：我们的顾客想要通过双击清楚输入中的文本。这种行为就可以封装在一个自定义的指令中，假设指令为InputClearDirective。它的选择器将是一个属性，叫做nsInputClear。当这个属性被添加到一个元素上时，我们想要监听这个宿主元素的双击事件。

让我们创建这个指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsInputClear\]'

})

export class InputClearDirective {

constructor(private element: ElementRef\<HTMLInputElement\>) {}

}

这样使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input nsInputClear\>

我们需要相应宿主元素（这里就是input）的'dblclick'事件来清除值了。

这里我们就需要用到HostListener装饰器了！这个装饰器可以应用于一个指令的方法，来告知框架这个方法对于宿主元素指定的事件需要调用。

我们这里这样写：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsInputClear\]'

})

export class InputClearDirective {

constructor(private element: ElementRef\<HTMLInputElement\>) {}

\@HostListener('dblclick')

clearContent() {

this.element.nativeElement.value = '';

}

}

现在，宿主元素每次触发'dblclick'，该指令就会清除输入的值。

注意它也可以监听全局事件，像是window:resize：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsWindowResize\]'

})

export class WindowResizeDirective {

\@HostListener('window:resize', \['\$event'\])

resize(event) {

console.log(\`The screen is being resized to \${event.target.innerWidth}\`);

}

}

注意到也可以在方法中访问事件，这是通过制定\['\$event'\]作为装饰器的第二个参数实现的。

## 宿主绑定

另一个用于创建高级指令和组件的装饰器时HostBinding。HostListener使我们能够和宿主元素的事件进行交互，HostBinding使我们能够和宿主元素的属性进行交互。

比如我们想要在一个输入有某种错误（比如required）的时候添加一个特定的CSS类（ is-required）。这个类可能增加了一个边框或者一个星号，这并不重要。它不会验证字段，它只是获取内置的Angular表单验证结果，使用这个结果来给输入添加样式。

再次，这种任务非常适合这个指令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsAddClassIfRequired\]'

})

export class AddClassifRequiredDirective {

}

我们在一个代码驱动的Angular表单中使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input formControlName="firstName" nsAddClassIfRequired\>

在一个模版驱动表单中使用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<input \[(ngModel)\]="user.name" required nsAddClassIfRequired\>

然后我们需要在我们的指令中获取输入的状态。Angular会自动验证字段，如果字段为必填但是没有填充，它会添加required错误。这里强大的依赖注入系统又帮助我们了！你可以让Angular注入到一个指令中另一个指令应用于同样的宿主，或者它的一个祖先中。

因为我们想要我们的指令与FormControlName或者NgModel一起工作，我们可以让Angular注入这两个。但是因为只有两者之一可用，所以就不能正常工作（通常只用input的一个或者另一个），Angular由于一个依赖不能提供所以会中断。这里有一个技巧，可以让Angular在一个依赖不能提供的时候继续执行：Optional装饰。

这样就能够工作了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

constructor(\@Optional() private formControl: FormControlName, \@Optional() private ngModel: NgModel) {}

但是我们没有做到最好。事实上，两个指令都继承自NgControl。所以我们不用注入其中之一，我们可以简单地让Angular给我们提供通用的NgControl！

\@Directive({

selector: '\[nsAddClassIfRequired\]'

})

export class AddClassIfRequiredDirective {

constructor(private control: NgControl) {}

}

现在我们有了对于NgControl的引用，就很容易知道这个字段是否有required错误了，只要使用方法hasError()就可以。最后如果确实有错误，我们就需要在宿主元素上添加is-required类。这里就是HostBinding登场的地方了！这个装饰器让我们能够绑定宿主元素的属性到我们指令的一个字段上。通常这样用：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@HostBinding('value') innerValue;

这样每次指令的innerValue属性变化的时候就能自动更新宿主的值。

我们这里，我们还没有一个要绑定的字段。但是我们可以定义一个getter根据字段的错误返回true或者false，并且使用HostBinding装饰这个值，以自动地添加或者删除is-required类：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Directive({

selector: '\[nsAddClassifRequired\]'

})

export class AddClassIfRequiredDirective {

constructor(private control: NgControl) {}

\@HostBinding(class.is-required)

get isRequired() {

return this.control.hasError('required');

}

}

这几行代码功能强大：在表单中使用这个指令的时候，Angular会自动地添加或删除我们的自定义类，而这是基于用户输入的值的！

它也可以被用来绑定其它的属性，而不仅仅是CSS类。比如，一些组件库使用它添加可访问属性（aria.xxx）到一个宿主元素上。

注意我们构建的指令有一个自定义的选择器，但是如果你决定将这些指令应用于每个输入，你可以将它们的选择器修改为input，然后它们就会自动地应用到应用的每个输入上了。

# 国际化

好吧，如果你你不懂上面的英文介绍也不用担心。你的角色是开发者，而不是将你的应用翻译成法语、西班牙语或者其它语言。你能做的就是提供一种支持翻译的方式。本章就会说明如何来做。

## locale

我们之前已经提到过国际化了，那还是在关于管线的那一章。Angular内置的四个管线与国际化有关。它们是number、percent、currency和date。在Angular 5之前，它们都是依赖于标准的JavaScript国际化API的，而这些API都是由浏览器提供的。但是浏览器的支持并不完善，浏览器之间的不一致性问题导致了大量bugs，这些管线在Angular 5.0中被完全修复了。

我们现在还不知道这些管线怎样去格式化数字和日期。是使用一个点还是一个都好来作为小数的分隔符呢？每年的第一个月应该是January还是Janvier呢？你可能会认为这基于浏览器中设置的语言配置，但是事实上并不是这样的。这基于一个可以注入的叫做LOCALE\_ID的值。默认值为'en-US'。

这里有一个例子来展示如何获取到LOCALE\_ID的值。正如你看到的，它是一个简单的字符串值。要将其注入到你的组件或者服务中，你不能只依赖它的类型。你需要告诉Angular那个符号标识了这个值，这可以通过使用\@Inject(LOCALE\_ID)来实现。如果你想知道应用正在使用那个locale，这就能用得上了：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-locale',

template: \`

\<p\>The locale is {{ locale }}\</p\>

\<!\-- 会显示'en-US' \--\>

\<p\>{{ 1234.56 \| number }}\</p\>

\<!\-- 会显示'1,234.56' \--\>

\`

})

class DefaultLocaleComponent {

constructor(\@Inject(LOCALE\_ID) public locale: string) {}

}

这很好。但是我们怎样改变locale呢？事实上是不能的。locale是一个常量，一旦应用启动就不能改变了。但是这并不意味着在应用启动之前无法改变它。这是可以的，简单地在你的根Angular模块中为LOCALE\_ID提供另一个值就可以了。但是也要知道：这会改变locale，另一步是在应用中绑定和此locale相关的数据（月份翻译，数字格式规则等）。Angular只是默认绑定了en-US的数据。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

import { registerLocaleData } from '\@angular/common';

import localeFr from '\@angular/common/locales/fr';

registerLocaleData(localeFr);

这里显示它对我们组件的效果：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@NgModule({

imports: \[BrowserModule\],

declarations: \[CustomLocaleComponent\], // 添加其它组件

providers: \[

{provide: LOCALE\_ID, useValue: 'fr-FR'}

\]

// ...

})

export class AppModule {}

\@Component({

selector: 'ns-locale',

template: \`

\<p\>The locale is {{ locale }}\</p\>

\<!\-- 会显示'fr-FR' \--\>

\<p\>{{ 1234.56 \| number }}\</p\>

\<!\-- 会显示'1 234,56' \--\>

\`

})

class CustomLocaleComponent {

constructor(\@Inject(LOCALE\_ID) public locale: string) {}

}

所有处理国际化的管线都能接受一个locale作为它们最后的参数。你可以根据需要动态改变它们：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\@Component({

selector: 'ns-locale',

template: \`

\<p\>The locale is {{ locale }}\</p\>

\<!\-- 会显示'en-US' \--\>

\<p\>{{ 1234.56 \| number:'1.0-3':'fr-FR' }}\</p\>

\<!\-- 会显示'1 234,56' \--\>

\`

})

class DefaultLocaleOverriddenComponent {

constructor(!Inject(LOCALE\_ID) public locale: string) {}

}

如果你需要创建一个只支持一个不同于en-US的locale的应用，只需要像上面设置一个不同的locale就可以了。但是通常，这还不够，你想要将你的应用真正国际化。

## 翻译文本

如果你之前使用过AngularJS 1.x，并且为你的AngularJS应用做过国际化，你应该会知道没有基于用户的语言偏好而展示翻译文本的内置方式。

一个用于此目的的支持AngularJS的库叫做angular-translate。使用的策略也非常普通：你使用一个指令或者一个管线来翻译一个键（比如'home.welcome'）。这个键代表了一个信息，你提供所有想支持的语言的翻译（比如'Welcome'和'欢迎'）。运行时，指令或者管线根据偏好语言获取对应的翻译，然后使用翻译后的语言跟新DOM。你可以在运行时修改偏好语言，所有页面上的信息就会立即被翻译成新的语言。

现在Angular直接提供了国际化支持（尽管在Angular 4.0之前很难用）。再也不需要依赖外部的库了。它的策略也基本上是基于键的，但是有一个大的不同：它是运行于编译期而非运行时。当应用启动，或者使用Angular的AOT编译器，在构建应用时，Angular解析组件中所有的HTML模版，将它们转换成JavaScript代码，分析模型的变化并修改相应的DOM。这就是翻译发生的时机。这导致了几个结果：

-   运行时不可以改变locale和翻译的信息。需要重新加载整个应用和重启才能做到。

-   一旦开启，应用会更快，因为它不需要动态地一遍又一遍地对键进行翻译

-   如果使用AOT编译器（应该，至少在生产环境中），你必须构建和运行和支持的locales数量相同的应用。

## 处理和加工

本章的后续部分，会假设你使用了Angular CLI来构建应用。工具实际上可以在Angular CLI之外使用，因为它们是Angular ngc编译器的一部分。但是它们和Angular CLI集成很好并且使用上更简单，所以推荐使用它来构建应用，我们就是这样做的。

我们也会使用AOT编译器来构建和部署我们的国际化版本的应用。这确实是最简单的方式。如果你想在JIT模式下测试国际化（没有构建期的预编译），需要修改用于启动应用的代码。可以参考官方文档的internationalization cookbook来了解更多。

那么，我们怎么继续呢？你现在知道怎么创组件和它们的模版。你需要完全重写它们以支持国际化吗？谢天谢地，不需要。过程如下：

-   你使用i18n属性来标记模版中需要翻译的部分

-   运行一个工具将所有标记的部分提取到一个文件中，比如messages.xlf。两种文件格式，基于xml的格式和工业标准格式都是支持的

-   你使用组件翻译器创建一个这个文件的翻译版本，比如messages.fr.xlf

-   通过提供的locale ID（比如'fr'）和对应的翻译文件（messages.fr.xlf）来构建应用。angular编译器和CLI将模版中i18n标记的部分用这个文件中的翻译替代，并且将你的应用配置为使用提供的locale ID。

我们看一下每步的细节。

## 使用i18n标记文本并提取

我们用一个示例模版开始：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h1\>Welcome to Ponyracer\</h1\>

\<p\>Welcome to Ponyracer {{ user.firstName }} {{ user.lastName }}!\</p\>

\<img src="/img/pony.gif" alt="running pony" title="Ponies are cool, aren't they?" /\>

Lest start playing.

这个模版中有5个片段需要被翻译。当然，你可能想要一次性翻译所有东西，但是十几种，那会暴露给翻译者很多的HTML样板，你也不想在HTML结构变化的时候去修改翻译。所以你需要分别翻译5个片段。

其中之一，还h1元素的内容，是纯静态文本。其中之一包含两个插值表达式。还有HTML的属性。最后一个是没有被任何元素包含的静态文本。

这里是你如何标记它们。让我们从个第一个，最简单的开始：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h1 i18n\>Welcome to Ponyracer\</h1\>

现在让我们提取第一个信息文件，使用Angular CLI提供的xi18n命令：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ng xi18n \--output-path locale/

这会在src/locale目录下创建文件messages.xlf。这里是它包含的信息：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<?xml version="1.0" encoding="UTF-8"\>

\<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2"\>

\<file source-language="en" datatype="plaintext" original="ng2.template"\>

\<body\>

\<trans-unit id="5e3335d7f1a430ef14a91507531838c57138b7f2" datatype="html"\>

\<source\>Welcome to Ponyracer\</source\>

\<context-group\>

\<context context-type="sourcefile"\>app/app.component.ts\</context\>

\<context context-type="linenumber"\>2\</context\>

> \</context-group\>
>
> \</trans-unit\>
>
> \</body\>

\</file\>

\</xliff\>

正如你看到的，它生成了一个trans-unit，它包含了我们的源，也就是静态文本。法语翻译者会收到一个messages.fr.xlf的文件，像下面这样：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image14.png){width="5.805555555555555in" height="2.3472222222222223in"}

者足够简单了，因为源信息非常容易理解。你不需要再费心去搞清楚它是关于什么的，怎样去翻译它。但是这种方式有一个大的缺点。如果你改变了模版的代码，引入了无意义的空格，或者在标题后面添加了一个点，当再次提取文件的时候就会发生：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h1 i18n\>

Welcome to Ponyracer.

\</h1\>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image15.png){width="5.833333333333333in" height="1.8333333333333333in"}

不仅仅是源改变了，也就是所预期的，id也变化了。者使得维护翻译信息文件更加困难了。幸运的是，有一种更好的方式。你可以自己提供一个独一无二的ID：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h1 i18n="@\@home.title"\>Welcome to Ponyracer\</h1\>

就会生成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image16.png){width="2.8194444444444446in" height="2.2222222222222223in"}

事实上，为了为你的翻译者提供更多的上下文信息，你可以在信息ID之外提供一个有意义的的描述：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<h1 i18n="welcome title\|the title of the home page@\@home.fullTitle"\>

Welcome to Ponyracer

\</h1\>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image17.png){width="5.833333333333333in" height="2.6666666666666665in"}

让我们进入到第二个片段：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p i18n="@\@home.welcome"\>Welcome to Ponyracer {{ user.firstName }} {{ user.lastName }}!\</p\>

这是生成的东西：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image18.png){width="6.180555555555555in" height="2.5555555555555554in"}

正如你看到的，这个格式有几个有趣的地方：

-   翻译者不会被angular表达式搞晕，因为它在信息中明确指明了

-   很明显两个插值是开发者关心的，但是给翻译者解释一下也是一个好主意

-   如果在一些语言中，first name和last name顺序是相反的，那翻译者也能够自由调整

-   如果开发者选择修改组件或者用户的属性，也不需要重新翻译。

让我们继续看一下img元素中的两个元素。翻译属性的语法如下：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<img src="/img/pony.gif"

alt="running pony" i18n-alt="@\@home.ponyImage.alt"

title="Ponies are cool, aren't they?" i18n-title="@\@home.ponyImage.title"/\>

这会生成：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image19.png){width="2.8333333333333335in" height="3.6666666666666665in"}

最后，怎样翻译最后一个片段呢？我们没有地方放置i18n属性了。有一种方式来解决这个问题：使用ng-container元素，运行时它不会渲染到DOM中：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<ng-container i18n="@\@home.startMessage"\>

Let's start playing.

\</ng-container\>

## 翻译、构建和部署应用

现在你创建了一个完整的messages.xlf文件，需要人翻译它。一个常犯的错误是将源文本（我们这里是英语）直接替换成它的翻译。这不行。翻译必须写在每个翻译单元的\<target\>元素内。\<source\>元素不能动：它提供了翻译的原始信息。比如：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image20.png){width="6.208333333333333in" height="1.8888888888888888in"}

要以法语运行并构建应用，你需要指定locale，还有消息文件的位置，然后使用ng serve或者ng build：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ng build \--aot \--i18n-locale fr \--i18n-file src/locale/messages.fr.xlf

或者你可以在angular.json中为locale定义一个配置：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

"fr": {

"aot": true,

"i18nFile": "src/locale/messages.fr.xlf",

"i18nLocale": "fr"

}

然后运行：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ng build \--configuration=fr

AOT编译器会定位到i18n在模版中标记的片段，在XLF文件中找到对应的翻译，并使用这个翻译在模版中翻译片段。然后就会像往常一样从模版生成JavaScript代码，并打包应用。

如果你想要支持英语、法语和西班牙语，你需要三次构建应用（每次一个），并在生产web服务器上部署3个构建的应用。你也要定义那个应用服务哪个用户。这可以在服务端进行，通过检测请求头的偏好locale，并返回合适的index.html页面。或者从数据库中获取认证用户的偏好，返回合适的index.html也买呢。也可以在客户端做，将三个应用部署在不同的URL下(ponyracer.com, ponyracer.fr, ponyracer.es，或者ponyracer.com/en, ponyracer.com/fr, ponyracer.com/es)，基于浏览器的locale从ponyracer.com重定向到正确的URL。

## 在代码中翻译信息

有时，你需要翻译的代码并不在模版中，而是在TypeScript代码中。比如，小马比赛的三个状态PENDING、RUNNING和FINISHED也需要被翻译出来。当前的设想是能够这样做：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

const RaceStatus = {

PENDING: \_\_('pending'),

RUNNING: \_\_('running'),

FINISHED: \_\_('finished')

}

不幸的是，这还没有实现。一个临时的解决方案，需要基于LOCALE\_ID从服务器加载一个JSON翻译文件。

## 复数

有时，你需要展示的信息是基于集合中元素的数量，或者是基于元素的计数的。比如我们的首页显示今天设定好的赛事。你可以简单的显示："Number of planned race(s): 4"。但是一个更加友好的信息应该是，如果没有赛事就显示："No race is planned"， 如果只有一个赛事就显示："Only one race is planned"，如果是其它情况就显示"N races are planned"。

Angular确实有特殊的模版语法来支持这些。很难阅读，除非对于LISP程序员而言，但是通过下面的例子它确实能够做到并且很容易理解。建设我们的组件有一个属性叫做racesPlanned，它包含了今天计划的赛事的数量。你可以这样展示它：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p\>

Hello, {racesPlanned, plural, =0 {no race is planned}

> =1 {only one race is planned}
>
> other {{{{ racesPlanned }} races
>
> are planned}}

\</p\>

要国际化这个信息，使用i18n属性就可以：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\<p i18n="@\@home.racesPlanned"\>

Hello, {racesPlanned, plural, =0 { no race is planned }

> =1 {only one race is planed}
>
> other {{{ racesPlanned }} races are planned}}

\</p\>

提取生成两个翻译单元，一个是对于信息自身的，一个打包在信息中的表达式的：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image21.png){width="6.5in" height="3.9451388888888888in"}

不幸的事，第二个翻译单元有一个自动生成的ID，复数语法必须理解并且被翻译者注意。

还是可以翻译这两个翻译单元的，翻译也以预期的行为工作：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

![](https://github.com/maiernte/img/raw/master/books/angularninjia/image22.png){width="6.5in" height="3.3756944444444446in"}

## 最佳实践

在多年以来i18n应用中获得最佳实践和Angular并没有密切的关系，而是和i18n自身有关的。

总是要为你的信息指定一个独一无二的ID。如果你选择了一个有意义的ID，你就不需要指定一个信息的意义和描述了，因为ID就够用了。以它们所在的组件的名字作为前缀（像是我们在所有例子中的home.前缀）使我们能够了解它们用在什么地方，并且能够容易的在代码中找到。使用自动生成的ID不允许为两个相同的源语言信息具有不同的翻译。也使得应用两个版本之间应该改变什么变得难以搞清楚。

尽管翻译者并不总是开发者，还是要将信息文件存储在版本控制系统中。这能够确保一个分支可以有其自身的附加信息，当准备好之后合并到主分支。它使得比较不同分支和版本之间的不同变得容易。

重复并不总是坏的。你可能想到两个页面共享一个标签"Save"或者"OK"应该使用相同的键，但是稍后你可能想要用"OK, I'll do it"和"OK, I accept"来作为它们的标签。或者它们需要在不同的外语中有一些不同。对于那些在英语中相同，而在外语中有不同意义的英语单词使用不同的键就更加重要了，像是"free"，可以是"free as in beer"或者是"free as in speech"。其它语言对于这两个概念会使用不同的词语。

不要将语言和国家搞混。不要使用国旗来代表语言。一些语言（像是英语）在多个国家被使用。一些国家同时使用多种语言（像是比利时，使用了法语、荷兰语和德语）。

避免使用连接来翻译文本。比如，要翻译"Hello, my name is X and I'm Y years old"，不要将"Hello, my name is"作为第一个键，"an I'm"作为第二个键，"years old"作为第三个键。而是要使用一个单一的key，其包含插值表达式。

你现在已经准备好使用你漂亮的i18n Angular应用来统治世界了。

# 结束了

感谢你的阅读！

后续的版本中将会增加其它的章节，像是路由器（第一个版本还没有完全完成），一些高级知识和其它好东西。它们都需要更多的打磨，但是我们确信你会乐在其中的。当然，我们会紧跟框架的发行版本，所以你不会错过新的特性。本书的未来更新都是免费的。

如果你喜欢你读到的东西，告诉你的朋友！
